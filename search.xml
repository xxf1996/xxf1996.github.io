<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[shape-outside属性及其应用]]></title>
    <url>%2Fpost%2Fcss-shape-outside%2F</url>
    <content type="text"><![CDATA[前言 shape-outside这个属性实在是太冷门了，要不是去研究&lt;basic-shape&gt;数据类型，还真不会发现这个属性；但是其兼容性也还算可以，PC端完全没问题，移动端iOS是支持比较好的，而安卓端则不太支持： shape-outside是CSS Shapes Module Level 1规范中提出的一个属性，用于设置浮动元素周围内联元素对其包裹的形状，也就是说借助shape-outside属性可以使得浮动元素周围的文字不再是围绕盒模型进行环绕，而是可以指定任意形状进行环绕，达到更丰富的文字环绕效果；比如： shape-outside及相关属性 CSS Shapes Module Level 1规范中不止设计了shape-outside一个属性，还有配合该属性一起搭配使用的属性：shape-image-threshold和shape-margin； shape-outside shape-outside属性的作用不再多说，语法如下： none | [ &lt;basic-shape&gt; || &lt;shape-box&gt; ] | &lt;image&gt;[1] none：默认值，即默认的浮动区域（Float area），默认的浮动区域就是margin-box； &lt;basic-shape&gt;：基本形状类型； 123456789101112131415161718192021222324252627282930313233@keyframes shape &#123; 0% &#123; clip-path: circle(); shape-outside: circle(); &#125; 25% &#123; clip-path: ellipse(50% 30px); shape-outside: ellipse(50% 30px); &#125; 50% &#123; clip-path: inset(30px 20px round 15px); shape-outside: inset(30px 20px round 15px); &#125; 75% &#123; clip-path: polygon(50% 0%, 100% 100%, 0% 100%); shape-outside: polygon(50% 0%, 100% 100%, 0% 100%); &#125; 100% &#123; clip-path: polygon(50% 100%, 0% 0%, 100% 0%); shape-outside: polygon(50% 100%, 0% 0%, 100% 0%); &#125;&#125;.container &#123; overflow: hidden;&#125;.box &#123; float: left; width: 200px; height: 200px; margin: 10px; background-color: coral; animation: shape 5s linear alternate infinite;&#125; 上面这个动画就是展示了各种基本形状应用于shape-outside上的效果； 但是需要注意的是，&lt;basic-shape&gt;数据类型有一个参考盒模型的概念，对于shape-outside属性而言，默认的参考盒模型是margin-box，但是可以在属性中同时使用&lt;shape-box&gt;来指定一个参考盒模型！如： 123.demo &#123; shape-outside: content-box circle();&#125; 这样就把shape-outside属性的参考盒模型指定为content-box了！ &lt;shape-box&gt;：盒模型类型，包含margin-box、border-box、padding-box和content-box； &lt;image&gt;：图像类型，包括url()函数引入的图像和渐变色；图像作为形状时，是根据图像的alpha通道（即透明通道）来作为形状的边界的，具体的通道阈值要取决于shape-image-threshold属性的值； shape-margin 这个属性的作用很简单，就是沿着shape-outside属性生成形状再向外扩展相应的距离，不过扩展后的形状不能超过参考盒模型的区域！ 123456789.box &#123; float: left; width: 200px; height: 200px; shape-margin: 10px; background-color: coral; clip-path: circle(); shape-outside: content-box circle();&#125; 上面这个例子可以看到，尽管shape-margin讲形状向外扩展了10px，但是超出content-box区域外的部分并不视为浮动区域； 那么有没有办法使得浮动区域整体向外扩展相同的距离呢？就像margin属性的效果那样？答案是有，就是将margin-box设置为参考盒模型，然后使用margin属性即可！ 123456789.box &#123; float: left; width: 200px; height: 200px; margin: 10px; background-color: coral; clip-path: circle(); shape-outside: circle();&#125; 因为参考盒模型为margin-box，所以设置margin属性可以扩大margin-box的大小，因此浮动区域也相应地扩大了，也就达到了类似一般盒模型中margin的效果； shape-image-threshold 这个属性是专门用来设置图片形状提取时透明通道的阈值，范围为0 ~ 1，默认值为0；阈值为n代表图片中透明通道值大于n的区域都是浮动区域。 123456789.box &#123; --img: linear-gradient(45deg, rgba(220, 0, 0, 1), rgba(200, 0, 0, 0)); float: left; width: 200px; height: 200px; background: var(--img); shape-outside: var(--img); shape-image-threshold: 0.5;&#125; 由于将阈值设置成了0.5，根据上面渐变色的特点可知，透明度为0.5的分界线刚好在左上-右下对角线上，上面这个例子也能看出；不仅如此，chrome浏览器还会贴心地把浮动区域给标记出来： 上面这个动图就是阈值从0到1递增的过程，可以看到阈值也是能插值的； 相关应用 上述属性的意图本来就很明显，就是设置不规则的浮动区域，到达更丰富更自然的图文混合效果；所以常用来配合带透明通道的图片进行更贴近图案的图文混合效果。 透明通道图片图文混合 上面这个苹果Logo就是带透明通道的，可以看到文字与图片中的图案有更好的贴近效果； 这种效果很适合用来对图片进行讲述的排版，有点类似科普书中那种图文讲解排版，比如这个作品： 异形文字排列区域 利用各种浮动区域的拼接或者组合，可以将文字包围在一个任意形状中，看起来会有很震撼的效果，比如下面这个作品： 通过左右两个多边形浮动区域，将文字挤在在一个心形的区域中，很有创意；袁川大佬也有一个类似的作品： 可以看到这个作品整体呈现脸的轮廓，而那些符号都是随机生成的文字，右侧是有一个由多边形绘制而成的脸轮廓形状的浮动区域，所以左侧的文字贴近右侧浮动区域时就形成了脸的轮廓；当然，这个作品的亮点还不只有shape-outside，这里面还用到了滤镜来组合调制颜色，以及文字渐隐处理所用到的mask，还有随机生成文字用到的CSS变量等等； 更复杂的文字排版 虽说shape-outside属性的初衷是为了不规则形状的浮动，但是也可以用来进行更加复杂和不规则的文字排版，比如有个大神就用CSS grid布局 + shape-outside实现了维恩图文字排版： 相关文档 写给自己看的CSS shapes布局教程 « 张鑫旭-鑫空间-鑫生活 https://drafts.csswg.org/css-shapes/#shape-outside-property ↩︎]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[basic-shape 数据类型]]></title>
    <url>%2Fpost%2Fcss-basic-shape%2F</url>
    <content type="text"><![CDATA[前言 &lt;basic-shape&gt;是一种特殊的CSS数据类型，用于表示使用基本形状函数，从而应用相应的形状或路径；目前支持&lt;basic-shape&gt;类型的属性有： shape-outside：该属性用于指定周围内联元素环绕时所包围的形状； clip-path：该属性用于指定所属盒模型的裁剪形状； offset-path：该属性用于指定元素移动的路径，属于offset属性中的一个； 形状函数 关于参考盒模型 由于形状作用的盒模型根据具体的CSS属性有所不同，它可以是margin-box、padding-box、border-box和content-box中的任何一个，因此用参考盒模型来指代这个具体的盒模型； When using this syntax to define shapes, the reference box is defined by each property that uses values. [1] inset inset函数定义了一个矩形形状，只不过这个矩形是由参考盒模型四个边框向内形成的内嵌矩形；语法如下： inset( &lt;length-percentage&gt;{1,4} [ round &lt;‘border-radius’&gt; ]? )[2] 可以看出参数分为两个部分，前面是1-4个长度/百分比参数，用于设置矩形距离参考盒模型相应方向的边框距离； 1个值：所有方向的距离一致，百分比为对应方向上盒模型的长度； 2个值：第一个值代表上和下方向，第二个值代表左和右方向； 4个值：依次为上、右、下和左，顺时针方向； 后面一组是可选参数，为round关键字加上border-radius的语法，用于设置内嵌矩阵的圆角效果；如： 123.demo &#123; clip-path: inset(20% round 45px);&#125; circle 顾名思义，circle函数就是用于指定一个圆形形状，语法如下： circle( &lt;shape-radius&gt;? [ at &lt;position&gt; ]? )[3] 参数依然是两个部分，第一个参数为半径，是可选的，默认值W3C文档上没有说明，但是据观察为盒模型的最短边的一半（注意：这可与50%的效果是不一样的！）；当使用百分比时，长度的参照值为： height2+width2/2\sqrt{height^2 + width^2} / \sqrt{2} height2+width2​/2​ 这里的宽度和高度指的都是参考盒模型；后面一个参数也是可选的，为at关键字加上一组坐标位置，用于指定圆心坐标，坐标默认值为center； ellipse ellipse函数则是指定一个椭圆形状，语法如下： ellipse( [ &lt;shape-radius&gt;{2} ]? [ at &lt;position&gt; ]? )[4] 同样，这里参数也是两个部分，都是可选的；第一部分为半径，两个参数（注意：这里要么完全省略，要么只能两个参数都写，一个参数是非法的！），第一个参数为x方向半径，第二个参数为y方向半径，默认值为50% 50%；第二部分与circle函数类似，用于指定椭圆中心位置，默认值为center； polygon polygon函数则是用来绘制任意多边形状的，语法如下： polygon( &lt;‘fill-rule’&gt;? , [&lt;length-percentage&gt; &lt;length-percentage&gt;]# )[5] 第一个参数fill-rule是可选的（需要注意的是第一个参数与后面的参数需要加上逗号分隔），用于指定多边形内部区域识别的算法，有以下选项： nonzero：默认值 evenodd 关于nonzero和evenodd算法之间的区别，可以参考：fill-rule - SVG | MDN ; 第二个参数则是一组坐标值，坐标值就是多边形的顶点位置，一个顶点坐标有两个值，用空格分隔，而不同顶点坐标之间则用逗号分隔；如： 123.demo &#123; clip-path: polygon(50% 20%, 90% 80%, 10% 80%);&#125; 坐标值的原点位置是参考盒模型的左上角； path path函数则是利用SVG path语法来绘制形状和路径，不过目前兼容性很受限；语法如下： path( [&lt;‘fill-rule’&gt;,]? &lt;string&gt; )[6] 第一个参数为可选的，用于指定fill-rule；第二个参数为SVG path字符串，用于指定路径；SVG path语法可以参考：d - SVG: Scalable Vector Graphics | MDN 插值规则 由于&lt;basic-shape&gt;数据类型是支持插值的，这就意味着该属性可以被应用到animation和transition属性中；但是插值规则并非可以直接从一种形状到另一种形状，只是对形状函数的参数数值进行插值而已；从W3C的文档[7]可知，basic-shape数据类型进行插值必须满足以下条件： 参考盒模型必须一致； 形状类型必须一致； ellipse和circle的中心点位置不能包含closest-side和farthest-side关键词； polygon形状的fill-rule必须一致，且顶点数量要相同； 1234567891011.box &#123; width: 200px; height: 80px; clip-path: inset(10px round 20px); background-color: coral; cursor: pointer; transition: clip-path .5s ease-in;&#125;.box:hover &#123; clip-path: ellipse();&#125; 可以看到上面这种不同形状函数之间是不能进行插值的； 1234567891011.box &#123; width: 200px; height: 80px; clip-path: inset(10px round 20px); background-color: coral; cursor: pointer; transition: clip-path .5s ease-in;&#125;.box:hover &#123; clip-path: inset(20px round 20px);&#125; 而上面这种同类型形状函数之间就可以进行数值插值了； 相关扩展 &lt;position&gt;数据类型 顾名思义，这种类型的数据专门用来表示位置的；语法[8]如下： 可以是一个值，也可以是两个值；一个值表示x位置和y位置是一致的，两个值则分别表示x位置和y位置； x位置：可以是&lt;length-percentage&gt;（即长度类型 + 百分比类型）类型数据，还可以是left（0%），center（50%），right（100%）等关键词； y位置：可以是&lt;length-percentage&gt;，还可以是top（0%），center（50%），bottom（100%）等关键词·； &lt;shape-radius&gt;数据类型 同理，该类型用于表示形状的半径长度，语法如下： &lt;shape-radius&gt; = &lt;length-percentage&gt; | closest-side | farthest-side[9] closest-side：半径长度为中心点到盒模型边框最近的一边之间的距离； farthest-side：半径长度为中心点到盒模型边框最远的一边之间的距离； 相关文档 &lt;basic-shape&gt; - CSS（层叠样式表） | MDN CSS Shapes Module Level 1 offset-path - CSS: Cascading Style Sheets | MDN CSS的图形（Shape）概览 - CSS（层叠样式表） | MDN shape-outside - CSS（层叠样式表） | MDN https://drafts.csswg.org/css-shapes/#reference-box ↩︎ https://drafts.csswg.org/css-shapes/#funcdef-inset ↩︎ https://drafts.csswg.org/css-shapes/#funcdef-circle ↩︎ https://drafts.csswg.org/css-shapes/#funcdef-ellipse ↩︎ https://drafts.csswg.org/css-shapes/#funcdef-polygon ↩︎ https://drafts.csswg.org/css-shapes/#funcdef-path ↩︎ https://drafts.csswg.org/css-shapes/#basic-shape-interpolation ↩︎ https://drafts.csswg.org/css-values-3/#position ↩︎ https://drafts.csswg.org/css-shapes/#typedef-shape-radius ↩︎]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[transform相关H5案例]]></title>
    <url>%2Fpost%2Fcss-transform-h5%2F</url>
    <content type="text"><![CDATA[前言 现在H5中应用了大量的CSS动效，而这些动效很多都与transform属性相关（没办法，transform就是天生适合产生动效的），借助和分析比较典型的H5案例可以更好地应用transform属性； 恕我直言，一看就不是什么正经猫【网易】 活动地址：http://gongyi.163.com/special/meowkingdom/ 活动类型：创意H5游戏 简介：这个活动的主体就是一个模拟俄罗斯方块的游戏，只不过把方块的形状用相应的不正经的猫姿势进行了替换；游戏使用的是PIXI库进行搭建的，其余状态都是都是普通的H5元素，有比较多的动画，动画基本上都是图片拆解，然后部分使用transform进行动态变化； 上面这个是游戏部分，跟transform相关的部分是其他地方； 动画拆解 从上图可以看出，游戏前画面是有多处css动画的，而这些动画大多和transform有关： 中心旋转：即变换中心为默认的center center； 边缘旋转：此处变换中心是图片的右边缘中心，即right center； 缩放 + opacity：放大 + 不透明度变低； 帧图片播放动画：这个马赛克动画实际上就是只有两帧的动画图片，然后循环播放；这个抖动本来还以为也是transform模拟出来的，但看源码实际上就是一个四帧的动画图片进行的播放，毕竟仔细看这个动画有扭曲变化，这个transform目前真的无能无力…… backgroud-position：这个地方看似有点像缩放，但实际上就是图片在y方向变化而已； 2014腾讯互动娱乐年度发布会邀请函 活动地址：http://up.qq.com/2014/invitation/main.html 活动类型：单屏滑动页面 简介：这是一个典型的单屏滑动活动页，基本上就是滑动切换上下屏，每屏有不同的内容；主要关注点就是切换上下屏之间的过渡动画效果，以及每屏出现时小物件的活动轨迹和动画； 从上面看出，这里面确实有大量的CSS动画，而且很多都是和transform相关的，所以还是重点关注一下比较有趣的地方； 值得注意的地方 注：下面的gif图所展现的不一定是原速，因为可能是通过chrome浏览器自带的animation面板进行手动录制的； 关注游戏机这个图标的动画，可以明显的看出这个动画是组合动画，分为几个阶段： 中心旋转 + 放大 + opacity变大 旋转 + 平移：这个阶段动画看起来像是沿着边缘进行旋转，但实际上看源码是边平移边旋转； 这个地方实际上是一组元素形成的扩散动画，每个元素本身的动画都是一致的，就是平移 + 旋转 + 不透明度变化，只是每个元素平移的方向不同，形成了扩散效果； 这个地方的三角形运动轨迹形似S，实际上动画就是利用连续两次的平移 + 旋转，然后旋转方向有所不同，形成连续且丝滑的运动轨迹； 这段开门的动画主要是利用透视投影，然后再进行绕Y轴向后旋转，形成立体的真实感； 相关文档 有什么好的微信H5活动案例？ - 知乎 H5列表：H5案例网站 H5案例分享 - 创意H5案例，一搜即得：H5案例网站 H5玩法知多少？腾讯超多实战案例让你大开眼界！ | 优设网 - UISDC]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>H5</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[transform应用场景的探索]]></title>
    <url>%2Fpost%2Fcss-transform-apply%2F</url>
    <content type="text"><![CDATA[前言 transform属性是CSS基于图形学中矩阵变换和投影变换实现的产物，因此理论上基于矩阵变换和投影变换的视角效果都可以使用transform实现；诸如canvas/webGL中常见的立体/3D效果，物理运动效果等等，都可以等价转化为transform中的变换函数，只不过CSS的控制粒度目前只能局限于关键帧，无法对动效进行每一帧的控制（那种通过js来修改css的方式也算不上是控制每一帧，倒是目前还在实现中的CSS Houdini规范可以做到）； 下面只是一些简单的初步探索，后续可能会发现更多有趣的应用。 立体hover效果 实现逼真的立体效果，肯定需要开启透视投影；而透视投影可以对某个元素单独设置，也可以对容器元素进行设置； 单个元素：单个元素可以直接使用perspective()这个transform-function，这样当前元素就会具有透视投影效果，而不需要依赖其容器元素； 容器元素：容器元素则可以直接通过perspective属性进行设置，这样就相当于创建了一个独立的相机空间，也就是其子元素默认具有相同的投影设置（前提是容器元素的transform-style``为preserve-3d）；这种方式再配合z坐标（即translateZ或者能够改变z坐标的变换），就能很方便地对整个容器内元素进行立体效果模拟； Demo地址：3D transform button hover effect 模拟物理运动 弹性形变 在真实世界中，物体的运动或者冲击通常会产生形变，如果在类似的运动动画中加上模拟形变的效果，就会显得更加的真实；同样地，transform也可以模拟这些运动形变，模拟的诀窍就是观察这些运动形变的关键帧特点，以及形变和速度变化/大小之间的关系； 上述这些形变都是弹性形变，属于比较简单和直观的，通常是在一个或两个方向上不停地震荡，然后趋于稳定，因此模拟起来比较简单；下面是Demo地址： CodePen - css transform animation: physical movement CodePen - css transform animation: physical movement 2 刚体碰撞 如果是要模拟诸如刚体碰撞这样的效果，那就会有点棘手，因为其中除了会有物体变换，还会有变换中心（transform-origin）的改变，这样就需要观察关键帧在对应时间点应该使用哪个位置作为变换中心了； Demo地址：CodePen - css transform animation: rigid body motion 注：刚体碰撞是刚体运动的一种，所谓的刚体运动简单地来说就是只有旋转和平移变换，即不发生形变； 视差滚动H5 所谓的视差滚动简单的可以理解为：视觉层面上有不同景深（即z坐标）的平面，当滚动时不同景深之间的移动速度有差异，这种差异就会形成视差； 利用transform的透视投影确实可以做到简单的视差滚动效果，但考虑到很多视差效果的H5交互作品通常具有很多场景元素，这时纯靠CSS那显然是吃力的，所以借助成熟的3D渲染框架来实现比较好，比如：PIXI，这类框架一般是基于图形学和游戏制作的框架概念实现的，因此更适合制作较更多元素更复杂的动画/交互展示； 这里有两个优秀的应用视差效果的H5可以推荐一下： 态度日历 让每一天更有趣 别不相信，你是一颗星星 相关文档 Candy Color Button Animation：很棒的按钮hover效果 Rotating Text https://blog.prototypr.io/this-aint-disney-a-practical-guide-to-css-transitions-and-animations-a8b87e7c5531 Android 中基于物理特性的动画简介 - 知乎 https://zh.wikipedia.org/wiki/形變]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>计算机图形</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[transform属性的数学原理]]></title>
    <url>%2Fpost%2Fcss-transform-math%2F</url>
    <content type="text"><![CDATA[前言 transform本质上就是一个仿射变换（即线性变换 + 平移），从CSS给定的transform-function可以看出，内置的函数将变换分为了2D变换和3D变换两种，但是从CSS规范来看，2D变换函数也只不过是3D变换函数的特殊形式而已，所以transform属性从原理上来说就是一个3D仿射变换函数。 关于仿射变换的详细数学解释，可以参考：如何通俗地讲解「仿射变换」这个概念？ - 马同学的回答 - 知乎 https://www.zhihu.com/question/20666664/answer/157400568 仿射变换的核心就是变换矩阵了，因此transform属性的两个核心函数就是matrix()和matrix3d()； matrix()函数 仿射变换通常是通过齐次坐标进行变换的，因此2D变换矩阵也就相应地变成了3x3的齐次矩阵： [actxbdty001]⋅[xy1]\begin{bmatrix} a &amp; c &amp; t_{x} \\ b &amp; d &amp; t_{y} \\ 0 &amp; 0 &amp; 1 \end{bmatrix} \cdot \begin{bmatrix} x \\ y \\ 1 \end{bmatrix} ⎣⎡​ab0​cd0​tx​ty​1​⎦⎤​⋅⎣⎡​xy1​⎦⎤​ 上面就是matrix()函数的一般数学形式了，其中a,b,c,d,tx,tya, b, c, d, t_{x}, t_{y}a,b,c,d,tx​,ty​就是该函数的六个参数了；属于2D变换的transform-function有： translate/translateX/translateY scale/scaleX/scaleY rotate skew/skewX/skewY 也就是说上面这些变换函数完全可以通过matrix()函数进行等价替换；这里做了一个Demo来体现matrix()函数与这些变换函数等价的体现； 每种仿射变换之间的形式还是有所区别的，有必要弄清楚每种变换对应矩阵形式（之前就是对斜切变换的矩阵一直有误解……）： M平移=[10tx01ty001]M缩放=[sx000sy0001]M旋转=[cosα−sinα0sinαcosα0001]M斜切=[1tanα0tanβ10001]\begin{aligned} M_{平移} &amp;= \begin{bmatrix} 1 &amp; 0 &amp; t_{x} \\ 0 &amp; 1 &amp; t_{y} \\ 0 &amp; 0 &amp; 1 \end{bmatrix} \\[4ex] M_{缩放} &amp;= \begin{bmatrix} s_x &amp; 0 &amp; 0 \\ 0 &amp; s_y &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} \\[4ex] M_{旋转} &amp;= \begin{bmatrix} cos\alpha &amp; -sin\alpha &amp; 0 \\ sin\alpha &amp; cos\alpha &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} \\[4ex] M_{斜切} &amp;= \begin{bmatrix} 1 &amp; tan\alpha &amp; 0 \\ tan\beta &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} \end{aligned} M平移​M缩放​M旋转​M斜切​​=⎣⎡​100​010​tx​ty​1​⎦⎤​=⎣⎡​sx​00​0sy​0​001​⎦⎤​=⎣⎡​cosαsinα0​−sinαcosα0​001​⎦⎤​=⎣⎡​1tanβ0​tanα10​001​⎦⎤​​ matrix3d()函数 同理，matrix3d()就是3D变换矩阵了，对应的就是4x4齐次矩阵： [a1a2a3a4b1b2b3b4c1c2c3c4d1d2d3d4]⋅[xyz1]\begin{bmatrix} a_1 &amp; a_2 &amp; a_3 &amp; a_4 \\ b_1 &amp; b_2 &amp; b_3 &amp; b_4 \\ c_1 &amp; c_2 &amp; c_3 &amp; c_4 \\ d_1 &amp; d_2 &amp; d_3 &amp; d_4 \end{bmatrix} \cdot \begin{bmatrix} x \\ y \\ z \\ 1 \end{bmatrix} ⎣⎢⎢⎡​a1​b1​c1​d1​​a2​b2​c2​d2​​a3​b3​c3​d3​​a4​b4​c4​d4​​⎦⎥⎥⎤​⋅⎣⎢⎢⎡​xyz1​⎦⎥⎥⎤​ 因此，matrix3d()函数就有16个参数，需要注意参数的顺序是列主导的，也就是： matrix3d(a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4) 为何这里不省略一些矩阵元素，像matrix()那样呢？大概是matrix3d除了模拟仿射变换，还要提供透视投影变换，因此需要完整的矩阵元素；属于3D变换的transform-function有： translateZ scaleZ rotateX/rotateY/rotateZ/rotate3d perspective 也就是说上面的变换函数都可以使用matrix3d()函数进行等价替换；平移和缩放的3D变换矩阵形式同2D形式无本质差异，就是相应的扩展了一个维度而已，值得关注的是绕任意轴进行旋转及透视投影相关的变换矩阵； rotate3d()函数 rotate3d()函数实际上就是一个绕任意轴进行旋转的变换，它接受旋转轴的方向及旋转角度； rotate3d(x, y, z, α) 上面就是对应的3D旋转变换矩阵，其中(x,y,z)(x, y, z)(x,y,z)就是旋转轴的方向，α\alphaα为旋转角度； perspective()函数 该变换函数的作用就是设置当前视点距离屏幕（z = 0）平面的距离，从而形成相应的透视投影效果； [10000100001000−1d1]\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; -\large{\frac{1}{d}} &amp; 1 \end{bmatrix} ⎣⎢⎢⎡​1000​0100​001−d1​​0001​⎦⎥⎥⎤​ 相关文档 - CSS: Cascading Style Sheets | MDN CSS Transforms Module Level 2：transform第二阶段规范，主要涉及3D变换和投影相关 CSS Transforms Module Level 1：transform第一阶段规范，主要涉及2D变换]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS滤镜效果]]></title>
    <url>%2Fpost%2Fcss-filter%2F</url>
    <content type="text"><![CDATA[前言 CSS3新增了filter属性用来专门设置元素的滤镜效果，不过目前只支持两种类型： 内置的滤镜函数：一些很常用的滤镜效果。 url()：该方法可以引用一个svg滤镜元素来进行滤镜效果的设置。 CSS滤镜函数一览 滤镜函数 作用 参数 blur() 高斯模糊 模糊范围；&lt;length&gt;类型数据，默认为0；不能为百分比！负值会被忽略； brightness() 亮度调整 亮度值；小数或百分比 为0时全黑，为1时图像不变 可以大于1，大于1时比原图像更亮 contrast() 对比度调整 对比度值；值的设置同亮度一样 drop-shadow() 阴影效果 参数设置同box-shadow()类似 grayscale() 灰度调整 灰度（线性）因子；值在0 - 1之间 1为完全的灰度图像，0则不变 hue-rotate() 色相旋转 色相旋转角度；单位为deg或turn invert() 颜色反转效果 反转（线性）因子；值在0 - 1之间 1为完全反转，0则不变 opacity() 不透明度调整 跟opacity效果一样 saturate() 饱和度调整 饱和度值；指的设置同亮度一样 sepia() 褐色调整 褐色因子；设置同invert 1为深褐色，0则不变 滤镜详解 blur blur()方法的核心算法就是高斯滤波器（滤波器是计算机视觉/图像处理中的一个概念），即利用高斯函数（二维正态分布函数）算出以当前像素点为中心点的矩形区域内所有点的权重，然后将权重归一化处理，权重和各像素点颜色的乘积之和作为当前像素点的新颜色值；因此这种处理效果看起来就是模糊的图像； G(x, y)=12πσ2e−x2+y22σ2G(x,\ y) = \large{\frac{1}{2\pi\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}}} G(x, y)=2πσ21​e−2σ2x2+y2​ 上面就是二维正态分布函数，σ\sigmaσ为标准差，对应的就是blur(length)方法中的长度值，可以理解为滤波器的半径，当长度为nnn时，得到的高斯权重矩阵大小就为(2n+1, 2n+1)(2n + 1,\ 2n + 1)(2n+1, 2n+1)；而x, yx,\ yx, y则代表以当前像素点为原点，各个像素点的坐标；以blur(1px)为例，此时σ=1\sigma = 1σ=1，r=1r = 1r=1： 上面就是某个像素点和其周围相邻一个像素点之间的坐标值了；将坐标值(x, y)(x,\ y)(x, y)和标准差代入公式即可得到每个像素点对应的权重值： 显然，权重值相加不等于1，因此需要做归一化处理： 细节问题一：模糊半径 从W3C文档可知，它仅仅规范了高斯滤波器中标准差的来源，而没有说清楚模糊半径（即滤波器半径）怎么取； The passed parameter defines the value of the standard deviation to the Gaussian function. The parameter is specified a CSS length, but does not accept percentage values. [1] 因此，blur()方法规范在这一点上是不严谨的；但是MDN上面对于blur()方法中有个描述值得推敲： The blur() fucntion applies a Gaussian blur to the input image. The value of radius defines the value of the standard deviation to the Gaussian function, or how many pixels on the screen blend into each other, so a larger value will create more blur. [2] 也就是说这个长度也可以用来描述模糊半径，由于这个长度可以是浮点数，但由于滤波器半径是整数，可以大胆推测：滤波器半径（模糊半径）是长度的向上取整值； 细节问题二：模糊效果超出部分 应用模糊滤镜效果时，可以看到模糊效果会向外扩张一定的区域，这个多出的区域大概就是传入blur方法的长度： 12345678910.test &#123; --radius: 10px; width: 200px; height: 200px; padding: var(--radius); border: 1px solid red;&#125;.blur &#123; filter: blur(var(--radius));&#125; 123&lt;div class="test"&gt; &lt;img class="blur" src="https://placekitten.com/200/200"&gt;&lt;/div&gt; 不知模糊滤镜效果为何会超出原本的区域，看起来像是处理边界部分时进行相应宽度的填充导致的，不知道这算不算是副作用？毕竟一般的模糊滤镜处理效果是不会超出图像原本区域的，但是W3C规范也并没有提及边界处理情况，所以有点迷； 当我们并不想要显示模糊滤镜超出的部分怎么办？传统的办法可以套一层父元素，然后利用overflow: hidden进行隐藏；但是，其实有更简单的办法，那就是利用clip-path直接将超出部分裁剪掉： 1234.blur &#123; filter: blur(var(--radius)); clip-path: inset(0 0 0 0);&#125; brightness 亮度滤镜的原理很简单，就把亮度值与原像素值相乘，得到的像素值超出1则为1；其实这个效果很容易用混合模式中的正片叠底进行模拟（当然，亮度超出1时就没法模拟了）； 1234&lt;div class="brightness"&gt; &lt;img class="brightness-item" src="https://placekitten.com/200/200"&gt; &lt;div class="brightness-blend"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910.brightness-item &#123; filter: brightness(0.5);&#125;.brightness-blend &#123; display: inline-block; width: 200px; height: 200px; background-blend-mode: multiply; background: rgba(0, 0, 0, 0.5) url("https://placekitten.com/200/200");&#125; contrast 对比度滤镜计算公式如下： Cresult=(0.5, 0.5, 0.5)∗(1−a)+a∗CoriginC_{result} = (0.5,\ 0.5,\ 0.5)*(1 - a) + a * C_{origin} Cresult​=(0.5, 0.5, 0.5)∗(1−a)+a∗Corigin​ 这里，aaa指的就是对比度系数，即传入contrast()方法中的参数；因此，可以看出当对比度系数为1时，得到图像就是原图像，当对比度系数为0时，得到是纯灰度图像；当对比度系数超出1时，得到的效果就是黑的越黑，白的更白，即对比度上升； drop-shadow A drop shadow is effectively a blurred, offset version of the input image’s alpha mask drawn in a particular color, composited below the image.[3] 由W3C的定义可知，投影滤镜就是复制了图像的透明通道加上了投影颜色组成了新的图层，且在该图层上应用了模糊滤镜效果，该图层位于原图层的下方； 123&lt;div class="drop"&gt; &lt;img class="drop-item" src="https://interactive-examples.mdn.mozilla.net/media/examples/firefox-logo.svg"&gt;&lt;/div&gt; 12345.drop-item &#123; width: 200px; height: 200px; filter: drop-shadow(300px 0 0 red);&#125; 使用一张具有透明通道的图片，加上投影滤镜可以看到新的图层确实复制了原有的透明通道； grayscale 灰度滤镜原理就很简单，就是将原像素颜色与其灰度值按比例进行混合： Cresult=Cgray∗a+Corigin∗(1−a)C_{result} = C_{gray} * a + C_{origin} * (1- a) Cresult​=Cgray​∗a+Corigin​∗(1−a) hue-rotate 色相旋转，顾名思义就是将HSL中的H分量进行旋转；也就是先将颜色转为HSL颜色，再将H分量旋转指定量，然后再将颜色转回RGB颜色；只要理解了HSL色彩模型，就很容易这个色相旋转的本质了； invert 反转滤镜的原理和灰度滤镜原理是类似的，就是将原像素颜色与其互补色按比例进行混合： Cresult=C互补∗a+Corigin∗(1−a)C_{result} = C_{互补} * a + C_{origin} * (1- a) Cresult​=C互补​∗a+Corigin​∗(1−a) 当然，如果是invert(1)时（即完全的互补色），可以利用差值滤色模式来等价模拟： 1234&lt;div class="invert"&gt; &lt;img class="invert-item" src="https://placekitten.com/200/200"&gt; &lt;div class="invert-other"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910.invert-item &#123; filter: invert(1);&#125;.invert-other &#123; display: inline-block; width: 200px; height: 200px; background-blend-mode: difference; background: white url("https://placekitten.com/200/200");&#125; saturate 饱和度滤镜原理同对比度类似，只不过需要先得出原像素颜色的明度值（即HSL颜色中的L分量），然后将明度值与原像素颜色按比例进行混合： L=0.3∗Cr+0.59∗Cg+0.11∗CbCresult=(L,L,L)∗(1−s)+Corigin∗s\begin{aligned} L &amp;= 0.3 * C_r + 0.59 * C_g + 0.11 * C_b \\ C_{result} &amp;= (L, L, L) * (1 - s) + C_{origin} * s \end{aligned} LCresult​​=0.3∗Cr​+0.59∗Cg​+0.11∗Cb​=(L,L,L)∗(1−s)+Corigin​∗s​ sss就是滤镜中设置的饱和度值，可以看出，当s=0s=0s=0时，得到的就是一副灰度图像； sepia 褐色滤镜本质上还是一个混合滤镜，只不过获取一个像素颜色对应的褐色需要多一点计算；不过由于没有在W3C上发现有描述相关的算法，所以在网上找了褐色滤镜的算法[4]： Csepia=(r, g, b)⋅[0.3930.3490.2720.7690.6860.5340.1890.1680.131]Cresult=Cspeia∗a+Corigin∗(1−a)\begin{aligned} C_{sepia} &amp;= (r,\ g,\ b) \cdot \begin{bmatrix} 0.393 &amp; 0.349 &amp; 0.272 \\ 0.769 &amp; 0.686 &amp; 0.534 \\ 0.189 &amp; 0.168 &amp; 0.131 \end{bmatrix} \\[5ex] C_{result} &amp;= C_{speia} * a + C_{origin} * (1 - a) \end{aligned} Csepia​Cresult​​=(r, g, b)⋅⎣⎡​0.3930.7690.189​0.3490.6860.168​0.2720.5340.131​⎦⎤​=Cspeia​∗a+Corigin​∗(1−a)​ 相关文档 你所不知道的 CSS 滤镜技巧与细节 · Issue #30 · chokcoco/iCSS filter - CSS（层叠样式表） | MDN 常用滤镜算法以及WebGL实现 | NewbieWeb FDCon2019大会分享之滤镜与混合模式实录 « 张鑫旭-鑫空间-鑫生活 图像处理的滤镜算法 - 掘金 高斯模糊的算法 - 阮一峰的网络日志 https://en.wikipedia.org/wiki/Gaussian_blur 亮度，饱和度，对比度的计算方法_gaowebber的博客-CSDN博客_对比度计算公式 https://www.w3.org/TR/filter-effects-1/#funcdef-filter-blur ↩︎ filter - CSS: Cascading Style Sheets | MDN ↩︎ https://www.w3.org/TR/filter-effects-1/#funcdef-filter-drop-shadow ↩︎ image processing - How is a sepia tone created? - Stack Overflow ↩︎]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS颜色混合模式]]></title>
    <url>%2Fpost%2Fcss-blend-mode%2F</url>
    <content type="text"><![CDATA[前言 混合模式（blend mode）是计算机图形学中的一个概念，用于处理帧绘制中不同（相邻）层级图像之间的颜色混合方式；CSS3开始引入了混合模式的功能，可以先从原理开始了解。 注：以下RGB颜色分量范围为[0, 1]。 混合模式 基本原理 关于混合模式的原理，其实W3C文档上面写的很详细，所有的混合模式可以精简成一个公式： Cmix=f(Cbackdrop, Csource)C_{mix} = f(C_{backdrop},\ C_{source}) Cmix​=f(Cbackdrop​, Csource​) 其中： CmixC_{mix}Cmix​：代表混合之后得到的颜色； CbackdropC_{backdrop}Cbackdrop​：代表处于相对底层的颜色； CsourceC_{source}Csource​：代表处于相对上层的颜色； fff：代表用于混合两种颜色的函数； 所以，可以明显的看出来各种混合模式之间的区别就在于混合函数； 相关概念 颜色通道：由于数字图像存储像素颜色信息都是按不同颜色成分分别进行存储的，因此将图像中的某一成分单独拿出来组成的灰度图像就是其中的一个颜色通道；例如常见的RGBA图像就有R，G，B，A四个颜色通道； A channel in this context is the grayscale image of the same size as a color image, made of just one of these primary colors.[1] 互补色：在RGB颜色模型中，一种颜色的互补色就是用白色减去该颜色所得到的颜色；可以这样描述： C互补=1−CC_{互补} = 1 - C C互补​=1−C 可分离混合模式（Separable blend modes）：这里的可分离指的是对不同的颜色通道进行混合然后再合并得到的混合效果是一样的，即不同的颜色通道只依赖于对应的颜色通道信息； 混合函数 可分离 正常（normal）：默认情况，即上层像素直接覆盖下层像素； f(Cb, Cs)=Csf(C_b,\ C_s) = C_s f(Cb​, Cs​)=Cs​ 正片叠底（multiply）：上层像素与下层像素各通道值进行相乘，得到的图像较原图像会偏暗；当一方像素为黑色时得到的像素自然也是黑色，反之若一方像素为白色得到的像素则为另一方像素原值； f(Cb, Cs)=Cb∗Csf(C_b,\ C_s) = C_b * C_s f(Cb​, Cs​)=Cb​∗Cs​ 滤色（screen）：先将两者的互补进行正片叠底，然后再取其互补；这种情况通常会使图像变得更亮，当一方像素为黑色时得到的像素值就是另一方像素值，而当一方像素为白色时得到的像素也是白色；因此最后混合得到图像会有一个特点：颜色值再低也不会低于两者中的任何一个； f(Cb, Cs)=1−[(1−Cb)∗(1−Cs)]=Cb+Cs−Cb∗Cs\begin{aligned} f(C_b,\ C_s) &amp;= 1 - [(1 - C_b) * (1 - C_s)]\\[1em] &amp;= C_b + C_s - C_b * C_s \end{aligned} f(Cb​, Cs​)​=1−[(1−Cb​)∗(1−Cs​)]=Cb​+Cs​−Cb​∗Cs​​ 变暗（darken）：取两者中各自通道中最小的值； f(Cb, Cs)=min(Cb,Cs)f(C_b,\ C_s) = min(C_b, C_s) f(Cb​, Cs​)=min(Cb​,Cs​) 变亮（lighten）：取两者中各自通道中最大的值； f(Cb, Cs)=max(Cb,Cs)f(C_b,\ C_s) = max(C_b, C_s) f(Cb​, Cs​)=max(Cb​,Cs​) 颜色减淡（color-dodge）：作用是提高底层颜色亮度，然后反射上层颜色，最后达到提高图像亮度的目的； f(Cb, Cs)={0,Cb=01,Cs=1min(1, Cb1−Cs),elsef(C_b,\ C_s) = \begin{cases} 0, &amp; C_b = 0 \\[1em] 1, &amp; C_s = 1 \\[1em] min(1,\ \large\frac{C_b}{1 - C_s}), &amp; else \end{cases} f(Cb​, Cs​)=⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​0,1,min(1, 1−Cs​Cb​​),​Cb​=0Cs​=1else​ 颜色加深（color-burn）：跟color-dodge作用相反，会降低底层颜色亮度，然后反射上层颜色，降低图像的亮度； f(Cb, Cs)={1,Cb=10,Cs=01−min(1, 1−CbCs),elsef(C_b,\ C_s) = \begin{cases} 1, &amp; C_b = 1 \\[1em] 0, &amp; C_s = 0 \\[1em] 1 - min(1,\ \large\frac{1 - C_b}{C_s}), &amp; else \end{cases} f(Cb​, Cs​)=⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​1,0,1−min(1, Cs​1−Cb​​),​Cb​=1Cs​=0else​ 强光（hard-light）：颜色变亮或变暗取决于上层的像素颜色，暗则更暗，亮则更亮；效果类似于在底层图像上加上高（镜面）反射光； f(Cb, Cs)={fmultiply(Cb, 2∗Cs),Cs≤0.5fscreen(Cb, 2∗Cs−1),elsef(C_b,\ C_s) = \begin{cases} f_{multiply}(C_b,\ 2 * C_s), &amp; C_s \le 0.5 \\[1em] f_{screen}(C_b,\ 2 * Cs - 1), &amp; else \end{cases} f(Cb​, Cs​)=⎩⎨⎧​fmultiply​(Cb​, 2∗Cs​),fscreen​(Cb​, 2∗Cs−1),​Cs​≤0.5else​ 弱光（soft-light）：颜色变亮或变暗取决于上层的像素颜色，效果类似于在底层图像上加上漫反射光； D(C)={((16∗C−12)∗C+4)∗C,C≤0.25C,elsef(Cb, Cs)={Cb−(1−2∗Cs)∗Cb∗(1−Cb),Cs≤0.5Cb+(2∗Cs−1)∗(D(Cb)−Cb),elseD(C) = \begin{cases} ((16 * C - 12) * C + 4) * C, &amp; C \le 0.25 \\[1em] \sqrt{C}, &amp; else \end{cases}\\[2em] f(C_b,\ C_s) = \begin{cases} C_b - (1 - 2 * C_s) * C_b * (1 - C_b), &amp; C_s \le 0.5 \\[1em] C_b + (2 * Cs - 1) * (D(C_b) - C_b), &amp; else \end{cases} D(C)=⎩⎨⎧​((16∗C−12)∗C+4)∗C,C​,​C≤0.25else​f(Cb​, Cs​)=⎩⎨⎧​Cb​−(1−2∗Cs​)∗Cb​∗(1−Cb​),Cb​+(2∗Cs−1)∗(D(Cb​)−Cb​),​Cs​≤0.5else​ 叠加（overlay）：将两者互换位置，然后再进行强光处理；因此类似于给上层图像加了镜面反射光； f(Cb, Cs)=fhard−light(Cs, Cb)f(C_b,\ C_s) = f_{hard-light}(C_s,\ C_b) f(Cb​, Cs​)=fhard−light​(Cs​, Cb​) 差值（difference）：获取两者各自通道之间的差值； f(Cb, Cs)=∣Cb−Cs∣f(C_b,\ C_s) = | C_b - C_s | f(Cb​, Cs​)=∣Cb​−Cs​∣ 排除（exclusion）：从结果来看，exclusion等于滤色效果减去正片叠底；从效果上看则与差值类似，但是具有更低的对比度； f(Cb, Cs)=Cb+Cs−2∗Cb∗Csf(C_b,\ C_s) = C_b + C_s - 2 * C_b * C_s f(Cb​, Cs​)=Cb​+Cs​−2∗Cb​∗Cs​ 不可分离 顾名思义，不可分离指的就是一个颜色通道的颜色混合会依赖其他颜色通道的数据；CSS中不可分离混合模式通常采用以下步骤： 将RGB转为HSL颜色模型； 然后对H，S，L分量进行处理； 最后再最转回RGB颜色模型； 根据W3C文档可知，不可分离混合模式会使用以下几个函数： Lum(C)Lum(C)Lum(C)：获取颜色灰度值； ClipColor(C)ClipColor(C)ClipColor(C)：将颜色值范围进行校正，保证颜色分量在[0, 1]之间； SetLum(C, l)SetLum(C,\ l)SetLum(C, l)：将颜色值转为灰度为l的颜色； Sat(C)Sat(C)Sat(C)：获取RGB颜色的饱和度（即HSL中的S分量）； SetSat(C, s)SetSat(C,\ s)SetSat(C, s)：将RGB颜色中的饱和度转为s； 可以用GLSL进行相应函数的描述： 123456789101112131415161718192021222324252627282930313233343536373839404142void main &#123; // RGB转灰度 float lum (vec3 color) &#123; return 0.3 * color.r + 0.59 * color.g + 0.11 * color.b; &#125; // 获取rgb颜色分量中的最大值 float minChannel (vec3 c) &#123; return min(min(c.r, c.g), min(c.g, c.b)); &#125; // 获取rgb颜色分量中的最小值 float maxChannel (vec3 c) &#123; return max(max(c.r, c.g), max(c.g, c.b)); &#125; // 校正rgb颜色值 vec3 clipColor (vec3 color) &#123; vec3 c = color; float l = lum(color); float n = maxChannel(color); float x = minChannel(color); if (n &lt; 0.0) &#123; c = l + (((c - l) * l) / (l - n)); &#125; if (x &gt; 1.0) &#123; c = l + (((c - l) * (1.0 - l)) / (x - l)); &#125; return c; &#125; // 设置rgb颜色灰度 vec3 setLum (vec3 color, float l) &#123; float d = l - lum(color); return clipColor(color + d); &#125; // 获取rgb颜色的饱和度s分量 float sat (vec3 c) &#123; return maxChannel(c) - minChannel(c); &#125;&#125; 色相（hue）：使用底层颜色的S及L分量，加上上层颜色的H分量，得到一个新的颜色； f(Cb, Cs)=SetLum(SetSat(Cs, Sat(Cb)), Lum(Cb))f(C_b,\ C_s) = SetLum(SetSat(C_s,\ Sat(C_b)),\ Lum(C_b)) f(Cb​, Cs​)=SetLum(SetSat(Cs​, Sat(Cb​)), Lum(Cb​)) 饱和度（saturation）：使用底层颜色的H及L分量，加上上层颜色的S分量，得到一个新的颜色； f(Cb, Cs)=SetLum(SetSat(Cb, Sat(Cs)), Lum(Cb))f(C_b,\ C_s) = SetLum(SetSat(C_b,\ Sat(C_s)),\ Lum(C_b)) f(Cb​, Cs​)=SetLum(SetSat(Cb​, Sat(Cs​)), Lum(Cb​)) 颜色（color）：使用上层颜色的H及S分量，加上底层的颜色的L分量，得到一个新的颜色； f(Cb, Cs)=SetLum(Cs, Lum(Cb))f(C_b,\ C_s) = SetLum(C_s,\ Lum(C_b)) f(Cb​, Cs​)=SetLum(Cs​, Lum(Cb​)) 明度（luminosity）：使用底层颜色的H及S分量，加上上层的颜色的L分量，得到一个新的颜色； f(Cb, Cs)=SetLum(Cb, Lum(Cs))f(C_b,\ C_s) = SetLum(C_b,\ Lum(C_s)) f(Cb​, Cs​)=SetLum(Cb​, Lum(Cs​)) CSS中混合模式相关的属性 css3中引入了两个与混合模式有关的属性： background-blend-mode：用于指定元素背景（包括背景图和背景色）之间的混合模式； mix-blend-mode：用于指定元素与其叠层之下的元素/层级之间的混合模式； 混合模式的应用 滤色模式叠加特效 可以使用mix-blend-mode: screen的方式给图片/视频或某一区域叠加特效图片/动图，从而达到叠加特效的效果；比如： 上面这种效果就是利用上述混合模式，在图片上叠加了一层火焰燃烧的动图，动图如下： 由滤色混合模式特点可知，上层像素为黑色时混合的结果就是底层像素，因此这种模式下特效图片都是黑底，就是为了让非特效部分像素保持原样，而特效部分像素则与 底层像素进行融合； 有人可能会有些疑问，为何不直接把特效图片做成带透明通道的，这样非特效部分的像素就是完全透明的，然后直接叠加在底层区域上不就好了；显然，直接叠加的效果不太真实，而滤色混合模式则会对底层像素和上层像素进行某种比例的融合，这样看起来有点接近光反射的模型，看起来更真实； 滤色模式制作图片背景的文字 看到上面这个效果，可能很多人马上能够想到利用backgound-image + -webkit-background-clip: text + color: transparent组合实现；然而这个目前仅能在webkit内核浏览器才能有效果，但是知道了滤色混合模式的原理后，可以利用其“顶层为黑色像素时保留底层像素，为白色像素时则为白色”的特点来实现一样的效果： 文字单独设置成一层，然后设置mix-blend-mode: screen； 文字颜色为黑色：因此可以对文字点阵区域保留底层的像素； 文字区域背景色为白色：因此文字点阵以外区域皆为白色； 1234&lt;div class="demo"&gt; &lt;img src="https://placekitten.com/200/100"&gt; &lt;div class="text"&gt;text&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617.demo2 &#123; position: relative; width: 200px; height: 100px;&#125;.text &#123; position: absolute; left: 0; top: 0; width: 100%; height: 100%; font-size: 80px; line-height: 100px; text-align: center; background-color: white; mix-blend-mode: screen;&#125; 而且mix-blend-mode目前兼容性比较好，PC端完全没问题，移动端可能安卓稍低的版本不太支持； 渐变色文字 渐变色文字原理跟上面的图片背景文字一样，只不过是把底层的图片换成渐变背景色而已； 1234567891011121314151617181920.demo &#123; position: relative; width: 600px; height: 100px; margin-top: 20px; background-image: linear-gradient(45deg, blue, green, orange);&#125;.grad &#123; position: absolute; left: 0; top: 0; width: 100%; height: 100%; font-size: 60px; font-weight: bold; line-height: 100px; text-align: center; background-color: white; mix-blend-mode: screen;&#125; 123&lt;div class="demo"&gt; &lt;span class="grad"&gt;渐变文字 Color&lt;/span&gt;&lt;/div&gt; 自制滤镜 虽然css3新增的filter属性提供了很多滤镜，但是丰富的混合模式加上各自的特点，再配合各种各样的图片就能够形成丰富多彩的自定义滤镜； 正片叠底过滤颜色通道 由于正片叠底的特点，当某颜色通道为0时，可以使混合后相应的颜色通道也为0，也就达到了过滤特定颜色通道的目的；比如上层图像为纯红色（相当于(1, 0 , 0)），此时正片叠底的效果就是只保留底层图像的R通道； 12345678910111213141516171819.demo &#123; margin-top: 20px;&#125;.single &#123; display: inline-block; width: 200px; height: 160px; background: url("https://placekitten.com/200/160"), red; background-blend-mode: multiply;&#125;.single:nth-of-type(2) &#123; background: url("https://placekitten.com/200/160"), green;&#125;.single:nth-of-type(3) &#123; background: url("https://placekitten.com/200/160"), blue;&#125;.single:nth-of-type(4) &#123; background: url("https://placekitten.com/200/160");&#125; 123456&lt;div class="demo"&gt; &lt;div class="single"&gt;&lt;/div&gt; &lt;div class="single"&gt;&lt;/div&gt; &lt;div class="single"&gt;&lt;/div&gt; &lt;div class="single"&gt;&lt;/div&gt;&lt;/div&gt; 也可以保留任意两个颜色通道： 12345678910111213141516.single &#123; display: inline-block; width: 200px; height: 160px; background: url("https://placekitten.com/200/160"), rgb(255, 255, 0); background-blend-mode: multiply;&#125;.single:nth-of-type(2) &#123; background: url("https://placekitten.com/200/160"), rgb(255, 0, 255);&#125;.single:nth-of-type(3) &#123; background: url("https://placekitten.com/200/160"), rgb(0, 255, 255);&#125;.single:nth-of-type(4) &#123; background: url("https://placekitten.com/200/160");&#125; 123456&lt;div class="demo"&gt; &lt;div class="single"&gt;&lt;/div&gt; &lt;div class="single"&gt;&lt;/div&gt; &lt;div class="single"&gt;&lt;/div&gt; &lt;div class="single"&gt;&lt;/div&gt;&lt;/div&gt; 甚至可以控制单一颜色通道的比例然后再混合起来，相当于逐像素进行计算来实现某种滤镜算法；当然，这种利用混合模式去实现滤镜效果和直接使用GPU计算在性能上的差距还是有待验证的，不过简单的组合还是可行的； 晕影效果 利用正片叠底 + 径向渐变可以实现晕影的滤镜效果，且通过调整径向渐变的半径大小可以控制晕影大小； 1234567.demo &#123; width: 300px; height: 300px; margin-top: 20px; background: url("https://placekitten.com/300/300"), radial-gradient(white 50%, black 100%); background-blend-mode: multiply;&#125; 其他 了解了混合模式的原理后，可以发现混合模式可以用来做出非常丰富的图像处理，只要结合各个混合模式的算法特点就可以实现很棒的效果，还不用写底层代码； 相关文档 Blend modes - Wikipedia HSL和HSV色彩空间 - 维基百科，自由的百科全书 如何通俗易懂地讲解 Photoshop 中的「通道」概念？ - 嗜睡者的回答 - 知乎 Shader 中的颜色混合模式（Blend Mode） - 掘金 &lt;blend-mode&gt; - CSS（层叠样式表） | MDN https://zh.wikipedia.org/wiki/互補色 不可思议的混合模式 background-blend-mode - ChokCoco - 博客园：很多实用的例子，强烈推荐 深入理解CSS mix-blend-mode滤色screen混合模式 « 张鑫旭-鑫空间-鑫生活 深入理解CSS background-blend-mode的作用机制 « 张鑫旭-鑫空间-鑫生活 Channel (digital image) - Wikipedia ↩︎]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>动效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[border-radius的本质]]></title>
    <url>%2Fpost%2Fcss-border-radius%2F</url>
    <content type="text"><![CDATA[前言 border-radius从名字上看像是指定border-box的圆角半径，实际上在使用时大家也是这么用的；但是从W3C官方文档定义来看，border-radius属性不仅会影响border-box的形状，还能影响padding-box和content-box的形状； border-radius的本质就是通过定义盒模型四个顶点的圆角半径，从而确定四个顶点圆角的中心位置，四个中心点绘制的椭圆/圆分别对border-box，padding-box和content-box进行裁剪； 所以border-radius本质上是一种特殊的形状裁剪语法，和clip-path类似； 语法 border-radius本身是一种缩写属性，对应四个顶点的设置： border-top-left-radius border-top-right-radius border-bottom-right-radius border-bottom-left-radius 这种缩写方式与border属性类似，顶点顺序也是遵循顺时针方向，从左上到左下； 值的类型 &lt;length&gt;：绝对长度类型； &lt;percentage&gt;：百分比类型，百分比基于半轴对应方向border-box的尺寸； 维度/方向 如果是在单个顶点设置圆角属性时，是以空格来分隔两个维度的半轴长度，前者为x方向半轴长度，后者为y方向半轴长度： 123.demo &#123; border-bottom-left-radius: 50% 50px;&#125; 而在缩写语法中，通过斜杠（/）来分隔不同方向的半轴长度，前面为x方向半轴长度的缩写，后面为y方向半轴长度的缩写； 缩写语法 border-radius缩写属性可接收1～4个值，不同数量的值会有不同的顶点分配： 1个值：每个顶点具有一样的设置； 123456789.demo &#123; border-radius: 10px;&#125;/* or */.demo &#123; border-radius: 10px / 5%;&#125; 2个值：第一个值对应左上和右下顶点，第二个值对应右上和左下顶点；可以看出这种语法是对角设置； 123.demo &#123; border-radius: 10px 20px;&#125; 3个值：第一个值对应左上顶点，第二个值对应右上和左下顶点（对角线），第三个值对应右下顶点； 123.demo &#123; border-radius: 10px 5% 20px;&#125; 4个值：四个值依次对应左上，右上，右下，左下四个顶点； 123.demo &#123; border-radius: 10px 30px 5% 11px;&#125; 裁剪原理 以上关于语法的部分只不过是随处可见的资料，然而border-radius本质上是对盒模型进行形状裁剪，因此了解其裁剪原理才算是理解其本质； 注：圆是一种特殊的椭圆，下面用椭圆来替代圆/椭圆，不再赘述； 根据顶点圆角两个维度的半轴长度确定椭圆的中心点； 从中心点画出椭圆弧，对相应的盒模型进行裁剪，裁剪后的形状就是新的盒模型形状（即可能不是正常的盒形）； 从原理上来说是很简单的，但是其实还存在很多细节，一些边界情况如何处理等等； 确定中心点 border-box的中心点其实很好确定，毕竟border-radius指定的就是border-box顶点圆角的半轴长，根据border-box顶点位置和半轴长马上就能得到中心点位置； Pcenter=Pborer−vertex−(Rx, Ry)P_{center} = P_{borer-vertex} - (R_x,\ R_y) Pcenter​=Pborer−vertex​−(Rx​, Ry​) 其实其他盒模型的中心点的位置跟border-box的位置是一致的，关键在于半轴长度如何确定？毕竟border-radius只是指定了border-box圆角的半轴长度，因此其他盒模型的半轴长度只能基于此进行推导； 其他盒模型的半轴长 The padding edge (inner border) radius is the outer border radius minus the corresponding border thickness. In the case where this results in a negative value, the inner radius is zero.[1] 根据W3C文档的定义可知： {Rpadding−x=Rx−Wborder−xRpadding−y=Ry−Wborder−y\begin{cases} R_{padding-x} = R_x - W_{border-x} \\[1em] R_{padding-y} = R_y - W_{border-y} \end{cases}\\[2em] ⎩⎨⎧​Rpadding−x​=Rx​−Wborder−x​Rpadding−y​=Ry​−Wborder−y​​ 注：Rx,RyR_x,R_yRx​,Ry​为border-box的半轴长，Wborder−xW_{border-x}Wborder−x​为水平方向的边框长度（顶点在左边就是左边框，在右边就是右边框），同理，Wborder−yW_{border-y}Wborder−y​就是竖直方向的边框长度； 当然，如果得到的半轴长为负值时，会自动变成0，此时也就没有圆角裁剪效果了；同理可以得到content-box的圆角半轴长： {Rcontent−x=Rpadding−x−Wpadding−xRcontent−y=Rpadding−y−Wpadding−y\begin{cases} R_{content-x} = R_{padding-x} - W_{padding-x} \\[1em] R_{content-y} = R_{padding-y} - W_{padding-y} \end{cases}\\[2em] ⎩⎨⎧​Rcontent−x​=Rpadding−x​−Wpadding−x​Rcontent−y​=Rpadding−y​−Wpadding−y​​ 裁剪规则 上面为了图示方便画的都是一个完整的椭圆，实际上只需要四分之一个椭圆即可；具体是哪四分之一，需要根据顶点的方向来确定，即对应方向的象限（这里借用坐标象限表述可能清楚一些）； 左上：第二象限 右上：第一象限 右下：第四象限 左下：第三象限 裁剪时椭圆曲线外被舍去，也可以理解为对应的椭圆曲线充当新的盒模型外曲线；以border-box为例： 其它顶点及盒模型裁剪也是类似的； 半轴长度的上限 从规范上来看，好像并没有提及半轴长度的上限，也就是只要半轴长度大于等于0理论上都是可行的；可是经过实践（blink内核和webkit内核），浏览器上面的表现可以看出半轴长度是存在一个上限的，这个上限就是盒模型相应方向尺寸的一半！ 当然，这并不是说当半轴长度超过盒模型相应方向尺寸的一半时，简单地按尺寸的一半进行处理；而是根据当前盒模型的宽高比进行一定的缩放，即把超出比例最多的方向的半轴长度设置为当前盒模型对应方向尺寸的一半，另一个方向按比例缩放！ 举个例子：一个元素的border-box是一个300x200的box时，设置border-radius为150px/200px，由于此时y方向半轴长度是超出比例最多的，因此会将y方向的半轴长度设置为box高度的一半——100px，那么此时另一个方向——x方向的半轴长度就是： Rx′=Ry′Ry∗Rx=100200∗150=75\begin{aligned} R&#x27;_x &amp;= \frac{R&#x27;_y}{R_y} * R_x \\[1em] &amp;= \frac{100}{200} * 150 \\[1em] &amp;= 75 \end{aligned} Rx′​​=Ry​Ry′​​∗Rx​=200100​∗150=75​ 因此，此时border-radius: 150px/200px就等价于border-radius: 75px/100px； 眼见为实 裁剪后的padding与border 从上面可以很明显的看出，经过border-radius的裁剪，border和padding也变形了；其实可以这么理解： border-box外曲线与padding-box外曲线之间的区域就是border； 同理，padding-box外曲线与content-box外曲线之间的区域就是padding； 案例分析 绘制蛋形 从鸡蛋形状可以分析：上半部形状较尖，下半部形状较圆；根据border-radius原理出发，想要绘制鸡蛋形状，上面两个顶点的椭圆肯定偏窄，下面两个顶点的的椭圆就圆一点；所谓偏窄就是y方向的半轴长度更大，得出css如下： 123456789.egg &#123; width: 100px; height: 150px; border-top-left-radius: 50%; border-top-right-radius: 50%; border-bottom-left-radius: 50% 50px; border-bottom-right-radius: 50% 50px; background-color: gold;&#125; 胶囊分离动画 上面这个动画仅需一个元素，无需借助伪元素，如果理解了border-radius的本质，就很容易想明白的，可以挑战一下； 胶囊分离动画 相关文档 border-radius - CSS（层叠样式表） | MDN CSS Backgrounds and Borders Module Level 3：border-radius官方文档 CSS Backgrounds and Borders Module Level 3 ↩︎]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>动效</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅尝 CSS Houdini]]></title>
    <url>%2Fpost%2Ffirst-test-css-houdini%2F</url>
    <content type="text"><![CDATA[前言 近几年，浏览器的特性频出，特别是一些开放浏览器底层控制的API规范，比如：WebAssembly，CSS Houdini，WebGL2.0等；这些底层API使得我们有机会定制更多的内容，而且拥有更好的性能，因此也就获得了更多的创造性。 关于CSS Houdini也是近两年才听的比较多，只知道大概是一个自定义CSS属性的利器，也没比较详细的去了解，算是比较前沿的CSS规范了；看过一些案例后，觉得CSS Houdini确实能够做出一些十分强大的展示和动效，是时候深入了解一下了。 CSS Houdini 现状 上图[1]是截至目前为止（2020-7-11）各浏览器厂商对于CSS Houdini规范各个模块的支持情况，可以看到目前只有blink内核（chrome系）浏览器对于CSS Houdini有较好的支持，而webkit内核则是处于开发中，firefox那就只是有意图去实现，连开发阶段都没有进入； 而且可以看到，即便是CSS Houdini规范，blink内核对不同模块的支持程度也不一样；目前Paint API，Properties &amp; Values API，Typed OM完全支持；其他模块不是没有开发进度就是很少的部分特性支持，基本上用处不大； 再看下caniuse网站的统计，移动端那就更加惨烈了，只有安卓原生浏览器和安卓Chrome浏览器有支持，而且要求版本还比较高（2020-4月后才支持）； 所以CSS Houdini目前支持程度有限，仅在blink内核浏览器有用武之处，真实应用场景会大打折扣； CSS Houdini 规范 背景 那么为何要提出CSS Houdini规范？ 首先，因为目前CSS很多属性在各个内核上可能有表现差异，导致兼容性问题，且原生polyfill几乎没有可能； 其次，CSS很多新特性从提案，W3C纳入规范再到厂商最终实现可能要面临几年以上的时间，这个流程极大地耗费开发者的耐心及应用推广；因此每次出现新特性提案时大多数人都会调侃说到等几年后再试试； CSS Houdini规范正是为了解决上述问题而提出的，通过暴露CSS引擎渲染相关的流程，使得渲染不再是黑盒，而是变得可控，这样样式和渲染的决定权就交到了开发者的手里，也就能解决上述的问题（当然，前提是所有浏览器都支持CSS Houdini规范……）。 作用 上图[2]解释了CSS Houdini规范中每个模块具体作用于CSS渲染的哪个流程，从图中可以看出CSS Houdini规范的野心很大，试图掌控整个CSS渲染流程（这对于开发者来说肯定是个好消息）； CSS Parsing API：用于解析CSS词法结构，也就是对于渲染中解析器工作的部分； CSS Typed OM：从CSS Houdini规范草案可以看出，CSS Typed OM是CSSOM的高性能版本，是直接将CSS值转化为类JS对象，从而减少中间层的转换； Converting CSSOM value strings into meaningfully typed JavaScript representations and back can incur a significant performance overhead. This specification exposes CSS values as typed JavaScript objects to facilitate their performant manipulation.[3] CSS Properties &amp; Values API：对CSS自定义属性进行指定值类型等相关配置，指定值类型后自定义属性就能够被应用于动画； CSS Layout API：用于控制渲染中的布局（Layout）流程，从而可以自己增加display类型； CSS Painting API：用于控制渲染中的绘制（Paint）流程，对于元素样式达到像素级的控制，且绘制API是canvas的子集，方便上手； Worklets：类似于Web Worker，是独立于主线程的脚本文件，只能使用指定的API，专门用于存放注册布局和绘制相关的代码； Composited Scrolling &amp; Animation：复合滚动和动画API，目的是在worklets中支持滚动（位置）及动画变化，使得相应的属性变化不会引起主线程中的重排和重绘，从而拥有高性能的滚动及动画表现；目前blink内核已经实现了一部分Animation Worklet[4]； CSS Properties &amp; Values API 简介 这部分的API很简洁，主要是定义了CSS自定义属性的一些性质；API包含CSS.registerProperty()方法和@property规则，而这两个本质上作用是一样的，前者是在JS中使用，后者是在CSS中使用； CSS.registerProperty() CSS.registerProperty(PropertyDefinition)[5] 该方法接收一个配置对象，该对象有以下几个属性： name：必填，自定义属性名（注意要包含前面的--）； syntax：可选，指定自定义属性的语法值类型；可用的值类型可以参考CSS的值与单位 - 学习 Web 开发 | MDN，默认值为&quot;*&quot;； inherits：自定义属性值是否可以被继承，默认为false（不能被继承）； initialValue：可选，自定义属性的初始值； 123456789// 先判断API是否能用if ('registerProperty' in CSS &amp;&amp; 'CSSUnitValue' in window) &#123; CSS.registerProperty(&#123; name: '--circle-color', syntax: '&lt;color&gt;', initialValue: '#39f', inherits: false &#125;)&#125; 上面就是一个注册自定义属性的例子，定义了具体值类型的自定义属性就能够被用于动画了（即可以自动生成关键帧了）；CSSUnitValue是CSS Typed OM规范中的一个API，CSS.registerProperty()对其有依赖； @property @property规则语法和CSS.registerProperty()类似： 12345@property --circle-color &#123; syntax: '&lt;color&gt;'; inherits: false; initial-value: #39f;&#125; CSS Painting API 简介 CSS Painting API主要是由PaintWorklet组成，PaintWorklet定义了一套该类型worklet内所能访问的全局对象（PaintWorkletGlobalScope），绘制上下文（PaintRenderingContext2D，是CanvasRenderingContext2D API的子集）及注册和加载方法； 注册 在worklet文件（也是JS文件）内使用registerPaint()进行注册，该方法接收两个参数： registerPaint(name, class)[6] name：该paintWorklet的名称，用于在CSS中进行引用； class：实现该paintWorklet的类； 其中类可以实现以下（抽象）成员或方法： static get inputProperties()：返回一个数组，包含绘制函数所需要的属性（包括自定义属性）； static get inputArguments()：返回一个数组，指定传入绘制函数的参数语法类型（类似于registerProperty方法中的syntax参数）； static get contextOptions()：返回一个配置对象，用于设置绘制上下文（PaintRenderingContext2D）； paint(ctx, size, props, args)：必须实现；绘制函数接收四个函数： ctx：绘制上下文，即当前paintWorklet对应的PaintRenderingContext2D实例； size：PaintSize对象，包含width和height两个属性，即paintWorklet作用的元素的尺寸信息； props：StylePropertyMapReadOnly对象，只能访问由inputProperties属性返回的属性； args：参数数组，可以接收由CSS paint()函数传入的参数； 关于 StylePropertyMapReadOnly 对象 该对象类似于Map对象，但是不能set，因此是只读的；通过get()方法可以获取到对应属性，不过得到并不是属性值，而是一个CSSStyleValue对象（属于CSS Typed OM），不同syntax类型的属性会有不同类型的CSSStyleValue对象； 不过一般来说数值类型的属性值可以通过value属性来获取值，颜色类型则通过toString()方法来获取值，如： 12const boxColor = props.get('--box-color').toString()const boxWidth = props.get('--box-width').value 加载 事实上，worklet的加载方式很类似，都是通过addModule(url)方法来进行： 1234// 先判断paintWorklet是否可用if ('paintWorklet' in CSS) &#123; CSS.paintWorklet.addModule('worklet-path.js')&#125; 注：worklet文件地址仅支持https和localhost方式！ 使用 paintWorklet加载后就能够在CSS中进行使用了，可以使用paint(name)函数来启用worklet，name就是注册时传入的名称； name不需要加上引号！ paint()函数返回值类型为&lt;image&gt;，因此只能在属性值类型为&lt;image&gt;的属性中进行使用！如：background-imgae，list-style-image等；更多关于&lt;image&gt;类型的信息可以参考 - CSS（层叠样式表） | MDN； 传参 paint()函数也能传参，然后被paintWorklet中的paint()方法所接收： 1paint(paint-name, arg1, arg2, ...) 一个案例 看到上面这个动画，在不使用CSS Houdini之前，很难想象纯CSS能够得到这样的效果； 在线demo demo源码 相关文档 用CSS Houdini画一片星空 - 掘金 Houdini：CSS 领域最令人振奋的革新 - 知乎 CSS Houdini | MDN Using the CSS properties and values API - Web APIs | MDN Houdini工作小组关于CSS的揭秘 - w3ctech 和 Houdini, CSS Paint API 打个招呼吧 - 知乎：CSS Paint API入门体验 StylePropertyMapReadOnly - Web APIs | MDN CSS Object Model (CSSOM) - Web APIs | MDN：CSS Typed OM一览 CSS Painting API - Web APIs | MDN：CSS Painting API demo Is Houdini Ready Yet? ↩︎ Houdini：CSS 领域最令人振奋的革新 - 知乎 ↩︎ https://drafts.css-houdini.org/css-typed-om ↩︎ https://developers.google.com/web/updates/2018/10/animation-worklet ↩︎ CSS.registerProperty() - Web APIs | MDN ↩︎ PaintWorklet.registerPaint - Web APIs | MDN ↩︎]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>动效</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-lazyload的一个坑：事件失效]]></title>
    <url>%2Fpost%2Fvue-lazyload-event-not-work%2F</url>
    <content type="text"><![CDATA[前言 使用vue-lazyload的lazy-component组件对某个组件进行包裹，然后对组件整体设置懒加载效果时，存在一个坑：该组件内部的自定义组件（即非原生html标签）所有的自定义事件都会失效，且可能视图渲染不完全（多层组件嵌套时）； 可能的原因 初步猜测是lazy-component渲染函数的问题，因为渲染函数可以控制内部子元素的事件和属性等配置的挂载；然后一看该组件源码，其内部渲染函数为： 不知道是不是跟渲染函数的第二个参数为null有关，渲染函数的第二个参数是用来设置attribute相关的参数（即包括指令，自定义事件v-on及props等相关的属性）； 解决办法 首先本能地使用Vue实例自带的$foreUpdate()对组件内部进行强制重新渲染，但是重新渲染后还是存在上述问题；毕竟$foreUpdate()方法本质上就是再次调用组件的渲染函数进行渲染，如果渲染函数本身就存在问题，重新渲染多少次都没用。 直接修改源码也是一种办法，不过发现直接改源码并没有用，因为vue-lazyload包主文件是一个编译后压缩的js文件（大多数包都是编译后的），也就是说如果要通过改源码这一途径来解决就需要对这个包进行编译……这个还是有点麻烦的，毕竟看了一下里面的依赖挺多的； 不过好在发现这个lazy-component有个自定义事件show，看源码应该是在懒加载组件从不可见区域进入可见区域时触发的，有了这个时间点就好办了；只需要利用这个时间点，用lazy-component进行占位，然后列表项进入可见区域后马上隐藏lazy-component且显示真正的列表项组件，因为此时lazy-component组件和要进行懒加载的列表项组件是平级的（即兄弟关系），所以就避免了lazy-component组件渲染的坑，还可以直接利用其懒加载功能； 可以写成一个新的懒加载组件： 123456789&lt;!-- lazy-item组件 --&gt;&lt;template&gt; &lt;div class="item"&gt; &lt;!-- 通过lazy-component组件的show事件来切换真正的内容 --&gt; &lt;lazy-component v-if="showLazy" class="item-lazy" @show="load" /&gt; &lt;!-- 直接透传prop和自定义事件 --&gt; &lt;list-item v-else v-on="$listeners" v-bind="$attrs"/&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112export default class LayzItem extends Vue &#123; name = 'LayzItem' private showLazy = true private load () &#123; console.log('懒加载load') this.$nextTick(() =&gt; &#123; this.showLazy = false &#125;) &#125;&#125; 一个小技巧：透传 所谓的透传就是将父组件的属性直接传给子组件，而不是通过在父组件定义相关的props和事件，然后再传入到子组件上；如： 1&lt;list-item v-else v-on="$listeners" v-bind="$attrs"/&gt; 通过v-on直接绑定父组件的$listeners属性，可以将父组件上绑定的所有事件直接绑定到子组件上；同理，$attrs包含组件的所有attribute属性，通过v-bind则可以直接绑定到子组件上； 透传的好处就是不需要在父组件中重新定义相关属性再中转给子组件，适用于希望将父组件上的相关属性直接传递给子组件的情况；上面这种包装列表项为懒加载组件的情况就很适用，因为直接在懒加载组件（父组件）上绑定的属性和事件就可以原封不动地传给真正的列表项了。 相关文档 修改nodejs项目中node_modules的代码，不能生效吗？ - 知乎 渲染函数 &amp; JSX — Vue.js]]></content>
      <categories>
        <category>踩坑</category>
      </categories>
      <tags>
        <tag>vue-lazyload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决多分支并行开发公共文件维护的几种方案]]></title>
    <url>%2Fpost%2Fmulti-branch-common-file%2F</url>
    <content type="text"><![CDATA[前言 当项目越来越大，且存在多分支同时开发的时候，就会遇到公共文件维护的问题；比如当在A分支修改某个公共文件时，B分支无法同步该文件的修改，毕竟两个开发分支（迭代）的排期和测试进度是不一样的，不能贸然交叉合并开发分支，否则会造成代码污染的问题。因此需要一种解决方案来专门维护项目公共文件，避免出现公共文件修改不同步造成各种冲突和可能存在的关联性bug出现。 方案一：npm私库 利用npm私库可以把项目公共组件部分独立成npm包，不受分支影响； 优点： 独立性强 可以存在多个版本，有问题时可以快速回滚版本，也可以发版本修复 缺点： 组件调试不方便 文档插件兼容性和引入方式待确认 方案二：git subtree 利用git subtree将公共组件文件夹变成项目的一个子仓库，关于公共组件的修改可以全部同步在子仓库，其他分支可以随时从子仓库pull进行同步； 优点 相对项目内其它文件，子仓库文件比较独立 无需结构更改，可以无缝兼容项目结构 组件调试方便 缺点 子仓库相关更新的subtree命令比较繁琐（不过目测可以通过添加npm script解决） 需要严格遵循子仓库的改动必须使用subtree命令提交 方案三：独立的公共文件维护分支 就是指定一条分支专门维护公共文件（包括公共组件），也就是说所有涉及到公共文件的修改全都必须切到该分支，修改后在该分支进行上传；且该分支不能合并其他任何开发或测试分支的代码，但是可以定期合并主分支代码（已通过测试的）； 优点 利用git分支即可维护项目公共文件，无需额外学习成本 同样兼容已有项目结构 组件调试方便 不仅可以维护组件，还能维护其他公共文件 缺点 需要保证公共文件维护分支的纯洁性，即不能让其他分支污染 优化措施 由于公共文件比较特殊，可以考虑引入一些工具加强规范，减少人为错误，和及时的改动通知等； 公共文件改动群通知：无论是git库，还是单独分支，都可以利用webhook进行钉钉群通知； 规范commit消息，自动生成公共文件changelog：利用一些成熟的工具加强commit消息格式，然后每次自动记录生成规范的changelog文件，以便有清晰的修改记录，而且commit通知也会更具可读性； 针对方案三，可能存在一种强制校验的方式来禁止合并其他代码的分支到公共文件分支：利用git hook来检测本地代码合并是否满足要求，目前也有相关的npm包支持这种git hook，比如：husky。但是由于需要写脚本来验证是否有命令能够支持检测merge来源分支，所以尚不明确； 相关文档 多项目并行开发之公共资源处理：Git Sbutree拆分子仓库 - wl-ui - SegmentFault 思否 git subtree教程 - 个人文章 - SegmentFault 思否 Git管理多个分支的公共部分Howtomanagethecommonpartofmultiplebranches_basicthinker的专栏-CSDN博客 Git subtree: the alternative to Git submodule | Atlassian Git Tutorial 规范你的 commit message 并且根据 commit 自动生成 CHANGELOG.md - 掘金 Git子仓库深入浅出 - 掘金 用 Git Subtree 在多个 Git 项目间双向同步子项目，附简明使用手册Sina Weibo icon：实践总结 使用git钩子对提交代码进行检查(pre-commit) - 简书 git hook实践心得 - 腾讯Web前端 IMWeb 团队社区 | blog | 团队博客 GitHub - typicode/husky: Git hooks made easy 🐶 woof! 手牵手使用Husky &amp; Nodejs自定义你的Git钩子 · Issue #10 · PaicFE/blog · GitHub]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>基建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codepen挑战（2020-6-17）：滑动]]></title>
    <url>%2Fpost%2Fcodepen-challenge-sliding%2F</url>
    <content type="text"><![CDATA[前言 codepen每周挑战是codepen网站推出的活动，每周一次；每个挑战都有一个主题，基本上是围绕一个特定的场景或者CSS特性/库这类的，针对性比较强。 挑战描述 实际上是创建一个关于滑动的动画即可，并不局限于幻灯片切换的那种动画（一开始确实理解错了……）。 想法 Demo地址：https://codepen.io/xxf1996/pen/KKVNzxz 由于一开始理解成幻灯片切换效果动画了，所以创建一个幻灯片进（slide-in）和出（slide-out）的动画； slide-in运用的视觉效果是冲击 + 压缩 + 反弹； slide-out则是沿着一条曲线路径不断旋转，前进和渐隐；主要是运用了新增没几年的offset-path及相关属性； 有趣的案例 https://codepen.io/raczo/full/bGEwRBg 很有意思，一只看起来百无聊赖的北极熊在冰面上滑动，再加上显眼的MONDAY，寓意很明显。 北极熊本身是使用SVG进行绘制的，显眼的MONDAY有四层，中间两层是普通的文字，顶层和底层都是使用了-webkit-background-clip: text + -webkit-text-fill-color：transparent + 渐变生成的背景这一组合达成的效果； 文字效果相关的尝试：https://codepen.io/xxf1996/pen/OJMzKYo 相关文档 offset-path - CSS: Cascading Style Sheets | MDN：移动路径 offset-rotate - CSS: Cascading Style Sheets | MDN https://codepen.io/anthonydugois/full/mewdyZ ：一个可视化输出SVG path的工具 -webkit-text-stroke - CSS（层叠样式表） | MDN：用于文字描边]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>codepen</tag>
        <tag>动效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[husky钩子的一些用法]]></title>
    <url>%2Fpost%2Fhusky-and-git-hooks%2F</url>
    <content type="text"><![CDATA[前言 husky是一个npm包，可以将git内置的钩子暴露出来，很方便地进行钩子的命令注入，而不需要在.git目录下自己写shell脚本了；不仅可以执行js文件作为脚本，还可以将脚本暴露出来，方便在git项目中进行管理。 基本用法 原理 husky支持的钩子就是git hooks，可以在对应钩子指定一条shell命令，husky会自动将这个命令写入.git目录下的对应钩子脚本，当触发这个git钩子时则会执行我们写入的命令； 因此husky本质上就是执行shell命令，因此只要是shell命令都可以在钩子中执行；由于nodeJS也可以通过命令行执行，所以直接用js来充当脚本也是可以的； 命令配置 可以在package.json文件的husky.hooks对象中写入相应的命令即可，键名就是钩子名称，键值就是需要执行的命令，如： 123456789&#123; "husky": &#123; "hooks": &#123; "pre-commit": "node ./hooks/pre-commit", "commit-msg": "node ./hooks/commit-msg $HUSKY_GIT_PARAMS &amp;&amp; commitlint -E HUSKY_GIT_PARAMS", "post-merge": "node ./hooks/post-merge" &#125; &#125;&#125; husky当然也支持通过专门的配置文件来指定钩子命令，但是使用过程中经常发生钩子配置不起作用的情况，还是package.json这种方式最稳定； 常用钩子 pre-commit：由git commit命令触发，在commit-msg之前； commit-msg：git commit和git merge都会触发，会传递一个参数，该参数为存放当前commit消息的临时文件路径；可以通过--no-verify参数来跳过commit-msg钩子； post-merge：触发于merge完成后； 一些技巧 在 node 脚本中如何退出 当使用node脚本进行检测，希望检测不通过时阻止git进行下一步操作，即终止操作；仅仅抛出错误是不能终止命令的，只能抛出exit状态才能终止；如： 1process.exit(1) // exit状态为1才能终止 在 node 中执行 shell 命令 有些用于检测的信息只能通过shell命令执行获取（如git相关的信息），如果想要在node中获取到这些信息，可以使用node自带的一些方法来执行；比如exec和spawn方法。 上面两个都是child_process模块里面的方法： 1const &#123; spawn, exec &#125; = require('child_process') 虽然这两个方法都可以执行shell命令，但是具体用途有所不同；就作用而言，spawn方法更加广泛，可控性更强； 当仅仅需要执行shell命令来获取信息（文本）时，可以使用exec方法； 如果需要按照原格式（即包含颜色，缩进，换行等）暴露shell命令的标准输出，那么就需要用到spawn方法了；因为exec得到的标准输出已经格式化了，仅仅是普通的文本字符串； 可以将上述方法包装成Promise对象，这样更加方便进行同步调用： 123456789101112131415161718192021222324252627282930313233343536373839/** * 执行shell命令，返回promise； * 这种方式不会捕获的命令输出会被格式化，即没有颜色缩进等； * @param &#123;string&#125; shell shell命令 */function execShell (shell) &#123; return new Promise((resolve, reject) =&gt; &#123; exec(shell, (err, stdout, stderr) =&gt; &#123; if (err) &#123; process.stdout.write(stdout) error(`命令执行错误！\n\n$&#123;stderr&#125;`) reject(stderr) &#125; else &#123; resolve(stdout) &#125; &#125;) &#125;)&#125;/** * 执行shell命令，返回promise； * 这种方式不能捕获命令输出，但是可以按原格式进行输出； * @param &#123;string&#125; shell shell命令 */function execShellOrigin (shell) &#123; const shellArr = shell.split(' ') const process = spawn(shellArr[0], shellArr.slice(1), &#123; stdio: 'inherit' // 命令的输出按原格式进行输出 &#125;) return new Promise((resolve, reject) =&gt; &#123; process.on('close', code =&gt; &#123; if (code) &#123; // 根据exit code可以判断命令执行结果 reject(code) &#125; else &#123; resolve() &#125; &#125;) &#125;)&#125; 在 commit-msg 钩子中获取/修改 commit 消息 执行commit命令后，git会将commit消息存放于一个临时文件中；然后触发pre-commit钩子，pre-commit钩子成功之后就会触发commit-msg，commit-msg钩子成功后则会将临时文件中的文本作为此次commit消息进行存储； 并且commit-msg钩子会对脚本传一个参数，这个参数就是存放commit消息的临时文件的路径；所以得到这个参数，就可以读取该文件的内容，也就能得到当前commit消息了；同理，在commit-msg钩子中覆盖这个文件就能对此次commit消息进行修改了； It takes a single parameter, the name of the file that holds the proposed commit log message.[1] 不过，由于在husky中的指定的commit-msg钩子命令并不是git直接执行的，因此只能通过husky间接暴露的变量$HUSKY_GIT_PARAMS来获取临时文件的地址，如： 12# $HUSKY_GIT_PARAMS变量就是commit-msg钩子传递的文件路径参数node ./hooks/commit-msg $HUSKY_GIT_PARAMS Git hooks can get parameters via command-line arguments and stdin. Husky makes them accessible via HUSKY_GIT_PARAMS and HUSKY_GIT_STDIN environment variables.[2] 在node脚本内部就可以利用process.argv来获取命令行参数了； 1const param = process.argv[process.argv.length - 1] // 获取git commit消息临时存放文件地址 读取和写入操作既可以依靠node自带的方法，也可以利用shell命令（shell命令简单粗暴）； 钩子没有触发 当第一次安装husky的时候，可能会出现.git/hooks里面的文件没有被覆盖的情况；此时，git hooks仍然是之前的状态（默认是没有效果的）；如果是husky安装正常，使用命令ls .git/hoooks查看文件则是下面这样： 随便打开一个钩子脚本文件，内容可能是这样： 12345678#!/bin/sh# husky# Created by Husky v4.2.5 (https://github.com/typicode/husky#readme)# At: 2020-6-16 17:14:54# From: /Users/snowdream/Desktop/bhb/dp-admin/node_modules/husky (https://github.com/typicode/husky#readme). "$(dirname "$0")/husky.sh" 如果不是上述形式，那么就是husky注入失败；可以通过重新安装（先uninstall再install）进行重新注入，因为每次安装husky时会重新覆盖一次.git/hooks脚本文件。 可用 shell 命令收集 获取当前 git 分支名称 1git symbolic-ref --short -q HEAD 获取最新的一条 git 提交信息 1git rev-list --no-walk --header HEAD 可以得到很详细的信息，用于进一步检测，比如检测最新的一次提交是不是merge，merge行为是否合法等待； 1234567635a70d8e1eaccfe7a460e76ae400a0e5cc95161tree 6ff519aef0471392e6da9f068cace81f3e874b56parent c4e3385d4cab66b27ba64f2bce3df179b0bb4d3aauthor xiexuefeng &lt;xxx@qq.com&gt; 1592881689 +0800committer xiexuefeng &lt;xxx@qq.com&gt; 1592881689 +0800 fix: xxx 读取或写入文件 读取使用cat命令： 1cat file-path 写入使用echo命令： 1echo "content" &gt; file-path 相关文档 Git - githooks Documentation inanzzz | Automatically amending the commit message with commit-msg hook javascript - Retaining output colors when shelling out to node - Stack Overflow：输出原格式的来源 git rev-list (Plumbing Commands) - Git 中文开发手册 - 开发者手册 - 云+社区 - 腾讯云：rev list命令文档，该命令十分强大 Husky cannot execute hooks · Issue #445 · typicode/husky · GitHub Git - githooks Documentation ↩︎ GitHub - typicode/husky: Git hooks made easy 🐶 woof! ↩︎]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>husky</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从类型系统的角度看TS]]></title>
    <url>%2Fpost%2Fts-in-type-system%2F</url>
    <content type="text"><![CDATA[前言 很多时候TS这门语言只被人看作是ES的类型增强版，然而在我看来TS作为ES的超集，ES语法可以看作是一个维度，而多出的类型系统则可以看作是另一个维度；也就是说如果把ES看作是一个一维编程语言，那么TS就是一个二维编程语言； 这篇文章尝试从多出来的一个维度来描述TS类型编程的独特性和一般性；所以，涉及各种类型的定义和用法不再过多阐述。 跟大多数编程语言一样，TS类型编程也遵循程序语言设计的一些原则。 程序设计语言的基本成分包括数据、运算、控制和传输等。 数据 数据是程序操作的对象，具有类型、名称、作用域、存储类别和生存期等属性，在程序运行过程中要为它分配内存空间。 本来习惯性地想把TS中所有用来存储类型的数据称之为“变量”，但是变量在严格意义上是可以在运行时改变值的，但是据观察，TS中的数据不允许多次赋值，所以也就不能称之为“变量”了，实际上所有的类型数据都是常量，不过声明合并那又是另一回事了； 1234567891011type Test = &#123; name: string;&#125;Test = &#123; age: number;&#125; // 这样的重新赋值，TS是不允许的，因为此时该标识符被认为是ES中的变量了type Test = &#123; age: string; // 事实上同类型的标识符也不能重复声明&#125; 标识符 TS中的标识符就是用来命名类型，泛型，命名空间，模块等事物的特定字符串；经实验，标识符的命名规则如下： 不允许数字开头； 1234// ❌type 3d = &#123; a: string;&#125; 不允许使用标点符号，下划线_和美元符号 $ 除外； 1234567891011121314// ❌type d+ = &#123; a: string;&#125;// ✅type d_ = &#123; a: string;&#125;// ✅type $c$ = &#123; name: string;&#125; 可以使用大小写英文字符，且区分大小写； 123456789// ✅type SOME_test = &#123; a: string;&#125;// 区分大小写type some_test = &#123; name: string;&#125; 中文字符也是可以的； 12345678// ✅type 中文 = &#123; name: string;&#125;const a: 中文 = &#123; name: 'ssss'&#125; 值 TS类型系统的值有点特殊，因为其值对于ES而言是“类型”，也就是说类型系统中的值就是类型；正是由于值的特殊性，容易让人忘记实际上用来约束ES代码的类型只不过是类型系统中普普通通的值； 值类型 注：这里的值类型对于ES来说就是“类型的类型”了。 原始类型：string，number，boolean，null，undefined，symbol，bigint，void；（本来理解原始类型应该类似于原子类型，应该是相互互斥的，但是null和undefined的存在打破了互斥关系……） 顶部类型：类型系统中的根节点，即其他所有非顶部类型都是其子类型；如any 和unknown； 底部类型：不存在对应值的一种类型，即不能兼容所有类型，包括自身；如never； 复合类型：复合类型则是对原始类型，顶部类型和底部类型的一种组合；比如对象类型（object及由interface和type构建的对象类型），数组，元祖，枚举（enum关键字声明的类型），类（class关键字声明的类型）等； 函数类型：function关键字声明的类型（interface也能声明出函数的结构）； 字面量类型：这里的字面量就是指可以在ES中作为字面量使用的值； 数据结构类型 根据TS类型声明关键字的不同，可以把存储的数据结构分为以下几种： interface class function enum type namespace / moudle 运算 类比于一般编程语言中的数据基本运算，实际上TS类型系统也是有值运算的，只不过运算比较特别； 二元运算 联合类型：使用|符号对两个值进行联合，得到的效果跟数组相似； 交叉类型：使用&amp;符号对两个值进行交叉； 三元运算 条件运算：跟其他编程语言中一样，使用三元运算符?:来进行条件运算； 集合 注：本来是想把联合类型当作是类型系统中的数组结构的，但是仔细一想好像不严谨，因为联合类型自带去重，因此更像是集合结构； 在类型系统中，并没有显式的集合数据结构，但是可以把联合类型当作是类型系统中的集合，因为很多时候联合类型的表现跟其他编程语言中的集合是相似的；比如： 组成联合类型的其中每个值可以看作是一个元素； 可后续添加新元素和移除（移除指定元素需要函数来支持）； 123type A = number | stringtype B = A | boolean // 后续可以利用 | 符号继续添加type C = Exclude&lt;A, number&gt; // 可以利用Exclude函数进行去除指定元素 添加元素时会自动去重； 12type a = number | string | booleantype b = a | number // 由于联合类型a已经包含number，所以再次添加时会去重 可进行遍历，使用关键字in来对象类型中展开； 1234567type keys = 'name' | 'age' | 'other'type ForStep&lt;T extends keyof any&gt; = &#123; [P in T]: P | 'value'; // 利用in对集合进行遍历，然后可以对元素进行一些操作&#125;type test = ForStep&lt;keys&gt; 可进行映射，利用分布式条件类型可对集合进行映射处理； 123type a = number | string | booleantype b&lt;T&gt; = T extends string ? 'test' : T // 将元素string替换成字符串testtype c = b&lt;a&gt; // 进行映射处理 对象 类型系统中的对象就是对象类型（可以由interface，type甚至是class创建得到），对象类型具有跟ES中对象相似的结构，只不过键值是类型而已； 12345678910111213141516interface A &#123; name: string; age: number;&#125;type B = &#123; readonly ok: boolean; size: number; other?: string[];&#125;declare class AAA &#123; name: string private some (word: string): Promise&lt;boolean&gt;&#125; 索引访问 类型系统中的对象也是支持通过索引来访问相应属性的值，只不过只能通过[key]（中括号）的方式进行访问，不能像ES中那样通过.（点符号）来访问！ 1type C = A['age'] | B['ok'] | AAA['some'] // 没错，class也能当做对象进行访问 对象中属性的修饰符（或者类成员的修饰符）则不会被带入到键值，也就是通过索引访问访问只能得到属性值；不过如果是可选属性，那么属性值默认会与undefined进行联合； 1234type D = &#123; extra: B['other']; // 访问可选属性 some: B['ok']; // 访问readonly属性&#125; 不仅如此，索引访问还支持使用集合（也就是联合类型）来进行一次访问多个属性值，且将多个属性值进行联合，最后得到一个集合； 1type E = B['ok' | 'other'] // 还可以用联合类型来访问多个属性值 函数 注：泛型类型（generic type）指的就是TS中带泛型的类型。 同样地，类型系统中并没有显式声明函数的语法；但是泛型类型完全可以当作是类型系统中的函数，因为泛型类型可以接受参数并返回不同的值，也就是说泛型类型具备入参（输入）和出参（输出）的形式。如常用的官方内置泛型类型Pick： 123type Pick&lt;T, U extends keyof T&gt; = &#123; [K in U]: T[K];&#125; 上面这段代码就可以理解为一个定了两个参数的函数，这个函数会对第二个参数进行遍历，然后构成一个新的对象类型，并返回这个值； 递归 没错，类型系统中的“函数”也能够调用自身，如： 1type DeepReadonly&lt;T&gt; = &#123; readonly [P in keyof T]: DeepReadonly&lt;T[P]&gt; &#125; 控制语句 类型系统中并没有其他编程语言那种使用独立的关键字和语法结构显式的控制语句，但是也有某些关键字能够起到类似的作用。这个局面个人猜测可能与TS本身就包含了ES的全部语法，导致使用独立关键字和语法结构来定义控制语句会出现冲突（除非定义一套互斥的语法）； 条件语句 T extends U ? True分支 : False分支 使用extends关键字来获取条件结果，三元运算符?:来控制条件分支，这就是类型系统中特有的条件语句，当然，条件语句也是可以嵌套的。 循环语句 [K in Union Type] 使用关键字in可以在对象类型索引签名中遍历集合（也就是联合类型），并能够得到集合中的每个元素，进行下一步控制； 相关文档 【万字长文】深入理解 Typescript 高级用法 - 知乎 类型系统 - 维基百科，自由的百科全书 浅谈 TypeScript 类型系统 - 知乎 附件：程序设计语言基础知识.pdf]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>TS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序原生语法工程化]]></title>
    <url>%2Fpost%2Fweixin-miniprogram-project%2F</url>
    <content type="text"><![CDATA[前言 关于微信小程序的工程化处理，如果像是选择mpvue、wepy等框架，项目其实就是按照一般的vue项目进行处理，只不过基于一般的vue项目多了一层转编译成原生小程序代码； 但如果直接使用原生语法来搭建小程序项目，那么该如何进行一些工程化的处理呢？不可能是完全地一个个页面独立地手写，这样效率太低了。 组件 组件的创建 小程序本身就提供了组件的语法，首先需要对.json文件做一个声明： 123&#123; "component": true&#125; 而视图（wxml）和样式（wxss）则和一般页面的写法是一样的。主要的区别就是逻辑文件（js）的写法，声明组件需要使用Component()： 1234567891011121314151617Component(&#123; properties: &#123; // 这里定义了innerText属性，属性值可以在组件使用时指定 innerText: &#123; type: String, value: 'default value', &#125; &#125;, data: &#123; // 这里是一些组件内部数据 someData: &#123;&#125; &#125;, methods: &#123; // 这里是一个自定义方法 customMethod: function()&#123;&#125; &#125;&#125;) properties是用来声明组件的自定义属性的，可以在wxml中当做data来使用；实际上就是用来进行传递父级数据的。需要注意的是组件的生命周期和页面的生命周期有所不同，组件还能监听到所在页面（Page）的一些生命周期，详情可以查看官方文档：https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html 组件的使用 总所周知，组件有全局组件和局部组件，小程序组件也一样；如果是全局组件，则声明在app.json文件中，如果只是局部组件（单独使用），则可以在页面对应的json文件中进行声明，语法如下： 123"usingComponents": &#123; "component-tag-name": "path/to/the/custom/component"&#125; usingComponents就是声明使用组件的地方，键名就是组件的标签名，键值就是组件的路径。 mixin 导出语法只能是CommonJS？ 小程序为原生组件也提供了一套类似混合（mixin）的语法，叫做behaviors；用独立的js文件编写，然后引入到相应的组件文件（js）中即可。语法大致如下： 12345678910111213141516// my-behavior.jsmodule.exports = Behavior(&#123; behaviors: [], properties: &#123; myBehaviorProperty: &#123; type: String &#125; &#125;, data: &#123; myBehaviorData: &#123;&#125; &#125;, attached: function()&#123;&#125;, methods: &#123; myBehaviorMethod: function()&#123;&#125; &#125;&#125;) 其作用就是复用组件之间的自定义属性、方法、数据等等。 使用 behaviors 使用的语法跟vue中mixin的使用类似，在组件的behaviors属性中添加相应的behavior文件即可； 1234567891011121314151617// my-component.jsvar myBehavior = require('my-behavior')Component(&#123; behaviors: [myBehavior], properties: &#123; myProperty: &#123; type: String &#125; &#125;, data: &#123; myData: &#123;&#125; &#125;, attached: function()&#123;&#125;, methods: &#123; myMethod: function()&#123;&#125; &#125;&#125;) WXS 语法限制 由于小程序本身语法的限制，导致在wxml的模板语法中并不能使用自定义方法，但是wxs定义的方法却能够在模板语法中使用，这样就能解决不能使用方法来处理模板语法中数据的问题了。 wxs是小程序自定义的一套脚本语言，实际上就是基于ES5进行的一些改造，不过有些原生对象做了限制，如Date对象。因此，在wxs中并不能使用ES6及以上语法，且模块语法为CommonJS！举个例子： 12345678910111213var getMax = function(array) &#123; var max = undefined; for (var i = 0; i &lt; array.length; ++i) &#123; max = max === undefined ? array[i] : (max &gt;= array[i] ? max : array[i]); &#125; return max;&#125;module.exports = &#123; getMax: getMax&#125;; 由于习惯了ES6以上的语法，所以写wxs的时候务必注意： 不能使用let、箭头函数和模板字符串等语法 导出只能通过module.exports对象 创建和使用 wxs既可以在wxml中进行声明，然后直接使用；也可以写在独立的.wxs文件中，然后引入到相应的wxml中进行使用。需要注意的是，不管是哪种方式，wxs里面的方法和数据都要进行导出之后才能进行使用！ wxml文件内 在wxml中则通过在&lt;wxs&gt;标签中声明wxs语法，然后通过module属性来指定该模块的名称，然后在wxml中进行使用即可； 12345678910&lt;wxs module="demo"&gt; function hello (text) &#123; return 'hello, ' + text &#125; module.exports = &#123; hello: hello &#125;&lt;/wxs&gt;&lt;text&gt;&#123;&#123;demo.hello(name)&#125;&#125;&lt;/text&gt; 独立的wxs文件 声明类似，只不过是把wxs代码写在单独的.wxs文件中而已： 12345678// demo.wxsfunction hello (text) &#123; return 'hello, ' + text&#125;module.exports = &#123; hello: hello&#125; 然后通过&lt;wxs&gt;标签进行引入： 12&lt;wxs src="path/to/demo.wxs" module="demo"&gt;&lt;/wxs&gt;&lt;text&gt;&#123;&#123;demo.hello(name)&#125;&#125;&lt;/text&gt; 通过&lt;wxs&gt;的src属性来指定.wxs文件的位置； 其他注意事项 .wxs和.js文件不能互相引入，.wxs只能引入.wxs文件！ 使用require()函数引入.wxs文件时，只能使用相对路径！ npm包的使用 这个流程官方文档就已经说的很清楚了，不再赘述了。 后话 虽说微信小程序为原生语法工程化提供了配套的语法和设施，但是很显然，同诸如vue + webpack等成熟的前端工程化配套而言，像是一个『拙劣的模仿者』，也只能是凑合着用了。 相关文档 自定义组件 | 微信开放文档 npm 支持 | 微信开放文档]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将swagger文档模型转换为相应的TS声明]]></title>
    <url>%2Fpost%2Fswagger-to-ts%2F</url>
    <content type="text"><![CDATA[前言 每次看到后端发布的swagger文档，然后根据相关接口的响应体模型去编写对应的TS类型时，我就不禁在想，为何不能自动根据swagger文档模型来生成相应的TS声明呢？这不，网上一查资料果然已经有人造起了轮子，直接开干。 方法一：swagger-to-ts 可以使用插件swagger-to-ts直接利用命令转换；该插件支持从swagger生成的yaml或json配置进行转换，而且支持直接拉取网络地址的配置； 安装完npm包后可以直接运行命令进行转换： 1npx @manifoldco/swagger-to-ts swagger-url -o ts-file-path.ts swagger-url：swagger文档配置网络地址或本地配置路径 ts-file-path.ts：转换后的TS文件路径； 而且该插件还会直接使用prettier对生成的TS文件进行美化，且支持指定prettier配置文件；听起来很棒，但实际上有坑，因为利用prettier转换的过程中可能会报错，且貌似无法控制prettier转换的开关……因此如果不符合prettier格式要求，那就生成不了TS文件了； 方法二：swagger官方转换器 swagger官方有个在线编辑器，这个在线编辑器功能十分强大，不仅能够在线编辑配置并实时预览swagger文档，还支持直接导入已有的配置（支持从网络地址导入）： 导入后就可以进行swagger模型的转换操作，其中就有一种转换方式为typescript-node，导出后是比较通用的TS结构； 导出的TS效果如下： 效果还是不错的，复制粘贴改造一下就很完美了，省下很多时间逐一敲代码了。 如何找到swagger配置地址？ 一般而言，后端通过swagger自动生成文档网站然后部署，直接打开该网站，然后查看请求： 一般会有一个请求地址为xxx/swagger-doc的请求，该地址就是获取swagger配置json文件的API地址；根据这个地址就可以直接去官方编辑器进行导入操作了； 后话 使用转换工具得到的TS声明跟实际项目中实践的方式可能会有出入，不可避免地需要进行手动调整；如果需要做到一次转换无需修改即可使用，那估计得和后端制定双方遵循的模型规范，还有高度规范化的TS实践方式； 相关文档 How to generate basic TypeScript interfaces from Swagger schema? - Stack Overflow GitHub - manifoldco/swagger-to-ts: Generate TypeScript types from Swagger OpenAPI specs：npm包，支持命令行转换 Swagger Editor：官方插件，支持转换为各种格式]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>TS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于挤压动画的一种尝试]]></title>
    <url>%2Fpost%2Fa-squish-animation-test%2F</url>
    <content type="text"><![CDATA[前言 前不久在codepen看到一个点击按钮出现挤压动画的demo，看起来很流畅，也比较简洁； 然后一看源码，使用的是GSAP这个动画库加上svg路径结合的，看起来SVG的路径有点复杂。然后心里想着能不能用更简单的代码或者思路来还原这种效果，看了一些资料后，心里大概出现了几种思路： 方法1：尝试利用clip-path + animation来实现 方法2：尝试利用clip-path + SVG clipPath animation 方法3：尝试利用transform的matrix()进行矩阵变换 + animation 尝试 方法一：clip-path + animation clip-path属性用于设置裁剪区域，使得元素只有裁剪区域的部分才会显示，最关键的是clip-path支持动画！但是经过一番尝试，clip-path目前支持的裁剪形状并不能满足挤压动画的需求，即凹曲线；目前clip-path支持的形状有： inset()：矩形； circle()：圆形； ellipse()：椭圆； polygon()：多边形； url()：引用SVG形状； 几何框盒； 事实上，clip-path有个很强大的形状来源，即path()方法，该方法可以使用SVG Path语法来构建形状，但是该方法目前很多浏览器并不支持在clip-path属性中使用，所以就比较遗憾了； 方法二：clip-path + SVG clipPath aimation 没错，由于clip-path中可以使用url()方法来引用SVG图形，因此我们也可以借助SVG这条思路来实现挤压所需要的形状，毕竟SVG path语法是十分的强大，还支持贝塞尔曲线，几乎任何形状都可以绘制出来； 而具体到SVG中就是使用clipPath元素来声明一个裁剪区域，然后使用url(#name)来引用即可；这看名字就知道clip-path属性就是借鉴的SVG clipPath了，基本用法如下： 12345&lt;svg id="mask" width="0" height="0"&gt; &lt;clipPath id="m1"&gt; &lt;path d="M0 200 L200 200 Q181 131 144 144 Q113 156 69 150 Q25 144 0 200"&gt;&lt;/path&gt; &lt;/clipPath&gt;&lt;/svg&gt; 123.demo &#123; clip-path: url("#m1");&#125; 在clipPath元素内定义的形状就是裁剪区域，除了可以使用path，还可以使用SVG内其他用来定义形状的元素，如：&lt;rect&gt;，&lt;circle&gt;等；不仅如此，还可以使用SVG animation语法，对形状进行动画处理；但是经实践，path的d属性开启动画后，被引用时并没有预想中那样有插值关键帧过渡的效果，而是直接跳到最后一帧，也就是说clipPath内的动画对于path没有效果： 123456789101112&lt;svg id="mask" width="0" height="0"&gt; &lt;clipPath id="m1"&gt; &lt;path d="M0 200 L200 200 Q181 131 144 144 Q113 156 69 150 Q25 144 0 200"&gt;&lt;/path&gt; &lt;animate attributeType="XML" attributeName="d" from="M0 200 L200 200 Q181 131 144 144 Q113 156 69 150 Q25 144 0 200" to="M0 200 L200 200 Q188 100 119 150 Q88 175 44 181 Q13 188 0 200" dur="2s" repeatCount="indefinite"/&gt; &lt;/clipPath&gt;&lt;/svg&gt; 123.demo &#123; clip-path: url("#m1");&#125; 像上面这种利用animate改变&lt;path&gt;元素的d属性，在clipPath并没有看到效果；不知道是不是用法不对，反正利用SVG animation来改变贝塞尔曲线实现挤压动画的尝试失败了…… 方法三：matrix()/matrix3d() 突然想起transform属性中可以使用matrix()/matrix3d()这种方法，也就是说还有矩阵变换这条路可以走；于是乎去网上找了下有没有类似挤压动画这种的扭曲变换，没想到还真找到一个比较相似的，叫做“柱面投影变换”；原理很简单，就是通过把矩形区域投影到一个圆柱体外侧面或内侧面上，从而得到一个挤压或拉伸的图形： 如果投影平面是圆柱体的外侧，那么就能得到跟挤压效果类似的凹曲线： 然而，很明显这种变换是非线性变换，而matrix()/matrix3d()只能接受常数作为矩阵元素，也就没办法实现非线性变换了！ 改变思路：思考原理 上面尝试的三种方法都失败了，可能是把问题想的太简单了，想通过已有的属性直接插值形成动画，而不想增加任何额外的计算；事实上，由于clip-path属性中有个polygan()方法可以绘制任意形状的多边形，而且支持动画（也就是可以关键帧自动插值），然而在图形学中，所有的曲线本质上就是通过对曲线的插值绘制出线段得到的；也就是说我们可以通过插值得到一个近似挤压动画需要的多边形形状，只要能够找出描述那个挤压曲线的公式即可，实践证明这是可行的，而且最终代码还不怎么复杂且可控； 挤压曲线的插值点坐标求解 如图所示，以矩形区域左下角为原点，假设挤压曲线为一段圆弧，挤压曲线距离原底边最高处的高度（波峰高度）为aaa，圆弧所处圆的半径为rrr，再设圆弧对应的弦长度的一半为ccc，于是就能得到： r2=(r−a)2+c2⇒r=a2+c22a\begin{aligned}r^2 &amp;= (r - a)^2 + c^2 \\[1em] \Rightarrow r &amp;= \frac{a^2 + c^2}{2a} \end{aligned} r2⇒r​=(r−a)2+c2=2aa2+c2​​ 根据rrr及圆心坐标就可以得到圆的轨迹方程： (x−c)2+(y−a+r)2=r2(x - c)^2 + (y - a + r)^2 = r^2 (x−c)2+(y−a+r)2=r2 根据圆的轨迹方程又可以得到挤压曲线（圆弧）部分yyy的求解： y−a+r=±r2−(x−c)2∵y⩾0∧r−a&gt;0∴y−a+r=r2−(x−c)2⇒y=r2−(x−c)2+a−ry - a + r = \pm \sqrt{r^2 - (x - c)^2} \\[1em] \because y \geqslant 0 \quad \land \quad r - a &gt; 0 \\[1em] \therefore y - a + r = \sqrt{r^2 - (x - c)^2} \\[1em] \\[1em] \Rightarrow y = \sqrt{r^2 - (x - c)^2} + a - r y−a+r=±r2−(x−c)2​∵y⩾0∧r−a&gt;0∴y−a+r=r2−(x−c)2​⇒y=r2−(x−c)2​+a−r 由于a和c是已知的，然后就能得到rrr；因此，当xxx确定后，就能得到对应的yyy值了；所以挤压曲线上每个点的坐标都可以求出，也就能够进行插值化处理了！ 插值化处理 在底边上等间距选取nnn个点，根据这些点的xxx坐标和已确定的波峰高度就能够得到对应位置的挤压曲线上的坐标点位置（其实主要是yyy值，以水平方向挤压曲线为例），然后按顺序连接这些插值得到的挤压曲线上的点，就可以得到近似挤压曲线的线段，这些线段闭合后就符合挤压动画所需的挤压效果了； 可以设计函数来根据参数（如插值点个数，波峰高度等）自动生成符合polygan()方法接受的路径格式；如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 获取弦上一点对应圆弧的高度差 * @param &#123;number&#125; x 圆弧对应的弦偏移位置 * @param &#123;number&#125; length 挤压圆弧对应的弦长度 * @param &#123;number&#125; crest 挤压圆弧波峰高度 */function getSquishOffset (x, length, crest) &#123; const half = length / 2 const half_2 = half * half const crest_2 = crest * crest const r = (half_2 + crest_2) / (2 * crest) return Math.sqrt( r * r - Math.pow(x - half, 2) ) + crest - r&#125;/** * 根据配置获取相应元素的挤压动画关键帧参数，拼接形式为多边形（polygan） * @member &#123;number&#125; width 元素宽度 * @member &#123;number&#125; height 元素高度 * @member &#123;number&#125; crestX 水平挤压曲线波峰高度 * @member &#123;number&#125; crestY 垂直挤压曲线波峰高度 * @member &#123;number&#125; pointX 水平方向插点个数 * @member &#123;number&#125; pointY 垂直方向插点个数 */function getSquishPath (&#123;width, height, crestX = 3, crestY = 3, pointX = 11, pointY = 11&#125;) &#123; let fromTop = [] // 上 + 右 let fromBottom = [] // 下 + 左 let toTop = [] let toBottom = [] const perX = 100 / (pointX - 1) const perY = 100 / (pointY - 1) for (let i = 0; i &lt; pointX; i++) &#123; const curX = Number((i * perX).toFixed(2)) // 当前水平位置百分比 const offset = Number(getSquishOffset(width * curX / 100, width, crestX).toFixed(2)) fromTop.push(`$&#123;curX&#125;% 0%`) fromBottom.unshift(`$&#123;curX&#125;% 100%`) toTop.push(`$&#123;curX&#125;% $&#123;offset&#125;px`) toBottom.unshift(`$&#123;curX&#125;% calc(100% - $&#123;offset&#125;px)`) &#125; for (let i = 1; i &lt; pointY - 1; i++) &#123; const curY = Number((i * perY).toFixed(2)) // 当前垂直位置百分比 const reverseY = Number((100 - i * perY).toFixed(2)) const offset = Number(getSquishOffset(height * curY / 100, height, crestY).toFixed(2)) fromTop.push(`100% $&#123;curY&#125;%`) fromBottom.push(`0% $&#123;reverseY&#125;%`) toTop.push(`calc(100% - $&#123;offset&#125;px) $&#123;curY&#125;%`) toBottom.push(`$&#123;offset&#125;px $&#123;reverseY&#125;%`) &#125; console.log([fromTop.join(', '), fromBottom.join(', ')].join(', ')) console.log([toTop.join(', '), toBottom.join(', ')].join(', ')) return &#123; from: [fromTop.join(', '), fromBottom.join(', ')].join(', '), // 初始帧（实际上就是矩形） to: [toTop.join(', '), toBottom.join(', ')].join(', ') // 挤压最后帧（挤压圆弧插值） &#125;&#125; 其他注意事项 动态修改挤压效果 如果想要动态修改动画效果，即修改@keyframes里面的内容；有一种思路就是利用原生的CSS变量，用CSS变量来存储关键帧中clip-path属性的值，然后利用:root（即根文档节点）元素的style来设置变量值，如： 12345const root = document.documentElement // 获取根文档节点// 设置css变量用于传递动画参数root.style.setProperty('--test-from', `polygon($&#123;info.from&#125;)`)root.style.setProperty('--test-to', `polygon($&#123;info.to&#125;)`)root.style.setProperty('--test-duration', config.duration + 's') 然后在关键帧动画相应的位置引用变量即可，这样动态修改变量值后，对应的动画效果也会改变；如： 1234567891011@keyframes test &#123; from &#123; clip-path: var(--test-from); &#125; 50% &#123; clip-path: var(--test-to); &#125; to &#123; clip-path: var(--test-from); &#125;&#125; 如何在每次点击的时候触发动画 简单粗暴的通过点击事件添加动画，动画完成后移除动画这种方式我没试过是否可行；我使用的是另一种思路：将动画播放次数设置为无限次数，但是默认的animation-play-state为paused（即暂停状态），点击后将动画的播放状态设置为running（即播放状态），每次动画结束后自动切换为暂停状态。 顺便说一下，监听动画每一次结束的时机可以使用animationiteration这个事件（该事件本质是在每次动画开始前触发，但不包括第一次，因此可用来当作动画每次播放结束的触发点）； 123456demo.addEventListener('click', () =&gt; &#123; demo.classList.add('play') // 点击播放动画&#125;)demo.addEventListener('animationiteration', () =&gt; &#123; demo.classList.remove('play') // 动画一次结束后暂停&#125;) 后话 我承认这种方法有点“硬核”，包含一些数学公式的推导，但实际上用到的知识只是高中数学里面的，过程并不复杂，只不过很久没用有点生疏了；而且第一次推导的时候还弄错了，有点尴尬，不过推导成功还是挺舒服的，最后得到的代码也并不复杂，最重要的是理解了本质问题，又加以应用，还是收获很大的； 上面就是推导过程的草稿，好久没写过数学推导了，还是挺有意思的；最后写了一个交互的demo，效果看起来还比较满意，可能动画参数还需要打磨一下； 这个交互demo还可以随时调整一些挤压动画的参数，然后查看改变后的效果；demo地址为：A squish animation demo 扩展资料：关于柱面投影变换的思路 28. 图像扭曲 - 知乎 2D射影儿何和变换——柱面投影，图像拼接柱面投影_yang6464158的专栏-CSDN博客 3d - Warp Image to Appear in Cylindrical Projection - Stack Overflow：有详细的原理推导和代码示例 css3动画的更深层次的探究（矩阵变换） - 简书 相关文档 Animating with Clip-Path | CSS-Tricks Flywheel logo javascript - SVG animate path’s d attribute - Stack Overflow html - How to animate clipping paths defined in SVG elements? - Stack Overflow 使用JavaScript修改CSS变量 - CSS（层叠样式表） | MDN CSSStyleSheet - Web API 接口参考 | MDN]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>动效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[clipboardData属性与DataTransfer对象]]></title>
    <url>%2Fpost%2Fclipboard-data-and-data-transfer%2F</url>
    <content type="text"><![CDATA[前言 clipboardData属性是ClipboardEvent事件对象的一个属性，其本质上就是一个DataTransfer对象；而ClipboardEvent事件则包括copy、cut和paste这三个原生事件。 通过将剪切板的数据按照DataTransfer对象的方式保存到clipboardData上，可以在相应的事件中来获取或者修改剪切板的数据。 常用方法 getData DOMString DataTransfer.getData(format); 该方法可以获取到剪切板中对应格式的数据，format参数就是指定数据的格式，其可选值有： text/plain：普通文本； text/uri-list：链接文本； text：等同于text/plain； url：等同于text/uri-list； If format equals “text”, change it to “text/plain”. If format equals “url”, change it to “text/uri-list”. [1] 如果没有对应的数据，则会返回一个空字符串。 DataTransferItem对象 可以看出getData()方法只能获取到文本类型的数据，但是有时候剪切板里面保存的数据可能是文件，比如复制一个图片的时候，要想从剪切板中获取图片内容就无法通过getData()方法了；这时候可以从DataTransfer.items属性入手，items属性是一个DataTransferItemList对象（一个伪数组对象），每个元素都是DataTransferItem对象。 该对象的属性有: type：拖拽项（或者剪切板中保存的数据项）的类型，为MIME值； kind：拖拽项的性质，可以是string或者file； 该对象的常用方法有： getAsFile()：尝试将拖拽项数据包装成一个File对象返回，不是文件就返回null（kind对应file）。 getAsString(callback)：接受一个回调函数，将拖拽项数据解析为字符串后将该字符串传递给回调函数（kind对应string）； 通过DataTransferItem对象的getAsFile()就可以方便地提取出剪切板中复制的图片等文件，而File对象既可以用于上传，也能转为base64字符串，处理图片就比较便捷了。 参考文档 拖拽献祭中的黑山羊-DataTransfer对象 « 张鑫旭-鑫空间-鑫生活 ClipboardEvent.clipboardData - Web API 接口参考 | MDN DataTransferItem.getAsString() - Web APIs | MDN DataTransferItem.getAsFile() - Web API 接口参考 | MDN DataTransferItem - Web API 接口参考 | MDN HTML 5.1 2nd Edition: 5. User interaction ↩︎]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>DOM</tag>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ESLint配置参数]]></title>
    <url>%2Fpost%2Feslint-config%2F</url>
    <content type="text"><![CDATA[前言 要将代码规范落实不仅是靠个人自觉的遵守，还得需要一个工具可以进行强制性地检测校验，这样就能真正地将规范落实到实处。而ESLint就是用来检测JS(X)/TS(X)代码的不二选择。 常用参数 extends 用来继承已有的ESLint配置，这个配置可以是内置的，也可以是npm插件；其值的格式有字符串和字符串数组两种； 字符串 当只是一个字符串时，这个字符串可以是： 配置文件路径； 共享配置名称（即npm插件）；当npm插件名称为eslint-config-*格式时，可以省略前面的eslint-config-前缀，如：eslint-config-airbnb可以直接写成airbnb； ESLint内置集成的配置；如：eslint:recommended，eslint:all； 字符串数组 数组形式，每个字符串都可以是上述格式；但是数组中后面的配置会覆盖前面的配置（当出现相同规则时）；如： 1234567&#123; extends: [ 'plugin:vue/strongly-recommended', '@vue/standard', '@vue/typescript/recommended' // ts检测 ]&#125; env env参数可以设置代码环境，启用一个环境，eslint就能够自动识别对应环境所有的全局变量；常用的环境有： browser：浏览器环境； node：Node.js环境； shared-node-browser：浏览器和Node.js通用的全局变量； es6：启用除了modules以外的所有ECMAScript 6特性； jquery：jQuery相关全局变量； worker：Web Worker环境； 除了上述的环境，eslint还支持很多比较常用的库作为环境（支持其全局变量），详情可以参考官方文档； env的设置方式很简单，其值为一个对象，当需要开启某个环境时，只需要将对应环境的值设置为true即可： 12345&#123; env: &#123; node: true &#125;&#125; parserOptions parserOptions是用来设置要支持检测的ES语法版本的；其设置值也是一个对象，包含三个选项（键）： ecmaVersion：用来设置支持的ECMAScript语言版本；可以是3，5，6这种经典版本号，也可以是用年份来设置版本号，如：2015（同6），2020（同11）；ES6及其之后的版本就可以使用对应的年份来设置版本号。默认值是5。 sourceType：具体作用细节还不清楚，网上找不到详细的资料；目前有两个选项，一个是script（脚本模式，默认值），另一个是module（ES模块）； ecmaFeatures：用于设置一些额外的语言特性，比如JSX等等； ecmaFeatures 目前支持的额外语言特性有4个： jsx：JSX语法； impliedStrict：全局strict模式； globalReturn：全局作用域使用return语句； experimentalObjectRestSpread：实验性功能，对象属性展开及剩余操作（目前该特性已经为stage-4了，ES2018）； 该属性设置方式同env一样，设置为true则开启，反之false则关闭； 12345678&#123; parserOptions: &#123; ecmaVersion: 2020, ecmaFeatures: &#123; jsx: false // 关闭对jsx的支持 &#125; &#125;&#125; parser 设置ESLint的解析器，解析器用来解析代码的语法树；其默认解析器为Espree，但是还有其他可以兼容的解析器（需要单独安装相应的npm包）： esprima babel-eslint：对babel的封装； @typescript-eslint/parser：支持对TS文件的解析； 好像也可以直接在parserOptions里面设置parser： 12345&#123; parserOptions: &#123; parser: '@typescript-eslint/parser' &#125;&#125; root 由于ESLint配置默认遵循层叠原则，即每级目录可以单独配置.eslintrc.*相关文件，如果该级目录没有文件则会向上一级查找直至根目录；不过如果设置root为true之后，项目中所有的检测文件不再会遵循层叠原则，而是统一以根目录中的配置文件为准来检测代码。 123&#123; root: true&#125; rules 除了继承已有的配置，还能手动修改通过rules属性来手动修改ESLint相关配置；每个检测规则都有其独特的键名，当要修改某条规则时，则使用键名然后设置相应的值即可；ESLint自带的规则表可以查看官方文档，使用其它ESLint插件则需要查看对应插件给出的规则； 每个规则都遵循一些简单的设置： 有些规则可能支持更详细的配置，比如数组，对象等等； 123456789101112131415161718&#123; rules: &#123; 'no-console': 'off', 'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off', 'generator-star-spacing': 'off', 'no-mixed-operators': 0, 'vue/max-attributes-per-line': [ 2, &#123; 'singleline': 5, 'multiline': &#123; 'max': 1, 'allowFirstLine': false &#125; &#125; ] &#125;&#125; overrides overrides可以匹配特定的文件，然后专门为其设置相应的ESLint配置（相当于一个优先级更高的配置文件）； files 通过这个参数可以来匹配特定的文件，其语法遵循glob匹配模式；值的形式为数组，数组中每个字符串代表一个匹配模式，如： 123456789101112131415161718192021&#123; overrides: [ &#123; files: [ '**/__tests__/*.&#123;j,t&#125;s?(x)', // 匹配jsx/tsx '**/tests/unit/**/*.spec.&#123;j,t&#125;s?(x)' // 匹配单元测试脚本 ], env: &#123; jest: true &#125; &#125;, &#123; files: [ '*.js' // 匹配所有的js文件 ], rules: &#123; '@typescript-eslint/no-var-requires': false // 关闭typescript-eslint对js文件检测require语句 &#125; &#125; ]&#125; 相关文档 Configuring ESLint - ESLint中文 Eslint 超简单入门教程 - 简书]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>ESLint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webGL常见光照模型]]></title>
    <url>%2Fpost%2Fwebgl-reflection-model%2F</url>
    <content type="text"><![CDATA[前言 当光照射到物体表面时,物体对光会发生反射、透射、吸收、衍射、折射、和干涉，其中被物体吸收的部分转化为热，反射、透射的光进入人的视觉系统，使我们能看见物体。为模拟这一现象，我们建立一些数学模型来替代复杂的物理模型，这些模型就称为明暗效应模型或者光照明模型。[1] 简言之，光照模型就是用来模拟真实世界中物体受到光线照射时的表现的计算模型； 冯氏光照模型（Phong reflection model） 冯氏光照模型由环境光、漫反射光及镜面反射光这三类光线组成； 环境光（Ambient Light）：用于模拟物体周围环境固有存在的光线；通常是阳光，月光这类光线对物体造成漫反射光，在物体间不停地反射，达到某种程度恒定的光线； 漫反射光（Diffuse Light）：用于模拟光线照射到粗糙表面形成的反射光； 镜面反射光（Specular Light）：用于模拟光线照射到光滑表面形成的亮点（即高光）； 环境光的计算 由于环境光模拟的是一类固定的光线，因此常使用环境光因子来计算； L环境=L光源∗K环境L_{环境} = L_{光源} * K_{环境} L环境​=L光源​∗K环境​ 注意：环境光因子的值在[0, 1]之间！ 漫反射的计算 漫反射的计算需要借助物体表面的法向量，通过光线的入射方向（L）及法向量（N）的点乘可以得到漫反射因子，然后根据漫反射因子来得到漫反射光； K漫反射=max(D光源⋅N, 0.0)L漫反射=L光源∗K漫反射K_{漫反射} = max(D_{光源} \cdot N,\ 0.0)\\ L_{漫反射} = L_{光源} * K_{漫反射} K漫反射​=max(D光源​⋅N, 0.0)L漫反射​=L光源​∗K漫反射​ 注意：当光线方向与法向量之间夹角大于90°时，点乘值必然小于0（此时相当于光线没有照射到该点）； 镜面反射光的计算 同理，镜面反射光也需要先计算出一个镜面反射因子；镜面反射因子是由人眼观察方向（V）和光线反射方向（R）之间的点乘得到； K镜面反射=max(V⋅R, 0.0)L镜面反射=L光源∗K镜面反射K_{镜面反射} = max(V \cdot R,\ 0.0)\\ L_{镜面反射} = L_{光源} * K_{镜面反射} K镜面反射​=max(V⋅R, 0.0)L镜面反射​=L光源​∗K镜面反射​ 除此之外，可以通过一个反光度（Shininess）的变量来控制高光区域的大小，反光度越大，则高光区域越小； K镜面反射=max((V⋅R)shininess, 0.0)K_{镜面反射} = max((V \cdot R)^{shininess},\ 0.0) K镜面反射​=max((V⋅R)shininess, 0.0) 注意：反光度的值一般为2的n次方，如：32, 64, 128, ...； 因此，环境光 + 漫反射光 + 镜面反射光即等于物体的反射光，最后将反射光乘以物体颜色即可得到物体最终进入人眼中的颜色值了（逐分量相乘）； L反射=L环境+L漫反射+L镜面反射Color反射=Color物体∗L反射L_{反射} = L_{环境} + L_{漫反射} + L_{镜面反射}\\ Color_{反射} = Color_{物体} * L_{反射} L反射​=L环境​+L漫反射​+L镜面反射​Color反射​=Color物体​∗L反射​ 这里有一个关于Phong光照模型的Demo：14. Phong specular reflect Blinn–Phong 光照模型 Blinn–Phong光照模型实际上是对于冯氏光照模型的一种改进，主要区别就在于镜面反射因子的计算； 改进后的镜面反射因子 在Blinn–Phong光照模型中，镜面反射因子是由光源方向（L）和观察方向（V）的半程向量（H）与法向量（N）之间的点积构成的； K镜面反射=max((H⋅N)shininess, 0.0)K_{镜面反射} = max((H \cdot N)^{shininess},\ 0.0) K镜面反射​=max((H⋅N)shininess, 0.0) 同样地，这里有一个关于Blinn–Phong光照模型的Demo：15. Blinn-Phong specular reflect 参考链接 Phong reflection model - Wikipedia Blinn–Phong reflection model - Wikipedia 光照基础 - LearnOpenGL-CN 什么是光照模型 - 知乎 ↩︎]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>计算机图形</tag>
        <tag>webGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webGL坐标系变换]]></title>
    <url>%2Fpost%2Fwebgl-coordinate-transformation%2F</url>
    <content type="text"><![CDATA[前言 由于webGL存在着几个不同的坐标系：模型坐标系、世界坐标系、相机坐标系和裁剪坐标系；因此将物体的同一坐标表示在不同的坐标系时，就需要对坐标进行转换，而根据不同坐标系之间的特性转换的具体参数可能有不同之处。 坐标系变换矩阵 将坐标从原坐标系变换到新坐标系中，有以下通用变换矩阵： (UxxUyxUzxOxUxyUyyUzyOyUxzUyzUzzOz0001)−1Ux→=(Uxx, Uxy, Uxz), x轴基向量Uy→=(Uyx, Uyy, Uyz), y轴基向量Uz→=(Uzx, Uzy, Uzz), z轴基向量O→=(Ox, Oy, Oz), 原点\begin{pmatrix} U_{xx} &amp; U_{yx} &amp; U_{zx} &amp; O_{x}\\ U_{xy} &amp; U_{yy} &amp; U_{zy} &amp; O_{y}\\ U_{xz} &amp; U_{yz} &amp; U_{zz} &amp; O_{z}\\ 0 &amp; 0 &amp; 0 &amp; 1 \end{pmatrix}^{-1} \\[2em] \begin{aligned} \overrightarrow{U_{x}} &amp;= (U_{xx},\ U_{xy},\ U_{xz}),\ \text{x轴基向量} \\ \overrightarrow{U_{y}} &amp;= (U_{yx},\ U_{yy},\ U_{yz}),\ \text{y轴基向量} \\ \overrightarrow{U_{z}} &amp;= (U_{zx},\ U_{zy},\ U_{zz}),\ \text{z轴基向量} \\ \overrightarrow{O} &amp;= (O_{x},\ O_{y},\ O_{z}),\ \text{原点} \end{aligned} ⎝⎜⎜⎛​Uxx​Uxy​Uxz​0​Uyx​Uyy​Uyz​0​Uzx​Uzy​Uzz​0​Ox​Oy​Oz​1​⎠⎟⎟⎞​−1Ux​​Uy​​Uz​​O​=(Uxx​, Uxy​, Uxz​), x轴基向量=(Uyx​, Uyy​, Uyz​), y轴基向量=(Uzx​, Uzy​, Uzz​), z轴基向量=(Ox​, Oy​, Oz​), 原点​ 其中，Ux→,Uy→,Uz→,O→\overrightarrow{U_{x}},\overrightarrow{U_{y}},\overrightarrow{U_{z}},\overrightarrow{O}Ux​​,Uy​​,Uz​​,O分别是新坐标系的基向量及原点在原坐标系中的表示。只需要将变换矩阵左乘一个列向量，即可得到该向量在新坐标系中的表示。 通过通用的坐标系变换矩阵可以推导出其它变换（平移、旋转、缩放等）的矩阵； 注：左乘是因为得到的变换矩阵是列主序的，为啥矩阵要列主序？因为glsl中的矩阵就是列主序的！ 思考：为啥矩阵要取逆矩阵？ 模型变换矩阵 模型变换指的是将坐标从模型坐标系转换到世界坐标系；一个模型内的所有顶点坐标都是相对于该模型的中心点（也就是模型坐标系的原点）而确定的，在实际应用中，一般都只能确定模型中心点在世界坐标系中的坐标，以及平移、旋转、缩放等操作，除此之外，一般模型的中心点的初始位置就是世界坐标系的原点位置(0, 0, 0)，所以模型变换矩阵可以简化为： M=T∗R∗ST:平移矩阵R:旋转矩阵S:缩放矩阵M = T * R * S \\[1em] \begin{aligned} T&amp;: \text{平移矩阵} \\ R&amp;: \text{旋转矩阵} \\ S&amp;: \text{缩放矩阵} \end{aligned} M=T∗R∗STRS​:平移矩阵:旋转矩阵:缩放矩阵​ 思考：为什么能够简化？ 注意顺序一定不能弄错，因为矩阵不满足交换律……那么为啥矩阵顺序必须是这样的？原因如下： 平移后会影响旋转，因此这里的旋转指的是是绕模型中心进行的旋转操作；所以平移要后于旋转进行。 同样，旋转后再进行缩放时，可能会造成缩放的效果不对（主要是旋转后x, y, z坐标发生改变，而缩放x, y, z系数不一致时，就可能对应不上）；因此缩放要先于旋转进行。 视图变换矩阵 视图变换指的是将坐标从世界坐标系转换到相机坐标系（也叫观察坐标系）；根据通用坐标系变换矩阵公式可知，只需要得到相机坐标系的原点及三个基向量在世界坐标系中的表示，即可得到视图变换矩阵。 需要注意的是相机坐标系是右手系！！！ 相机空间 VRP（View Reference Point）：观察参考点，也叫视点（eyepoint）；相机坐标系的原点。 VPN（View Plane Normal）：观察平面法向量，也叫观察/相机方向；相机坐标系的z轴。 VUV（View Up Vector）：相机顶部正朝向；相机坐标系的y轴大概方向。 推导过程 首先，相机坐标系原点（即人眼或相机位置）在世界坐标系中的位置是已知的；相机的关注点（lookat）的位置也是已知的；VUV也是已知的； 根据关注点和相机位置可以得到VPN（即相机坐标系的z轴基向量，N→\overrightarrow{N}N）； 根据VUV及VPN的叉乘可以得到相机坐标系的x轴基向量，U→\overrightarrow{U}U； 同理，根据N→\overrightarrow{N}N和U→\overrightarrow{U}U的叉乘可以得到真正的y轴基向量，V→\overrightarrow{V}V； 将U→\overrightarrow{U}U，V→\overrightarrow{V}V，N→\overrightarrow{N}N以及VRP的坐标代入到通用变换公式即可得到视图变换矩阵VVV： V=(uxvxnxOxuyvynyOyuzvznzOz0001)−1=(T∗R)−1=R−1∗T−1=(uxuyuz−U→⋅Ovxvyvz−V→⋅Onxnynz−N→⋅O0001)R=(uxvxnx0uyvyny0uzvznz00001)T=(100Ox010Oy001Oz0001)R−1=RT=(uxuyuz0vxvyvz0nxnynz00001)T−1=(100−Ox010−Oy001−Oz0001)\begin{aligned} V &amp;= \begin{pmatrix} u_{x} &amp; v_{x} &amp; n_{x} &amp; O_{x}\\ u_{y} &amp; v_{y} &amp; n_{y} &amp; O_{y}\\ u_{z} &amp; v_{z} &amp; n_{z} &amp; O_{z}\\ 0 &amp; 0 &amp; 0 &amp; 1 \end{pmatrix}^{-1} \\[2em] &amp;= (T * R)^{-1} \\ &amp;= R^{-1} * T^{-1} \\ &amp;= \begin{pmatrix} u_{x} &amp; u_{y} &amp; u_{z} &amp; -\overrightarrow{U}\cdot O\\ v_{x} &amp; v_{y} &amp; v_{z} &amp; -\overrightarrow{V}\cdot O\\ n_{x} &amp; n_{y} &amp; n_{z} &amp; -\overrightarrow{N}\cdot O\\ 0 &amp; 0 &amp; 0 &amp; 1 \end{pmatrix} \end{aligned} \\[2em] \begin{aligned} R &amp;= \begin{pmatrix} u_{x} &amp; v_{x} &amp; n_{x} &amp; 0\\ u_{y} &amp; v_{y} &amp; n_{y} &amp; 0\\ u_{z} &amp; v_{z} &amp; n_{z} &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1 \end{pmatrix} \\[2em] T &amp;= \begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; O_{x}\\ 0 &amp; 1 &amp; 0 &amp; O_{y}\\ 0 &amp; 0 &amp; 1 &amp; O_{z}\\ 0 &amp; 0 &amp; 0 &amp; 1 \end{pmatrix} \\[2em] R^{-1} = R^T &amp;= \begin{pmatrix} u_{x} &amp; u_{y} &amp; u_{z} &amp; 0\\ v_{x} &amp; v_{y} &amp; v_{z} &amp; 0\\ n_{x} &amp; n_{y} &amp; n_{z} &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1 \end{pmatrix} \\[2em] T^{-1} &amp;= \begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; -O_{x}\\ 0 &amp; 1 &amp; 0 &amp; -O_{y}\\ 0 &amp; 0 &amp; 1 &amp; -O_{z}\\ 0 &amp; 0 &amp; 0 &amp; 1 \end{pmatrix} \end{aligned} V​=⎝⎜⎜⎛​ux​uy​uz​0​vx​vy​vz​0​nx​ny​nz​0​Ox​Oy​Oz​1​⎠⎟⎟⎞​−1=(T∗R)−1=R−1∗T−1=⎝⎜⎜⎜⎛​ux​vx​nx​0​uy​vy​ny​0​uz​vz​nz​0​−U⋅O−V⋅O−N⋅O1​⎠⎟⎟⎟⎞​​RTR−1=RTT−1​=⎝⎜⎜⎛​ux​uy​uz​0​vx​vy​vz​0​nx​ny​nz​0​0001​⎠⎟⎟⎞​=⎝⎜⎜⎛​1000​0100​0010​Ox​Oy​Oz​1​⎠⎟⎟⎞​=⎝⎜⎜⎛​ux​vx​nx​0​uy​vy​ny​0​uz​vz​nz​0​0001​⎠⎟⎟⎞​=⎝⎜⎜⎛​1000​0100​0010​−Ox​−Oy​−Oz​1​⎠⎟⎟⎞​​ 注：当一个矩阵为正交矩阵时（即行向量和列向量两两正交），其转置矩阵等于其逆矩阵[1]！ 投影变换矩阵 投影变换指的是将坐标从相机坐标系转换到裁剪坐标系，最终投影变换将得到顶点投影后的标准化设备坐标（Normalized Device Coordinate, NDC），可以输入到顶点着色器中进行使用。 所谓的标准化设备坐标指的是x, y , z坐标值的范围都在[-1, 1]之间。 投影变换跟前面的坐标系之间的变换方法有些不同，裁剪坐标系并不是指定一个坐标原点和三个基向量而形成的，而是通过一些观察参数得到的平截头体（Frustum，一个空间范围）形成的，这个空间范围除了跟观察参数有关以外还和投影方式有关！ 相关概念 实际上在设定观察参数时，用到的参考坐标系仍然是相机坐标系，也就是相当于平截头体是相机空间的子空间，只不过变换后坐标进行了转换。 投影点：相机坐标系的原点。 近平面：通过设置近平面距离DnearD_{near}Dnear​可得，所以近平面指的是相机坐标系z=−Dnearz = -D_{near}z=−Dnear​平面。 远平面：同理，设置一个远平面距离DfarD_{far}Dfar​可得，近平面指的是相机坐标系z=−Dfarz = -D_{far}z=−Dfar​平面。 平截头体的宽高：指的是平截头体在近平面一端上的矩形宽高（远平面一端矩形的宽高可以根据参数推算）。 正交投影 正交投影是平行投影的一种，其投影线是垂直于投影平面（这里的投影平面值的就是近平面）的。因此可以得到正交投影的平截头体为一个长方体： 注：正交投影平截头体的宽高一般是通过设置xleftx_{left}xleft​、xrightx_{right}xright​、ytopy_{top}ytop​和ybottomy_{bottom}ybottom​得到的。 由于投影平面垂直于相机坐标系的z轴，因此相机坐标系内的一点在投影平面的xyz坐标只需要对原坐标做一个范围缩放处理即可： x′=x−xleftxright−xleft∗2−1=2∗(x−xleft)−xright+xleftxright−xleft=2x−(xleft+xright)xright−xleft=2xxright−xleft−xleft+xrightxright−xleft\begin{aligned} x&#x27; &amp;= \frac{x - x_{left}}{x_{right} - x_{left}} * 2 - 1 \\ &amp;= \frac{2 * (x - x_{left}) - x_{right} + x_{left}}{x_{right} - x_{left}} \\ &amp;= \frac{2x - (x_{left} + x_{right})}{x_{right} - x_{left}} \\ &amp;= \frac{2x}{x_{right} - x_{left}} - \frac{x_{left} + x_{right}}{x_{right} - x_{left}} \end{aligned} x′​=xright​−xleft​x−xleft​​∗2−1=xright​−xleft​2∗(x−xleft​)−xright​+xleft​​=xright​−xleft​2x−(xleft​+xright​)​=xright​−xleft​2x​−xright​−xleft​xleft​+xright​​​ 从上面x坐标的变换可以看到，这种变换实际上就是[xleft,xright][x_{left}, x_{right}][xleft​,xright​]到[−1,1][-1, 1][−1,1]的变换。同理，y坐标就是[ybottom,ytop]→[−1,1][y_{bottom}, y_{top}]\rightarrow[-1, 1][ybottom​,ytop​]→[−1,1]；而z坐标则是[zfar,znear]→[−1,1][z_{far}, z_{near}] \rightarrow [-1, 1][zfar​,znear​]→[−1,1]。 y′=2yytop−ybottom−ybottom+ytopytop−ybottomz′=2zznear−zfar−zfar+znearznear−zfar\begin{aligned} y&#x27; &amp;= \frac{2y}{y_{top} - y_{bottom}} - \frac{y_{bottom} + y_{top}}{y_{top} - y_{bottom}} \\ z&#x27; &amp;= \frac{2z}{z_{near} - z_{far}} - \frac{z_{far} + z_{near}}{z_{near} - z_{far}} \end{aligned} y′z′​=ytop​−ybottom​2y​−ytop​−ybottom​ybottom​+ytop​​=znear​−zfar​2z​−znear​−zfar​zfar​+znear​​​ 注：由于相机坐标系是右手系，因此znear&gt;zfarz_{near} &gt; z_{far}znear​&gt;zfar​！ 从投影变换结果(x′,y′,z′)(x&#x27;, y&#x27;, z&#x27;)(x′,y′,z′)可以得到正交投影的投影变换矩阵： P正交=(2xright−xleft00−xleft+xrightxright−xleft02ytop−ybottom0−ybottom+ytopytop−ybottom002znear−zfar−zfar+znearznear−zfar0001)P_{正交} = \begin{pmatrix} \large \frac{2}{\large x_{right} - x_{left}} &amp; 0 &amp; 0 &amp; - \large \frac{\large x_{left} + x_{right}}{\large x_{right} - x_{left}} \\[1em] 0 &amp; \large \frac{2}{\large y_{top} - y_{bottom}} &amp; 0 &amp; - \large \frac{\large y_{bottom} + y_{top}}{\large y_{top} - y_{bottom}} \\[1em] 0 &amp; 0 &amp; \large \frac{2}{\large z_{near} - z_{far}} &amp; -\large \frac{\large z_{far} + z_{near}}{\large z_{near} - z_{far}} \\[1em] 0 &amp; 0 &amp; 0 &amp; 1 \end{pmatrix} P正交​=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​xright​−xleft​2​000​0ytop​−ybottom​2​00​00znear​−zfar​2​0​−xright​−xleft​xleft​+xright​​−ytop​−ybottom​ybottom​+ytop​​−znear​−zfar​zfar​+znear​​1​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​ 透视投影 投射投影则是模拟真实世界中看见物体的模式进行的投影，具有立体效果。其平截头体如下所示： 可以看到点和投影点有一组三角相似关系： 进而根据三角相似原理可以得到一组等式： x′x=y′y=znearz⇒{x′=znear∗xzy′=znear∗yzz′=znear\frac{x&#x27;}{x} = \frac{y&#x27;}{y} = \frac{z_{near}}{z} \\[1em] \Rightarrow \large\begin{cases} x&#x27; &amp;= \frac{z_{near} * x}{z} \\[1em] y&#x27; &amp;= \frac{z_{near} * y}{z} \\[1em] z&#x27; &amp;= z_{near} \end{cases} xx′​=yy′​=zznear​​⇒⎩⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎧​x′y′z′​=zznear​∗x​=zznear​∗y​=znear​​ 需要注意的是，这里的x′x&#x27;x′和y′y&#x27;y′并不是最终我们想要的标准化设备坐标，而是在近平面的投影坐标，实际上还是处于相机坐标系中；因此还需要进行一下范围变换： x′′=x′−xleftxright−xleft∗2−1=x′−(−width/2)width∗2−1=2x′width=znear∗2xz∗widthy′′=znear∗2yz∗height\begin{aligned} x&#x27;&#x27; &amp;= \frac{x&#x27; - x_{left}}{x_{right} - x_{left}} * 2 - 1 \\ &amp;= \frac{x&#x27; - (-width / 2)}{width} * 2 - 1 \\ &amp;= \frac{2x&#x27;}{width} \\[2em] &amp;= \frac{z_{near} * 2x}{z * width} \\[2em] y&#x27;&#x27;&amp;= \frac{z_{near} * 2y}{z * height} \end{aligned} x′′y′′​=xright​−xleft​x′−xleft​​∗2−1=widthx′−(−width/2)​∗2−1=width2x′​=z∗widthznear​∗2x​=z∗heightznear​∗2y​​ 不过由于投影坐标系是左手系的，因此z轴方向与相机坐标系刚好相反，需要取负值；其次，由于www分量为zzz，所以各分量需要先乘以zzz： x′′=−znear∗2xwidthy′′=−znear∗2yheight\begin{aligned} x&#x27;&#x27; &amp;= - \frac{z_{near} * 2x}{width} \\[2em] y&#x27;&#x27;&amp;= - \frac{z_{near} * 2y}{height} \end{aligned} x′′y′′​=−widthznear​∗2x​=−heightznear​∗2y​​ 由于投影到平面的点是2D的（因为投影后所有点的zzz都相同），不过由于深度测试需要用到zzz值来判断点在空间中前后顺序，因此需要对原有的zzz坐标进行线性插值得到一个符合标准化设备坐标系的坐标值；不过，由于齐次坐标的www分量为zzz，因此实际上应该对1z\large\frac{1}{\large z}z1​进行插值[2]： 思考：我在想如果使w=1w=1w=1，那么是不是可以用普通的一次线性函数插值？还有就是为啥一定要利用www的特性来除以x,y,zx, y, zx,y,z坐标，而不是直接让其为目标值？这样看起来有点多此一举…… 事实上，使用普通一次线性函数z′′=az+bz&#x27;&#x27; = az + bz′′=az+b得到的参数似乎对不上公认的那个透视投影矩阵。 z′′=a⋅1z+bz&#x27;&#x27; = a\cdot\frac{1}{\large z} + b z′′=a⋅z1​+b 同时，在近平面z′′=−1z&#x27;&#x27; = -1z′′=−1和远平面z′′=1z&#x27;&#x27; = 1z′′=1处有确定的投影关系： {a∗1znear+b=−1a∗1zfar+b=1⇒{a=2∗znear∗zfarznear−zfarb=−znear+zfarznear−zfar\begin{cases} a * \large\frac{1}{\large z_{near}} + b &amp;= -1 \\[1em] a * \large\frac{1}{\large z_{far}} + b &amp;= 1 \end{cases} \\[1em] \Rightarrow \begin{cases} a &amp;= \large \frac{\large 2 * z_{near} * z_{far}}{\large z_{near} - z_{far}} \\[1em] b &amp;= - \large \frac{\large {\large z_{near} + z_{far}}}{\large z_{near} - z_{far}} \end{cases} \\ ⎩⎪⎨⎪⎧​a∗znear​1​+ba∗zfar​1​+b​=−1=1​⇒⎩⎪⎪⎨⎪⎪⎧​ab​=znear​−zfar​2∗znear​∗zfar​​=−znear​−zfar​znear​+zfar​​​ 经过这么多步转换后，可以得到透视投影矩阵为： P透视=(2∗znearwidth00002∗znearheight0000znear+zfarznear−zfar2∗znear∗zfarznear−zfar00−10)P_{透视} = \begin{pmatrix} \large \frac{2 * \large z_{near}}{width} &amp; 0 &amp; 0 &amp; 0 \\[1em] 0 &amp; \large \frac{2 * \large z_{near}}{height} &amp; 0 &amp; 0 \\[1em] 0 &amp; 0 &amp; \large \frac{\large {\large z_{near} + z_{far}}}{\large z_{near} - z_{far}} &amp; \large \frac{2 * \large z_{near} * z_{far}}{\large z_{near} - z_{far}} \\[1em] 0 &amp; 0 &amp; -1 &amp; 0 \end{pmatrix} P透视​=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎛​width2∗znear​​000​0height2∗znear​​00​00znear​−zfar​znear​+zfar​​−1​00znear​−zfar​2∗znear​∗zfar​​0​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎞​ 不过上述参数只是从数学上假设的，实际应用中计算透视投影矩阵时通常使用视场角（fovy）、宽高比（aspect）、近平面和远平面这四个值来计算透视投影矩阵： 很明显，通过视场角、近平面和宽高比能够算出近平面的宽高； {tan(fovy/2)=0.5∗heightznearaspect=widthheight记 θ=fovy/2⇒P透视=(cot(θ)aspect0000cot(θ)0000znear+zfarznear−zfar2∗znear∗zfarznear−zfar00−10)\begin{cases} tan(fovy / 2) &amp;= \large \frac{\large 0.5 * height}{\large z_{near}} \\[1em] aspect &amp;= \large \frac{\large width}{\large height} \end{cases} \\[1em] \text{记 }\theta = fovy / 2 \\[1em] \Rightarrow P_{透视} = \begin{pmatrix} \large \frac{cot(\theta)}{aspect} &amp; 0 &amp; 0 &amp; 0 \\[1em] 0 &amp; cot(\theta) &amp; 0 &amp; 0 \\[1em] 0 &amp; 0 &amp; \large \frac{\large {\large z_{near} + z_{far}}}{\large z_{near} - z_{far}} &amp; \large \frac{2 * \large z_{near} * z_{far}}{\large z_{near} - z_{far}} \\[1em] 0 &amp; 0 &amp; -1 &amp; 0 \end{pmatrix} ⎩⎪⎪⎨⎪⎪⎧​tan(fovy/2)aspect​=znear​0.5∗height​=heightwidth​​记 θ=fovy/2⇒P透视​=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎛​aspectcot(θ)​000​0cot(θ)00​00znear​−zfar​znear​+zfar​​−1​00znear​−zfar​2∗znear​∗zfar​​0​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎞​ 相关文档 WebGL 入门与实践：18 - lucefer - 掘金小册 视图矩阵的推导-云栖社区-阿里云 三维投影 - 维基百科，自由的百科全书 坐标系统 - LearnOpenGL-CN 线性代数之透视矩阵Perspective Matrix – Wyman的原创技术博客 正交矩阵 - 维基百科，自由的百科全书 ↩︎ 透视投影详解 - 翰墨小生 - 博客园 ↩︎]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>GLSL</tag>
        <tag>计算机图形</tag>
        <tag>webGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[形状与图案]]></title>
    <url>%2Fpost%2Fshape-and-pattern%2F</url>
    <content type="text"><![CDATA[常见形状 矩形 如图，若要画出上述矩形；正常思路就是扣去y&gt;ay &gt; ay&gt;a，y&lt;by &lt; by&lt;b，x&lt;cx &lt; cx&lt;c及x&gt;dx &gt; dx&gt;d的所有像素点，剩下的像素点就是我们想要的矩形区域； 具体到GLSL中，可以使用step()函数来进行扣去像素点的操作；如： 1step(b, y); 就代表y&lt;by &lt; by&lt;b的像素点会返回000；那么y&gt;ay &gt; ay&gt;a呢？如下： 11.0 - step(a, y); 综上，利用step()抠出一个矩形区域的做法为： 1step(b, y) - step(a, y) - step(d, x) - (1.0 - step(c, x)); 当然，这样得到矩形区域的边缘会出现很明显的锯齿，可以使用smoothstep()函数来替代step()函数，得到一个比较平滑的边缘。 圆形 圆形区域就比较容易获取了，只需要计算像素点到圆心的距离就可以确定是不是在区域内了； 11.0 - step(r, length(pos - center)); 正多边形 画出任意边数的正多边形可以根据一个距离场函数来进行；这个距离场函数实际上就是利用极坐标来进行计算的； 根据正多边形的内切圆或外接圆，将角度均分为相应的份数，在每份角度周期内圆心到边上的距离呈相同的规律变化。 如上图所示，以『正三角形』为例；在正三角形内得到一个内切圆，从圆心到顶点的边可以将内切圆均分为3份（即120°120\degree120°）。以0号边为起点，1号边为终点，对应内切圆的[0, 120°][0,\ 120\degree][0, 120°]，将该区间转化为[−60°, 60°][-60\degree,\ 60\degree][−60°, 60°]，很自然地得到该段三角形边的极坐标方程为： r=ρ⋅cosα⇒ρ=rcosαr = \rho \cdot cos\alpha \\ \Rightarrow \rho = \frac{r}{cos\alpha} r=ρ⋅cosα⇒ρ=cosαr​ 而对应到整个正三角形，关键就在于边上的点的角度到底位于[−60°, 60°][-60\degree,\ 60\degree][−60°, 60°]区间的哪个位置。显然，只需要对角度取余即可。同理，该极坐标方程可以推广到任何正多边形；除此之外，也可以利用正多边形的外接圆来确定极坐标方程，精髓就在于确定一个周期内不变的三角函数关系即可！ 上述极坐标方程只是确定了正多边形边上的点，若要得到一个正多边形区域，只需要满足到内切圆圆心的距离小于ρ\rhoρ即可。 GLSL中的实现 1234567891011// 根据内切圆法得到正多边形的极坐标方程float polygon (float n, float r, vec2 p) &#123; float per = TWO_PI / n; // 均分一圈得到的弧度 float x = p.x; float y = p.y; float radius = length(vec2(x, y)); // 该点距离圆心的距离 float angle = atan(y, x); // 该点相对于圆心的角度 float delta = angle - floor(angle / per + 0.5) * per; // 该点处于[-per/2, per/2]区间的位置 return 1.0 - smoothstep(r, r * 1.01, radius * cos(delta)); // 判断 r = ρ * cosα&#125; 上述方法可以画出一个正多边形区域，且对区域边缘部分进行了光滑处理；ppp参数可以看做内切圆心（即多边形中心位置）到正多边形边上的向量，而rrr参数则是内切圆的半径，稍微处理一下就可以当做多边形的边长。 关于使用内切圆来绘制正多边形，可以查看这个demo：32. Polygon。 极坐标 ρ=ρ(θ)\rho = \rho(\theta) ρ=ρ(θ) ρ\rhoρ就是当前点距离中心点的长度；而θ\thetaθ则是当前点相对于中心点的角度（弧度）；只要图形边缘满足上述特点即可使用极坐标进行绘制，如最常见的圆形，可以使用如下极坐标方程： ρ=a\rho = a ρ=a aaa是任意常数； 可以通过以下方式来计算某点的ρ\rhoρ和θ\thetaθ： 123vec2 pos = p - center; // p是当前坐标点，center为图形中心点坐标float len = length(); // 计算长度float angle = atan(pos.y, pos.x); // 计算角度 组合图形 叠加 扣除 图案（patterns） 广义指对某种器物的造型结构、色彩、纹饰进行工艺处理而事先设计的施工方案，制成图样，通称图案。有的器物（如某些木器家具等）除了造型结构，别无装饰纹样，亦属图案范畴（或称立体图案）。狭义则指器物上的装饰纹样和色彩而言。 —— https://baike.baidu.com/item/图案/52183 几何图案 网格 通过将屏幕从水平和垂直方向分成一个n∗mn*mn∗m的网格，其中每个网格单元可以进行图形的独立绘制，得到一个重复排列的图案； 假设最初得到的屏幕坐标为标准设备坐标（即坐标范围为[−1, 1][-1, \ 1][−1, 1]），可以通过fract()方法来进行网格单元的切割： 123vec2 num = vec2(n, m); // 水平及竖直方向单元的个数pos *= num; // 放大坐标pos = fract(pos); // 得到网格中的独立坐标 通过上述方法可以将坐标分成n * m个网格，其中每个网格内的坐标都是[0, 1][0, \ 1][0, 1]之间；然后对每个单元格进行相同的图形绘制，就可以得到重复填充的图案。可以查看这个根据网格进行重复填充的demo：35. Pattern Test 不仅如此，还可以进一步获取每个单元格位于水平和竖直方向上的索引，然后进行偏移或其它操作，得到更加丰富的填充效果； 参考文档 The Book of Shaders: Patterns]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>GLSL</tag>
        <tag>计算机图形</tag>
        <tag>webGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON对象与Blob对象互相转换]]></title>
    <url>%2Fpost%2Fjson-and-blob%2F</url>
    <content type="text"><![CDATA[前言 在某些后台业务场景下，可能需要导出或导入一些数据；而这个数据的介质就是json文件。从服务端获取到的json数据可以转为json文件并下载，而从用户导入的json文件又可以转换为json数据（对象）提交给服务端。 转换步骤 核心 无论是json数据转.json文件，还是.json文件转json数据，都离不开Blob对象的支持。 .json文件转为json数据（对象） 根据上传组件获取到对应的File对象； 将File对象转为Blob对象； 利用FileReader的readAsText方法读取json数据； FileReader的onload方法会在解析成功时执行；此时该实例的result属性就是解析好的json字符串，进一步用JSON.parse()方法就能解析出json对象。 可以将上述步骤封装成一个函数： 123456789101112131415161718/** * 将file对象（.json文件）转为json对象 * @param &#123;File&#125; file file对象 */function fileToJson (file) &#123; return new Promise((resolve, reject) =&gt; &#123; const reader = new FileReader() reader.onload = res =&gt; &#123; const &#123; result &#125; = res.target // 得到字符串 const data = JSON.parse(result) // 解析成json对象 resolve(data) &#125; // 成功回调 reader.onerror = err =&gt; &#123; reject(err) &#125; // 失败回调 reader.readAsText(new Blob([file]), 'utf-8') // 按照utf-8编码解析 &#125;)&#125; json数据（对象）转为Blob对象 由于Blob构造函数本身就支持将字符串转为文件，因此转换比较简单： 首先利用JSON.stringify()方法将json对象转为json字符串； 利用Blob构造函数得到Blob对象（注意：需要设置文件的MIME类型）； 如： 123const blob = new Blob([JSON.stringify(data)], &#123; type: 'application/json'&#125;) 扩展：将Blob对象直接下载到本地 上面将json数据转换为Blob对象后，作用并不大；一个后续的使用场景可能为：将这个文件通过浏览器下载到本地。这个就需要用到createObjectURL()方法和&lt;a&gt;标签的download特性了。 URL.createObjectURL(blob/file)：该方法可以得到一个指向Blob对象或File对象对应的二进制文件流的url地址，访问即可下载该文件； download属性：当&lt;a&gt;标签设置了该属性时，点击标签时浏览器不会跳转链接，而是将对应链接作为文件进行下载保存，而文件的名字就是download的属性值。 可以将上述流程封装成一个将json对象转化成文件并自动下载的函数： 1234567891011121314/** * 利用a标签的download属性和blob转url，将json字符串转为json文件进行下载 * @param &#123;*&#125; data json对象 */function downloadJson (data) &#123; const download = document.createElement('a') // 匿名a标签 const blob = new Blob([JSON.stringify(data)], &#123; type: 'application/json' &#125;) const url = URL.createObjectURL(blob) // blob转url download.href = url download.download = 'filename.json' // 文件名 download.click() // 触发下载&#125; 相关文档 URL.createObjectURL() - Web API 接口参考 | MDN &lt;a&gt; - HTML（超文本标记语言） | MDN 了解HTML/HTML5中的download属性 « 张鑫旭-鑫空间-鑫生活]]></content>
      <categories>
        <category>业务</category>
      </categories>
      <tags>
        <tag>H5</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS浮点数及精度问题]]></title>
    <url>%2Fpost%2Fjs-float%2F</url>
    <content type="text"><![CDATA[前言 总所周知，在JS中进行某些浮点数的计算时会得到意想不到的结果，诸如0.1 + 0.2和1 - 0.9这种，得到的结果都不是我们预期的那样；这种现象实际上是由于浮点数存储时精度丢失时所导致的，但这并不是JS独有的锅，而是采用IEEE 754标准存储浮点数都会有的问题； 关于 IEEE 754 标准 IEEE 754规定了四种表示浮点数值的方式：单精确度（32位元）、双精确度（64位元）、延伸单精确度（43位元以上，很少使用）与延伸双精确度（79位元以上，通常以80位元实做）。[1] 在JS中采用的是IEEE 754中双精度（64位）格式来存储浮点数，即每个数字类型的变量存储大小为64位；而这64位存储空间按照功能分成了3个部分[2]： 符号位（sign bit）：包含1位，用来表示数值的符号；0表示为正，1表示为负；记为S。 指数位（exponent）：包含11位，用来表示二进制科学计数法中的指数；记为E。 尾数位（mantissa）：包含52位，用来表示二进制科学计数法的有效数字中的小数部分；记为M。 因此，可以得出浮点数在双精度存储的二进制数值为： V=(−1)S∗2E−1023∗(M+1)V = (-1)^{S}*2^{E - 1023}*(M + 1) V=(−1)S∗2E−1023∗(M+1) 不过，看到这个公式可能心里会有疑问；二进制科学记数法是啥？为啥指数部分要减去1023？为啥有效数字中的整数部分不进行存储？ 关于二进制科学记数法 可以联想一下我们熟知的十进制科学计数法： N=N有效数字∗10EN = N_{有效数字}*10^{E} N=N有效数字​∗10E 所谓的有效数字就是介于[1,10)[1, 10)[1,10)这个区间的数字（当然有可能带负号），而这个指数实际上可以看做是小数点的移动： 当为正数时，小数点从有效数字往右移动相应的位数即可得到真实的数值； 同理，当指数位负数时，小数点从有效数字往左移相应的位数即可得到真实的数值； 按照这个原理，二进制科学记数法的指数也是用来移动有效数字小数点位置的，只不过这时有效数字用的是二进制来表示的。 为何只记录有效数字中的小数部分？ 联系上面提到的二进制科学计数法，可以得到二进制的有效数字位于[1,2)[1, 2)[1,2)这个区间内，所以很明显这个区间内有效数字部分的整数始终为1！既然为常量，也不需要再进行存储了，这也是为何尾数M加上1的原因，目的就是补充有效数字的整数部分。 指数部分为何减去1023？ 答案就是因为指数也有负数，而指数部分最大值为211−12^{11} - 1211−1（即2047），因此取一个中间数1023，使得[0,2047][0, 2047][0,2047]区间的数正负对半（大致对半，实际上区间变成了[−1023,1024][-1023, 1024][−1023,1024]）。 思考：为何不像sign bit那样指定一个指数符号位？试想一下，如果把指数部分第一位变成表示符号的位，那么剩余位数只有10位了，因此能表达的区间就是[−(210−1),210−1)][-(2^{10} - 1), 2^{10} - 1)][−(210−1),210−1)]，即[−1023,1023][-1023, 1023][−1023,1023]。 小数部分二进制的转换 整数部分十进制转其它进制的套路都很熟了，也就是辗转相除法；但是小数部分的转换好像有点陌生，不过大概的套路和辗转相除法有点相似，只不过变成了乘法； 将小数部分乘2，得到的数值其整数部分作为当前位进行存储； 将上述得到的数值小数部分重复1步骤，直到小数部分为0； 和整数部分进制转换相比，小数部分的进制转换是从高位到低位，因为小数部分的指数都是负数。下面是在js中进行小数部分二进制的转换： 12345678910111213141516171819202122/** * 将浮点数的小数部分转为二进制小数表示 * @param &#123;number&#125; f 浮点数 * @param &#123;number&#125; maxLength 小数最大长度 */function decimalToBinary (f, maxLength = 57) &#123; let res = '0.' let cur = 0 // 小数位 let decimal = f &gt; 1 ? f - Math.floor(f) : f // 当前位对应的小数 while (cur &lt; maxLength &amp;&amp; decimal !== 0) &#123; cur++ let n = decimal * 2 let intNum = Math.floor(n) // 取整数部分 decimal = n - intNum // 去小数部分 res += intNum // 将整数位补充到对应位上 &#125; return res&#125;console.log(decimalToBinary(0.1)) // 0.0001100110011001100110011001100110011001100110011001101 事实上可以利用Number.prototype.toString()方法转化二进制浮点数，因为该方法接受一个参数用来表示要转换的进制（默认进制就是10）；如： 1console.log(Number(0.1).toString(2)) // 0.0001100110011001100110011001100110011001100110011001101 经实践，通过toString转化的浮点数最大位数为57位。 如何将二进制小数转为十进制小数 这个方法跟整数部分的转换是一致的，只不过小数位的指数变成了负数； D=∑i=1nki∗2−i, (ki为第i位小数)D = \displaystyle\sum_{i=1}^{n}k_i * 2^{-i},\ (k_i\text{为第i位小数}) D=i=1∑n​ki​∗2−i, (ki​为第i位小数) 精度丢失产生的原因 综上，由于双精度浮点数的尾数部分只有52位；因此，当浮点数的实际尾数超出52位时，就会进行截取，也就是第52位之后的尾数都会被舍去，且如果取到的尾数的最后一位是1时，还要进行进位（类似十进制的四舍五入）。 由于上面的原因，可能导致某些浮点数在存储时发生了偏差，然后还原成十进制后数字也就自然不符合预期了。 分析 0.1 + 0.2 的结果 0.1的双精度存储二进制表示[3]如下： 1200111111 10111001 10011001 1001100110011001 10011001 10011001 10011010 0.2的双精度存储二进制表示如下： 1200111111 11001001 10011001 1001100110011001 10011001 10011001 10011010 可以根据获得的二进制存储信息来还原浮点数： 1234567891011121314151617181920212223242526272829/** * 根据双精度浮点数存储信息还原出原浮点数（十进制表示） * @param &#123;*&#125; info 双精度浮点数存储信息 */function getFloat (info) &#123; let e = info.e.toString(10) - 1023 // 计算指数 let res = Math.pow(2, e) * (info.i !== undefined ? info.i : 1) // 有效数字的整数部分始终为1 info.m.split('').forEach((item ,idx) =&gt; &#123; res += Number(item) * Math.pow(2, -idx - 1 + e) // 计算尾数部分 &#125;) return info.s === 0 ? res : -res // 判断符号&#125;let n1 = &#123; s: 0, e: 0b01111111011, m: '1001100110011001100110011001100110011001100110011010'&#125; // 0.1的表示let n2 = &#123; s: 0, e: 0b01111111100, m: '1001100110011001100110011001100110011001100110011010'&#125; // 0.2的表示console.log(getFloat(n1)) // 0.1console.log(getFloat(n2)) // 0.2 可以看出从0.1和0.2存储的二进制数据还原得到的结果是正确的，并没有精度丢失，但是为何相加之后得到的结果却不是0.3呢？ 由于0.1和0.2的尾数和符号都是相同的，不同的地方在指数部分（0.2的指数比0.1指数大1），但是二进制数相加时，要保证指数相同；因此先将0.1小数点左移一位得到： 123456789let n3 = &#123; s: 0, e: 0b01111111100, i: 0, // 有效数字整数部分，仅作演示，实际只能是1 // 由于小数点左移一位，原本的有效数整数部分1变成了尾数部分的第一位，尾数其他位的也依次右移一位 m: '1100110011001100110011001100110011001100110011001101'&#125; // 0.1的另一种表示console.log(getFloat(n3)) // 0.1 然后尾数部分进行相加，得到新的尾数： 110110011001100110011001100110011001100110011001100111 由于新的尾数超出了52位（53位），需要进1位： 121 + 1.0110011001100110011001100110011001100110011001100111 =10.0110011001100110011001100110011001100110011001100111 因此，最终0.1 + 0.2得到的二进制结果就是： 12345let n4 = &#123; s: 0, e: 0b01111111101, // 指数加了1 m: '00110011001100110011001100110011001100110011001100111' // 尾数右移了，因此多了一位&#125; 然而由于尾数部分超出了52位，因此只能截留52位，又因为截留的最后一位是1，因此要进1位，最终该结果的浮点数二进制表示为： 1234567let n4 = &#123; s: 0, e: 0b01111111101, m: '0011001100110011001100110011001100110011001100110100'&#125; // 0.1 + 0.2 的二进制表示console.log(getFloat(n4)) // 0.30000000000000004 所以，0.1 + 0.2最终得到的结果却是0.30000000000000004就是这么回事。 扩展：如何修复精度丢失导致的计算问题？ JS基础测试47期 · Issue #74 · zhangxinxu/quiz 相关文档 JavaScript 浮点数陷阱及解法 · Issue #9 · camsong/blog js浮点数存储精度丢失原理 - 掘金 Number.prototype.toString() - JavaScript | MDN IEEE 754 - 维基百科，自由的百科全书 ↩︎ 双精度浮点数 - 维基百科，自由的百科全书 ↩︎ Double (IEEE754 Double precision 64-bit)：双精度浮点数存储计算可视化 ↩︎]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo增加数学公式的支持]]></title>
    <url>%2Fpost%2Fhexo-math-latex%2F</url>
    <content type="text"><![CDATA[前言 由于写markdown文章很多地方都需要用到latex语法展示数学公式，有道云笔记本身就支持（解析器为katex），但是hexo默认是不支持的，因此会导致有道云笔记markdown导出到hexo博客时，数学公式就是一堆普通字符串。 不过好在已经有人造出了在hexo中支持数学公式的轮子，废话不多说，直接上方法； 使用NexT主题时 由于NexT主题本身就带有支持解析数学公式的配置，直接按照相关文档配置即可，十分方便！ 不过有些地方需要注意： 由于主题可能一直在更新，导致github上面的文档中具体的配置与我们自己用的版本不太一致；直接升级有可能会遇到其它意想不到的问题，所以最好直接查看本地项目中next/docs/zh-CN/MATH.md文件即可，这里面的配置跟我们使用的主题版本是一致的。 同上，KaTex的版本也一直在更新，最好将相应的CDN地址替换成最新版本的，以免采坑。 使用hexo-math插件 当时最初在网上找到的方法就是建议采用hexo-math插件来支持数学公式，而且这个插件是hexo官方维护的；然而，根据其官方文档的步骤来配置，你会发现数学公式压根不会解析！！！原因就在于它压根就没提需要更换markdown渲染引擎的事情…… 这是个巨坑，可能会浪费很多时间；对应的渲染引擎跟NexT配置提到的一样，需要根据使用MathJax还是KaTex来分别选择。 相关文档 hexo-theme-next/MATH.md at master · theme-next/hexo-theme-next hexojs/hexo-math: A hexo plugin that uses MathJax to render math equations. 为 Hexo 更换数学渲染引擎为 KaTeX - Mas’s Blog]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>latex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[色彩空间（颜色模型）]]></title>
    <url>%2Fpost%2Fcolor-space%2F</url>
    <content type="text"><![CDATA[前言 “色彩空间”一词源于西方的“Color Space”，又称作“色域”，色彩学中，人们建立了多种色彩模型，以一维、二维、三维甚至四维空间坐标来表示某一色彩，这种坐标系统所能定义的色彩范围即色彩空间。 简言之，色彩空间就是用来描述颜色的的坐标空间。而在GLSL里面，片元着色器最终接受的颜色属于RGBA模型。 常用的颜色模型 RGB(A)颜色模型 该模型的原理是光学三原色（红、绿、蓝）进行不同比例的混合可以得到其他任何颜色。 R：代表红色分量； G：代表绿色分量； B：代表蓝色分量； A：代表透明通道分量； 很明显，RGB色彩空间为一个立方体。该立方体内的每一个点都是不同的颜色值，而GLSL中每一个分量的取值范围为[0, 1][0,\ 1][0, 1]。而一般常用的RGB为24位，即每个分量取值为8位，也就是28=2562^8 = 25628=256种取值（[0, 255][0,\ 255][0, 255]），最后能够得到2242^{24}224个颜色值。 HSB颜色模型 HSB（也称HSV）颜色模型，是一种更符合直觉、更易于调色的颜色模型； H（Hue）：指色相，即单纯的颜色；取值范围为[0, 360°][0,\ 360\degree][0, 360°]。 S（Saturation）：指饱和度，饱和度越高则颜色越纯；取值范围为[0, 100%][0,\ 100\%][0, 100%]。 B（Brightness）：指明度，又称为值（Value）；取值范围为[0, 100%][0,\ 100\%][0, 100%]。 HSB色彩空间为一个圆柱体： HSB色彩空间坐标实际上是一个极坐标系；H分量为角度，S分量为弧长，B分量则是垂直于H-S极坐标系。 HSB转RGB hi=⌊h60⌋ mod 6f=h60−hip=v∗(1−s)q=v∗(1−f∗s)t=v∗(1−(1−f)∗s)(r,g,b)={(v,t,p), if hi=0(q,v,p), if hi=1(p,v,t), if hi=2(p,q,v), if hi=3(t,p,v), if hi=4(v,p,q), if hi=5\begin{aligned} h_i &amp;= \lfloor \frac{h}{60} \rfloor \ mod\ 6 \\ f &amp;= \frac{h}{60} - h_i \\ p &amp;= v * (1 - s) \\ q &amp;= v * (1 - f * s) \\ t &amp;= v * (1 - (1 - f) * s) \\ (r, g, b) &amp;= \begin{cases} (v, t, p),\ \text{if }h_i = 0 \\ (q, v, p),\ \text{if }h_i = 1 \\ (p, v, t),\ \text{if }h_i = 2 \\ (p, q, v),\ \text{if }h_i = 3 \\ (t, p, v),\ \text{if }h_i = 4 \\ (v, p, q),\ \text{if }h_i = 5 \\ \end{cases} \end{aligned} hi​fpqt(r,g,b)​=⌊60h​⌋ mod 6=60h​−hi​=v∗(1−s)=v∗(1−f∗s)=v∗(1−(1−f)∗s)=⎩⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎧​(v,t,p), if hi​=0(q,v,p), if hi​=1(p,v,t), if hi​=2(p,q,v), if hi​=3(t,p,v), if hi​=4(v,p,q), if hi​=5​​ 一个HSB转RGB的GLSL实现： 12345678910// Function from Iñigo Quiles// https://www.shadertoy.com/view/MsS3Wcvec3 hsb2rgb( in vec3 c )&#123; vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0 ); rgb = rgb*rgb*(3.0-2.0*rgb); return c.z * mix(vec3(1.0), rgb, c.y);&#125; RGB转HSB h={0°, if max=min60°∗g−bmax−min, if max=r and g≥b60°∗g−bmax−min+360°, if max=r and g&lt;b60°∗b−rmax−min+120°, if max=g60°∗r−gmax−min+240°, if max=bs={0, if max=0max−minmax=1−minmax, otherwisev=maxNotes:min=min(r,g,b)max=max(r,g,b)\begin{aligned} h &amp;= \begin{cases} 0\degree,&amp;\ \text{if } max = min \\ 60\degree * \frac{g - b}{max - min},&amp;\ \text{if } max = r\text{ and } g \ge b \\ 60\degree * \frac{g - b}{max - min} + 360\degree,&amp;\ \text{if } max = r\text{ and } g &lt; b \\ 60\degree * \frac{b - r}{max - min} + 120\degree,&amp;\ \text{if } max = g \\ 60\degree * \frac{r - g}{max - min} + 240\degree,&amp;\ \text{if } max = b \end{cases} \\ s &amp;= \begin{cases} 0,&amp;\ \text{if } max = 0 \\ \frac{max - min}{max} = 1 - \frac{min}{max},&amp;\ \text{otherwise} \end{cases} \\ v &amp;= max \\ \text{Notes:} \\ min &amp;= min(r, g, b) \\ max &amp;= max(r, g, b) \end{aligned} hsvNotes:minmax​=⎩⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎧​0°,60°∗max−ming−b​,60°∗max−ming−b​+360°,60°∗max−minb−r​+120°,60°∗max−minr−g​+240°,​ if max=min if max=r and g≥b if max=r and g&lt;b if max=g if max=b​={0,maxmax−min​=1−maxmin​,​ if max=0 otherwise​=max=min(r,g,b)=max(r,g,b)​ 参考文档 三原色光模式 - 维基百科，自由的百科全书 HSL和HSV色彩空间 - 维基百科，自由的百科全书 色彩空间_百度百科 RGB与HSB之间的转换公式 - xhhjin的专栏 - CSDN博客]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>GLSL</tag>
        <tag>计算机图形</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随机与噪声]]></title>
    <url>%2Fpost%2Frandom-and-noise%2F</url>
    <content type="text"><![CDATA[前言 随机和噪声是计算机图形生成艺术中的常用手段，可以利用随机和噪声构建出迷人又不尽相同的图案。 随机 一个随机的过程是一个不定因子不断产生的重复过程，但它可能遵循某个概率分布。 —— https://zh.wikipedia.org/wiki/随机性 随机数：即随机产生的数字，计算机中常用的随机算法都是产生一个[0, 1)之间的数；随机数最重要的特性是它在产生时后面的那个数与前面的那个数毫无关系。 伪随机（确定性随机）：即通过一个固定的计算函数来获取一个『随机』数，只要初值（随机种子）相同，得到的随机数就是相同的，得到随机数就是伪随机数，但是它们具有类似于随机数的统计特征。 伪随机函数 注：这里提及的伪随机函数只是简单地使用一些常见函数模拟出一个伪随机数，与『伪随机数生成器』有一定区别； 伪随机函数有以下几个特点： 足够混乱（相邻的种子数得到的『随机数』应该有较大差别） 周期应该比较长 不太容易预测出『随机值』（虽然确实有具体的函数描述） 相似概念：伪随机数生成器（pseudo random number generator，PRNG）； 三角函数 显然，初始的三角函数都不够混乱；要使得三角函数看起来足够混乱，有以下一些方法： 使周期变小，小到无法分辨； 上面这个图像是函数y=∣sin(x∗545673.42)∣y = |sin(x * 545673.42)|y=∣sin(x∗545673.42)∣生成的随机数图像，可以看到取得周期数极小，得到的随机图像也是『杂乱无章』，但是如果周期数与当前系统的最小精度之间存在倍数关系时，就会出现很有规律的随机值分布，如y=∣sin(x∗4153745.42)∣y = |sin(x * 4153745.42)|y=∣sin(x∗4153745.42)∣： 使长度变大，截取小数部分（相当于放大小数部分）； 上述图像是函数y=fract(sin(x)∗85595.42)y = fract(sin(x) * 85595.42)y=fract(sin(x)∗85595.42)得到的随机数分布图像；可以很明显的看到在函数极值处有比较明显的分割；且这种方法也同样存在第一种方法的问题，即放大倍数过大时，以至于得到的随机数分布出现比较规律的变化，如y=fract(sin(x)∗23485595.42)y = fract(sin(x) * 23485595.42)y=fract(sin(x)∗23485595.42)： 两种方法结合可以避免一些问题： 函数为：y=fract(sin(x/84.462)∗59595.42)y = fract(sin(x / 84.462) * 59595.42)y=fract(sin(x/84.462)∗59595.42)；通过同时放大小数部分，提高函数周期，可以使得到的随机数分布更均匀，更『随机』； 取小数部分 实际上，直接通过取一维线性函数的小数部分也能得到比较混乱的随机数分布；y=fract(x)y = fract(x)y=fract(x)的周期就是111，然后缩小周期（对于一维线性函数来说，同时也是放大小数部分）至无法分辨即可： 函数为：y=fract(x∗68875.42)y = fract(x * 68875.42)y=fract(x∗68875.42) 降维 有时候需要对一个二维及以上的向量生成一个随机数，这时候需要将向量降维至一维值，然后再使用伪随机函数生成伪随机数；而降维的方法就是向量点乘，通过将输入值点乘一个相应维度的固定向量值得到一个降维后的值。 噪声 简单地可以这么理解：噪声 = 随机数之间的插值； 数学的数值分析领域中，内插或称插值（英语：interpolation）是一种通过已知的、离散的数据点，在范围内推求新数据点的过程或方法。 一维线性插值 假设有aaa和bbb两个值，则根据插值系数k(∈[0, 1])k(\in[0,\ 1])k(∈[0, 1])，可以得到插值ccc： c=a+k∗(b−a)c = a + k * (b - a) c=a+k∗(b−a) 一维多项式插值 同上的假设： {u=∑i=1npi∗ki, (pi是对应项的系数)c=a+u∗(b−a)\begin{cases} u &amp;= \displaystyle\sum_{i=1}^n{p_i * k^i},\ (p_i\text{是对应项的系数}) \\ c &amp;= a + u * (b - a) \end{cases} ⎩⎪⎨⎪⎧​uc​=i=1∑n​pi​∗ki, (pi​是对应项的系数)=a+u∗(b−a)​ 一般来说，插值函数需要满足在定义域为[0, 1][0,\ 1][0, 1]上的值域为[0, 1][0,\ 1][0, 1]这个条件； 三次多项式插值 在噪声的插值中，用的最多的插值方法就是三次多形式插值了；因为三次多项式插值具有平滑且计算快的特点。GLSL内置的smoothstep()函数本质上就是一个三次多项式插值函数，插值效果如下所示： 其插值函数为： u(k)=3∗k2−2∗k3u(k) = 3*k^2 - 2*k^3 u(k)=3∗k2−2∗k3 也就是著名的 Perlin 噪声的三次多项式形式！ Perlin 噪声 Perlin噪声满足以下特征[1]： 对旋转具有统计不变性； 能量在频谱上集中于一个窄带，即：图像是连续的，高频分量受限； 对变换具有统计不变性。 经典的 Perlin 噪声有两种形式： 三次多项式： u(k)=3∗k2−2∗k3u(k) = 3*k^2 - 2*k^3 u(k)=3∗k2−2∗k3 五次多项式： u(k)=6∗k5−15∗k4+10∗k3u(k) = 6*k^5 - 15*k^4 + 10 * k^3 u(k)=6∗k5−15∗k4+10∗k3 二维插值 二维插值的原理就是在插值点附近的方格（矩形）顶点之间进行三次一维插值：即先对x方向进行两次插值得到插值点上下两个插值（即下图的(x+a,y)(x + a, y)(x+a,y)和(x+a,y+1)(x + a, y + 1)(x+a,y+1)两个点的插值），然后利用这两个点再对y方向做一次插值即可得到(x+a,y+b)(x + a, y + b)(x+a,y+b)点的插值！ 最后可以得到点(x+a,y+b)(x + a, y + b)(x+a,y+b)的插值为： f′(x+a,y+b)=[1−u(a)u(a)][f(x,y)f(x,y+1)f(x+1,y)f(x+1,y+1)][1−u(b)u(b)]f&#x27;(x + a, y + b) = \begin{bmatrix} 1 - u(a) &amp; u(a) \end{bmatrix} \begin{bmatrix} f(x, y) &amp; f(x, y + 1) \\ f(x + 1, y) &amp; f(x + 1, y + 1) \end{bmatrix} \begin{bmatrix} 1 - u(b) \\ u(b) \end{bmatrix} f′(x+a,y+b)=[1−u(a)​u(a)​][f(x,y)f(x+1,y)​f(x,y+1)f(x+1,y+1)​][1−u(b)u(b)​] 推导过程我就懒得用latex写一遍了，看图吧： 其中u(k)u(k)u(k)就是各类一维插值函数；联系到噪声本身，其中四个顶点的值就是当前方格四个顶点位置的随机值。这里有一个简单2D噪声生成的demo。 其它更高维的插值可以以此类推，可以想象当维度变大时，插值次数会呈指数型增长！ Simplex 噪声 Simplex噪声是Ken Perlin（没错，就是Perlin噪声的提出者）提出的更自然，性能更好的噪声算法。 其不同的地方在于： 在二维插值的时候，不使用正方形的四个顶点进行插值，而是使用等边三角形的三个顶点进行插值；更高维的插值也是如此，也就是说N维的插值只需要N+1个点！比传统的指数型增长相比改善显著！ 使用五次多项式进行插值，使边界处的衔接更平滑。 如何在二维平面构建等边三角形单元格？The Book of Shaders提到了一个巧妙的构建方法：首先将正方形单元格平分为两个等腰三角形，然后进行斜切变换将等腰三角形变成等边三角形[2]！ 参考文档 随机性 - 维基百科，自由的百科全书 随机数 - 维基百科，自由的百科全书 不只是噪音 - 知乎 The Book of Shaders: Noise Perlin噪声 - 维基百科，自由的百科全书 双线性插值 - 维基百科，自由的百科全书 Perlin噪声 - 维基百科，自由的百科全书 ↩︎ The Book of Shaders: Noise ↩︎]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>GLSL</tag>
        <tag>计算机图形</tag>
        <tag>webGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序（H5）接入腾讯IM]]></title>
    <url>%2Fpost%2Fmp-im-sdk%2F</url>
    <content type="text"><![CDATA[前言 腾讯IM是腾讯推出的即时通讯SDK，能在多端进行接入，用于聊天这类应用场景。 小程序接入腾讯IM 相关准备 小程序需要事先添加一个request 合法域名：https://webim.tim.qq.com；因为SDK依赖这个域名的接口进行消息监听等操作。 在小程序项目中安装完tim-js-sdk这个包之后，还需要在开发者工具中进行构建npm操作： 业务需要提供SDKAppID（IM应用ID），userSig（用户密钥），userID（用户id）以及groupID（群组id）； 接入步骤 这里以小程序的IM群组消息接收业务场景为例；H5的接入步骤类似，因为API一致，只不过SDK的包名有所不同。 引入SDK； 1import TIM from 'tim-wx-sdk' 根据接口获取IM初始化所需的配置（包括SDKAppID和userSig）并初始化； 12345const config = await api.getIMConfig() // 获取IM配置const tim = TIM.create(&#123; SDKAppID: config.appId // 应用id&#125;) // 创建实例tim.setLogLevel(1) // sdk日志输出级别, 0则开启全部；根据需要配置 注册监听事件，如SDK加载完成和消息接收等事件； 12345678910111213tim.on(TIM.EVENT.SDK_READY, e =&gt; &#123; // SDK 进入 ready 状态时触发 console.log('ready', e) // 一些SDK的API必须在ready事件触发后才能执行！&#125;)tim.on(TIM.EVENT.MESSAGE_RECEIVED, e =&gt; &#123; // SDK 收到推送的单聊、群聊、群提示、群系统通知的新消息，可通过遍历 event.data 获取消息列表数据并渲染到页面 console.log('received', e) if (Array.isArray(e.data)) &#123; e.data.forEach(item =&gt; &#123; parseMessage(item) // 解析IM消息 &#125;) &#125;&#125;) 登录IM账号； 登录成功后加入到对应群组； 12345678910111213tim.login(&#123; // 登录到IM userID: userID, userSig: userSig&#125;).then(res =&gt; &#123; console.log('login', res) return tim.joinGroup(&#123; // 加入到对应的群组 groupID: groupID, // 群组id applyMessage: 'wechat', type: TIM.TYPES.GRP_AVCHATROOM // 群组类型：音视频聊天，根据业务需求选择 &#125;)&#125;).then(res =&gt; &#123; console.log('group', res)&#125;) 群组类型以下几种： TIM.TYPES.GRP_PUBLIC（公开群） TIM.TYPES.GRP_CHATROOM （聊天室） TIM.TYPES.GRP_AVCHATROOM （音视频聊天室） 解析消息：IM返回消息有系统消息和自定义消息两种，这个根据实际业务定制的消息结构进行解析即可。 发送消息需要引入另一个包cos-wx-sdk-v5，其他SDK的功能可以查看这个文档：https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html 相关文档 SDK接入文档：即时通信 IM 集成 SDK（Web &amp; 小程序） - 常规集成（无 UI 库） - 文档中心 - 腾讯云 SDK详细文档：SDK - Documentation 消息收发文档：即时通信 IM 消息收发（Web &amp; 小程序） - 常规集成（无 UI 库） - 文档中心 - 腾讯云]]></content>
      <categories>
        <category>业务</category>
      </categories>
      <tags>
        <tag>H5</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接入七牛云SDK上传文件]]></title>
    <url>%2Fpost%2Fqiniu-sdk-upload%2F</url>
    <content type="text"><![CDATA[前言 想把markdown的图片都上传到图床上，方便管理引用；刚好手里有个七牛云的对象存储空间，所以就动手接入七牛的SDK，将图片上传到存储空间。 由于单纯地利用客户端的SDK并不能直接上传文件到七牛云空间中，还需要服务端的SDK返回上传token后才能进行上传操作，因此要配置一个服务端接口来获取上传的token。 接入流程 服务端 由于手上只有一个PHP的服务器可以用，所以这里就以PHP SDK为例。 在项目中引入七牛云的SDK包； 在对应接口文件中引入SDK包，调用Auth类生成上传token；如： 1234567891011121314require_once("../tools/qiniu-sdk/7.2.10/autoload.php");use Qiniu\Auth;$auth = new Auth($AK, $SK); // $AK就是Access Key，$SK就是Serect Key$token = $auth-&gt;uploadToken($bucket); //if ($token) &#123; // 判断token是否生成 $data = [ "token" =&gt; $token ]; $message = "七牛云上传token获取成功！";&#125; else &#123; $code = 400; $message = "七牛云上传token生成失败！";&#125; 注：生成token需要存储空间的Access Key、Serect Key和bucket（空间名）参数。 返回token即可； 客户端（浏览器） 安装qiniu-js并引入； 1import * as Qiniu from 'qiniu-js' // 注意qiniu-js并没有export default！ 获取到要上传的文件后，根据服务端接口获取上传token； 利用upload()方法上传文件； 123456789if (res.data.token) &#123; const cur = dayjs().format('YYYYMMDDHHmmss') const observer: QiniuObservable = Qiniu.upload( img, // 文件 `$&#123;config.path&#125;$&#123;cur&#125;$&#123;getSuffix(img.name)&#125;`, // 文件名 res.data.token // 上传token ) return observer&#125; 调用js SDK的上传方法后，会返回一个对象，这个对象包含几个回调，可以用于监听上传进度，错误以及上传完成等状态； 1234567891011121314151617181920212223242526272829303132333435363738394041export interface ObserverNextRes &#123; /** * 进度更新回调数据 */ total: &#123; /** * 已上传大小，单位为字节 */ loaded: number; /** * 本次上传的总量控制信息，单位为字节 */ total: number; /** * 当前上传进度，范围：0～100 */ percent: number; &#125;;&#125;export interface ObserverError &#123; isRequestError: boolean; code: number; message: number; reqId: string;&#125;export interface QiniuObserver &#123; /** * 接收上传进度信息的回调 */ next: (res: ObserverNextRes) =&gt; void; /** * 上传错误回调 */ error: (err: ObserverError) =&gt; void; /** * 上传完成后的回调 */ complete: (info: any) =&gt; void;&#125; 这个对象的结构大致如QiniuObserver接口所描述的；其中complete回调参数的具体结构可以在服务端进行配置； 对qiniu-js的封装可以看看这个demo； SDK文档 服务端SDK PHP：https://developer.qiniu.com/kodo/sdk/1241/php Node：https://developer.qiniu.com/kodo/sdk/1289/nodejs 客户端SDK JS：https://developer.qiniu.com/kodo/sdk/1283/javascript]]></content>
      <categories>
        <category>业务</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于vertical-align属性]]></title>
    <url>%2Fpost%2Fcss-vertical-align%2F</url>
    <content type="text"><![CDATA[前言 关于vertical-align属性被用得最多的场景就是用于对一些内联元素的垂直居中显示，然而事情永远不是我们想的那样简单，给了一个middle就能永远如我们所愿，很多时候基本就会发现图片和文字压根就没有垂直居中对齐……这个时候基本上都不知道为啥，试了一些其他属性值之后如果未果那么基本上就会用上flex布局暴力居中了，我一般就是这样做的 ￣□￣｜｜。 vertical-align的作用 对于内联元素 内联元素包括display: inline、display: inline-*和匿名内联元素（如文本节点等）； vertical-align可以设置内联元素与其容器元素（父元素或line boxes）在垂直方向的对齐方式；要理解对齐方式，首先要理解以下几个概念： 基线 x高度 inline boxes line box 相关概念 基线和 x 高度 可以看一下维基百科的一张图[1]，一目了然；x高度指的就是小写字母x的高度，而基线指的就是小写字母x的底部边缘处；这张图的其他概念也扩展一下： ascent：升部；即高于小写x字母以上的部分； ascent height：升部高度；某个字符位于升部区域的高度； descent：降部；即低于小写x字母以下的部分； descent height：降部高度；某个字符位于降部区域的高度； inline boxes 和 line boxes 这里借用张老师的一张图[2]，也是一目了然； inline box：其实就是各种内联元素外面包裹的一层盒子，其高度与font-size和line-height有关； line box：顾名思义，指的就是一行内联元素所包裹的盒子，可以包含多个inline box。可以用鼠标选中内联元素，高亮的区域的高度就是其对应的line box的高度。 vertical-align的属性值 vertical-align的对齐对象有两类，因此属性值作用的对象也有两类，一类是父元素，一类是line boxes（即每一行）； 对齐对象为父元素 The following values only have meaning with respect to a parent inline element, or to the strut of a parent block container element.[3] baseline：默认值，使内联元素盒子（inline box，下同）基线与父元素的基线对齐；不过父元素的基线位置有多种情况，需要单独说明； middle：使内联元素盒子的中线与父元素基线向上0.5个x高度的位置对齐；很明显，我们平时把middle理解为内联元素的中线与父元素的中线对齐是错误的！ text-top：使内联元素盒子的顶部与父元素content area的顶部对齐； text-bottom：使内联元素盒子的底部与父元素content area的底部对齐； sub：使内联元素盒子的基线与父元素的下标基线对齐； super：使内联元素盒子的基线与父元素的上标基线对齐； &lt;length&gt;：使内联元素盒子的基线与父元素基线向上给定长度的位置对齐；可以为负值，负值则代表基线向下给定长度的位置； &lt;percentage&gt;：与&lt;length&gt;同理，百分比相对的是内联元素的line-height； 关于 inline box 这里内联盒子的范围可以参考W3C的官方定义： In the following definitions, for inline non-replaced elements, the box used for alignment is the box whose height is the ‘line-height’ (containing the box’s glyphs and the half-leading on each side, see above). For all other elements, the box used for alignment is the margin box.[3:1] 简言之，对不可替换元素，这个inline box的高度就是line-height；反之则是margin-box； On a block container element whose content is composed of inline-level elements, ‘line-height’ specifies the minimal height of line boxes within the element. The minimum height consists of a minimum height above the baseline and a minimum depth below it, exactly as if each line box starts with a zero-width inline box with the element’s font and line height properties. We call that imaginary box a “strut.”[4] 关于没有基线的元素 对于没有基线的元素来说，其基线用margin-box区域的底边缘来替代！然而对于表现形式为inline-block的内联元素来说，其基线的确定要稍微特殊一点：当inline-block元素内部没有任何内联子元素或者overflow的值不为visible时，其基线位置还是margin-box的底边缘，否则就是其内部最后一个line box的基线位置！ The baseline of an ‘inline-block’ is the baseline of its last line box in the normal flow, unless it has either no in-flow line boxes or if its ‘overflow’ property has a computed value other than ‘visible’, in which case the baseline is the bottom margin edge.[3:2] 关于 content area 及其顶部位置 content area是什么？content area的顶部位置又是如何确定的？本来我也没想过深究这些，直到我准备查看一下text-top属性值的效果时，我简直一脸懵逼，不知道发生了什么……看个例子： 123456789.demo &#123; width: 200px; height: 50px; line-height: 50px; background-color: lightcyan;&#125;.pic &#123; vertical-align: text-top;&#125; 123&lt;div class="demo"&gt; &lt;img class="pic" src="https://placekitten.com/40/40"&gt;&lt;/div&gt; 很明显&lt;img&gt;的对齐区域应该是其margin-box，那么为何其父元素的content area的顶部不是&lt;div&gt;的顶部？可能的解释就是，其对齐的父元素不是外层的&lt;div&gt;，而是line box！那么如何确定line box的content area？ 关于content area的高度，W3C有这么一段说明： The height of the content area should be based on the font, but this specification does not specify how. A UA may, e.g., use the em-box or the maximum ascender and descender of the font.[3:3] 据我观察，谷歌浏览和火狐浏览器应该都是采用了字体的最大升部高度和最大降部高度组成高度；即： content area height = x高度 + 最大升部高度 + 最大降部高度 因为这个line box的顶部位置正好可以通过line-height - font-size * 1.4计算得到（这个1.4根据具体字体可能有差异）； 当content area的高度小于line box的高度时，那么line box的content area顶部就是： line box height - content area height 反之，那么line box的content area顶部就是line-box的顶部； 可以利用上面的公式大概计算一下，怎样可以使得上述的text-top能够对齐到&lt;div&gt;的顶部，即line box的content area的高度等于line-height；由于line-height设置为50px，所以推出font-size为50/1.4，约等于36px；看下font-size为36px的情况： 差不多就是这个逻辑； 对齐对象为 line box top：内联元素及其后代的顶部与line box的顶部对齐； bottom：内联元素及其后代的底部与line box的底部对齐； 除了上面的简单定义，W3C的规范里还提到了一点： The inline-level boxes are aligned vertically according to their ‘vertical-align’ property. In case they are aligned ‘top’ or ‘bottom’, they must be aligned so as to minimize the line box height. [5] 也就是说，使用top和bottom对齐时，会使得line box的高度保持在尽量小的程度；而line box的最小高度就是line-height，这一点规范上也有说明： On a block container element whose content is composed of inline-level elements, ‘line-height’ specifies the minimal height of line boxes within the element[4:1] 关于 line box 及其高度 关于line box，W3C有这么一段定义： In an inline formatting context, boxes are laid out horizontally, one after the other, beginning at the top of a containing block. Horizontal margins, borders, and padding are respected between these boxes. The boxes may be aligned vertically in different ways: their bottoms or tops may be aligned, or the baselines of text within them may be aligned. The rectangular area that contains the boxes that form a line is called a line box.[6] 简言之，就是每一行上包裹这一行内所有inline box的那个区域就是line box；而line box的高度则是由其内部最靠上的inline box顶部到最靠下的inline box底部之间的距离（因为可能各个inline box之间的高度和垂直对齐方式不一致）： The height of a line box is determined as follows: … … The line box height is the distance between the uppermost box top and the lowermost box bottom. (This includes the strut, as explained under ‘line-height’ below.)[5:1] 对于单元格元素 单元格元素包括&lt;td&gt;及display: table-cell的元素； vertical-align除了可以设置内联元素的垂直对齐方式外，还能用于设置单元格的垂直对齐方式，其属性值有： baseline：使单元格的基线与当前行中其它所有以基线对齐方式的单元格的基线对齐； top：使单元格的padding-box的顶边缘与当前行的顶部对齐； bottom：使单元格的padding-box的底边缘与当前行的底部对齐； middle：使单元格的padding-box居中； （幽灵）空白节点 空白节点的特征就是：本身是一个inline box，宽度为0，但是具有（继承）font和line-height属性；因此空白节点本身是看不见的。关于这种空白节点，貌似找不到很明显的官方定义；张老师把这种空白节点称之为“幽灵空白节点”，因为这些空白节点都是无意或者html在解析的过程中自动产生的，且不能直接控制，所以谓之“幽灵”。 理解空白节点的存在对于弄清楚之前使用vertical-align: middle等属性值为何不生效（或者不符合预期）是必须的。 空白节点的来源 大致有两处来源： 标签后面换行符或空格产生的；如： 12345678.demo &#123; width: 200px; background-color: lightcyan;&#125;.pic &#123; width: 40px; height: 40px;&#125; 123&lt;div class="demo"&gt; &lt;img class="pic" src="https://placekitten.com/40/40"&gt;&lt;/div&gt; 可以看到图片底部留有空隙，空隙产生的原因就是&lt;img&gt;后面进行了换行，因此html解析后多出一个空白节点；空白节点虽然宽度为0，但是继承了line-height属性，因此其高度就是line-height，所以&lt;img&gt;元素的margin-box底部会与空白节点的inline box基线进行对齐！ line box内部默认第一个inline box就是空白节点； exactly as if each line box starts with a zero-width inline box with the element’s font and line height properties. We call that imaginary box a &quot;strut&quot;[4:2] W3C把这种空白节点称之为“strut”，意为“支柱”；可能是撑起行高的作用。 空白节点的影响 导致图片不能正常居中 有时候我们可能想使用line-height等于height加上vertical-align: middle使图片在某区域中垂直居中这种套路，结果发现图片总是中间偏下一点： 12345678910.demo &#123; width: 200px; height: 50px; background-color: lightcyan;&#125;.pic &#123; width: 30px; height: 30px; vertical-align: middle;&#125; 123&lt;div class="demo"&gt; &lt;img class="pic" src="https://placekitten.com/40/40"&gt;&lt;/div&gt; 这个就是空白节点捣的鬼，由于空白节点继承了line-height，进而有了基线位置，因此line box的基线位置就变了空白节点的基线位置，然而字体基线位置并不是在中线位置往下0.5个x高度的地方，而是更下一点的位置，也就是“基线下沉”。因此，此时基线往上0.5个x高度之后的位置并不是inline box的中线位置，而且偏下一些的位置；至于到底偏下多少，这取决于字体及字体大小。 可以在&lt;img&gt;加上一个x来查看基线位置（可以当做“显形”的空白节点），蓝色框就是文本节点的inline box区域，可以看到基线位置明显偏下（inline box整体居中），因此&lt;img&gt;对齐的地方根本不是inline box的中线位置，所以就会偏下。 解决办法：虽然不能直接控制空白节点的样式，但是由于空白节点继承font和line-height属性，所以可以操纵外层元素的font-size来影响空白节点的基线位置。设置外层font-size: 0，可以使得空白节点的line-height为0，因此其高度也为0，那么所有的“线”都重合了，处于line box的中线处，所以&lt;img&gt;此时对齐的位置就是line box的中线： 其它问题 图标和文字不能垂直居中对齐 同一行中，混有图标和文字时，若使父级元素的height等于line-height，图标高度也等同于父级元素的高度，但是可以看到文字并非和图片一样垂直居中，而是偏下一些。如： 1234567891011.demo &#123; width: 200px; line-height: 20px; height: 20px; background-color: lightcyan;&#125;.pic &#123; width: 20px; height: 20px; vertical-align: middle;&#125; 1234&lt;div class="demo"&gt; &lt;img class="pic" src="./test.png"&gt; &lt;span&gt;x开头的一段话&lt;/span&gt;&lt;/div&gt; 可以分析一下，由于vertical-align的默认值就是baseline，因此图片和文字都是基线对齐其父元素，即外层line box的基线位置；从上图可以很明显看出，此时line box的基线位置就是&lt;div&gt;区域的底部边缘，因此文字基线就会对齐底部，而非想象中的居中。 那么把对齐方式都改为middle又如何？ 显然，由于基线下沉的影响，文字对齐的位置会相对中间线偏下一点点。 解决办法：只需要将图标的对齐方式设置为top即可，此时图标和文字就会居中对齐： 因为top对齐会使得line box的高度保持在最低，此时由于inline box的高度都没有超过line-height，因此此时line box的高度就是line-height的高度。 为何修改对齐方式会导致line box基线位置变化 虽然可以说x底部边缘位置就是line box的基线所在位置，但是为何修改inline box的对齐方式会导致line box的基线位置发生改变？关键就在于如何确定line box的基线位置，然而要命的就是CSS规范里面竟然没有定义line box的基线位置！！！ there are multiple solutions and CSS 2.1 does not define the position of the line box’s baseline[5:2] 看到这里我突然觉得为啥围绕着竖直对齐为何会产生那么多说不清的地方了……因为很多对齐方式基本上都是根据line box的基线位置进行对齐，然而line box的基线位置居然没有官方定义。 ？？？ 然而实际上浏览器在实现渲染的时候，肯定会有关于line box基线位置的定义的，不过不知道该去哪里能找到这份定义，不然就一直在这个地方纠结不清了。 后话 为何使用vertical-align属性的时候会心里没底，查完那么多资料我终于明白了，因为牵扯到的规范实在是太多了！ 还有，这次之所以引用了那么多的W3C规范，是因为根据MDN的资料和网上一些文章压根不足以解答心中的疑惑。因此，去查看一手资料是最直接了当的方式，也免得道听途说误解了什么。不过这样查资料确实挺耗费时间的，但得到的收获也少不了。 参考文档 CSS深入理解vertical-align和line-height的基友关系 « 张鑫旭-鑫空间-鑫生活 关于 vertical-align 你应该知道的一切 - 掘金 字母’x’在CSS世界中的角色和故事 « 张鑫旭-鑫空间-鑫生活 vertical-align - CSS（层叠样式表） | MDN X字高 - 维基百科，自由的百科全书 ↩︎ CSS float浮动的深入研究、详解及拓展(一) « 张鑫旭-鑫空间-鑫生活 ↩︎ https://www.w3.org/TR/CSS2/visudet.html#propdef-vertical-align ↩︎ ↩︎ ↩︎ ↩︎ https://www.w3.org/TR/CSS2/visudet.html#propdef-line-height ↩︎ ↩︎ ↩︎ https://www.w3.org/TR/CSS2/visudet.html#line-height ↩︎ ↩︎ ↩︎ https://www.w3.org/TR/CSS2/visuren.html#inline-formatting ↩︎]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于valueOf、toString和[Symbol.toPrimitive]方法]]></title>
    <url>%2Fpost%2Fvalueof-tostring-toprimitive%2F</url>
    <content type="text"><![CDATA[前言 在掘金上看到一篇文章，大意是如何让a === 1 &amp;&amp; a === 2 &amp;&amp; a === 3等于true；一开始确实一脸懵逼，不过后来想到了访问修饰符能够解决这个问题，毕竟每访问一次值就加上1就好了；当然，我居然忘了全局变量本身就是window的一个属性这个点，有点疏忽大意。 12345678let val = 1Object.defineProperty(window, 'a', &#123; get () &#123; return this.val++ // 这里的this就是全局对象window &#125;&#125;)console.log(a === 1 &amp;&amp; a === 2 &amp;&amp; a === 3) // true 不过，我又想到貌似对象还有一些方法能够改变访问到的值；比如： Object.prototype.valueOf() Object.prototype.toString() [Symbol.toPrimitive](hint) 然而，经过折腾发现这三种方法并不像访问修饰符那样的机制，在使用全等号===进行判断时并没有触发： 123456789101112131415let a = &#123; valueOf () &#123; return 1 &#125;, toString () &#123; return '2' &#125;, [Symbol.toPrimitive] () &#123; return 3 &#125;&#125;console.log(a === 1) // falseconsole.log(a === '2') // falseconsole.log(a === 3) // false 所以，心里自然就有疑问，这几个方法到底在什么时候才会触发？ Object.prototype.valueOf() 对象的valueOf旨在返回对象的原始值，会在需要将对象转换成原始值的地方自动执行。 根据MDN上的资料[1]可知，内置的一些对象已经定义valueOf方法，而对象默认则返回本身作为valueOf()的返回值。 Object.prototype.toString() 同理，toString()方法会返回表示该对象的字符串，会在对象预期要被转换成字符串的地方自动执行。对象默认的toString()方法会返回[object type]，这个type就是对象构造函数的名称。 Symbol.toPrimitive [Symbol.toPrimitive](hint)方法作用同valueOf()一样，但是优先级要高于valueOf()；而且该方法还会接受一个参数hint，这个参数用来表示期望转换的原始值的具体类型，有以下几种： number：数字类型 string：字符串类型 default：默认 对象转换成原始值 很明显，以上三种方法都是在对象被预期转换成某种原始值时触发，那么触发的时机是什么，需要何种类型的原始值就需要弄清楚了。 预期被转换成字符串类型 对应的hint类型为string 进行输出的地方，如alert()。 String(obj)： 1234567let a = &#123; toString () &#123; return '2' &#125;&#125;console.log(String(a)) // 2 字符串连接（+）操作： 1234567let a = &#123; toString () &#123; return '2' &#125;&#125;console.log(a + 'vv') 模板字符串： 12345678let a = &#123; [Symbol.toPrimitive] (hint) &#123; console.log(hint) // string return 2 &#125;&#125;console.log(`你是老$&#123;a&#125;？`) // 你是老2？ 预期被转换成数字类型 对应的hint类型为number 除法： 1234567let a = &#123; valueOf () &#123; return 2 &#125;&#125;console.log(2 / a, a / 2) // 1 1 可以使用[Symbol.toPrimitive]()方法来验证一下： 12345678let a = &#123; [Symbol.toPrimitive] (hint) &#123; console.log(hint) // number return 2 &#125;&#125;console.log(2 / a) // 1 Number(obj)： 12345678let a = &#123; [Symbol.toPrimitive] (hint) &#123; console.log(hint) // number return 2 &#125;&#125;console.log(Number(a)) // 2 正负号（注意不是加减运算）： 123456789let a = &#123; [Symbol.toPrimitive] (hint) &#123; console.log(hint) // number return 2 &#125;&#125;console.log(+a) // 2console.log(-a) // -2 预期被转换成默认类型（其他） 对应的hint类型为default 数字加法（即与对象相加的一方为数字类型）： 12345678let a = &#123; [Symbol.toPrimitive] (hint) &#123; console.log(hint) // default return 2 &#125;&#125;console.log(1 + a) // 3 这一点有点意外，原以为像这种情况预期转换的类型应该是数字类型，但事实上却是default； 布尔运算：所有对象都被转换成true； 12345678let a = &#123; [Symbol.toPrimitive] (hint) &#123; console.log(hint) // 没有触发 return false &#125;&#125;console.log(Boolean(a), a &amp;&amp; 123) // true 123 布尔运算包括==； 三种方法触发的顺序 首先判断对象是否有[Symbol.toPrimitive](hint)方法，若有则执行该方法； 1234567891011121314let a = &#123; [Symbol.toPrimitive] (hint) &#123; console.log(hint) return 'right your mother right' &#125;, toString () &#123; return 'f**k' &#125;, valueOf () &#123; return 'sb' &#125;&#125;console.log(String(a)) // right your mother right 如果预期被转换成字符串类型时，则优先执行toString()方法； 12345678910let a = &#123; toString () &#123; return 'f**k' &#125;, valueOf () &#123; return 'sb' &#125;&#125;console.log(String(a)) // f**k 如果预期被转换成默认类型或者数字类型时，则优先执行valueOf()方法： 12345678910let a = &#123; toString () &#123; return 123 &#125;, valueOf () &#123; return 456 &#125;&#125;console.log(Number(a)) // 456 注：若没有valueOf()方法，但是定义了toString()方法，则会执行toString()方法； 1234567let a = &#123; toString () &#123; return 123 &#125;&#125;console.log(Number(a)) // 123 参考文档 大厂面试题分享：如何让(a=1&amp;&amp;a=2&amp;&amp;a===3)的值为true? - 掘金 Object to primitive conversion ★ Type Conversions Object.prototype.valueOf() - JavaScript | MDN ↩︎]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用npm的注意事项及错误收集]]></title>
    <url>%2Fpost%2Fnpm-use-and-error%2F</url>
    <content type="text"><![CDATA[前言 记录npm使用的一些注意事项，以及收集一些npm错误的解决办法。 更新node和npm 更新node 安装n模块： 1sudo npm i -g n 安装最新稳定版node： 1sudo n stable 更新npm 1sudo npm i -g npm 注意：更新完node和npm后，可能当前环境并没有刷新，需要手动更新命令行工具或重新进入； 手动更新： 1source ~.zshrc 通过nvm更新node和npm nvm即Node version manager，是专门用来管理node版本切换的工具； 安装相应版本的node： 1nvm install v10.8.0 执行上述命令会自动安装v10.8.0的node及其对应的npm；安装完后会自动切换到安装完后的node版本，需要注意的是这只是临时切换。 永久切换node版本： 1nvm alias default v10.8.0 这样关闭终端后，打开的默认node版本就是上述设置的版本。 临时切换node版本： 1nvm use vxx.x.x 查看已安装的node版本： 1nvm list NPM错误收集 ERR 4048 unlink 123npm ERR! errno: -4048,npm ERR! code: &apos;EPERM&apos;,npm ERR! syscall: &apos;unlink&apos; 导致问题的原因：项目中文件夹或某个文件被其他程序占用（很可能就是vscode的锅），导致文件没有权限被读写； 解决办法：使用杀毒软件对文件夹进行占用解锁；如腾讯管家： 相关参考链接： node.js - Fail to install npm package “npm ERR! errno -4048” - Stack Overflow node.js - npm install give Error: EPERM, unlink - Stack Overflow EPERM: operation not permitted 1234npm ERR! code EPERMnpm ERR! errno -4048npm ERR! syscall lstatnpm ERR! Error: EPERM: operation not permitted 该类错误通常是项目文件夹的权限不够（win10中可能出现），在文件夹右击，然后选择『管理员取得所有权』即可。（很纳闷，明明是管理员账户为啥还有这情况出现？） 如果是解锁文件和赋予管理员权限还是提示-4048的错误时，可以考虑在npm命令后面加上--no-bin-links参数；如： 1npm i xxx --no-bin-links 参考文档：Error: EPERM: operation not permitted, unlink · Issue #2464 · phoenixframework/phoenix Unexpected end of JSON input while parsing near 1Unexpected end of JSON input while parsing near xxx 导致问题的原因：可能是之前安装的时候出现错误导致安装中断，因此npm缓存中含有不正确的安装包； 解决办法：使用npm cache clean -f清除缓存，然后再次安装即可； 相关参考链接： npm install error unexpected end of JSON input while parsing near ‘…omment:http://open’ · Issue #4328 · LLK/scratch-gui node-sass安装失败 解决办法：直接单独设置淘宝源镜像进行安装； 1npm config set sass_binary_site https://npm.taobao.org/mirrors/node-sass/ 参考链接：整理 node-sass 安装失败的原因及解决办法 - 个人文章 - SegmentFault 思否 提示包不存在：code ETARGET 如这样的错误： 1234567npm ERR! code ETARGETnpm ERR! notarget No matching version found for es-abstract@1.14.0npm ERR! notarget In most cases you or one of your dependencies are requestingnpm ERR! notarget a package version that doesn&apos;t exist.npm ERR! notargetnpm ERR! notarget It was specified as a dependency of &apos;xxx&apos;npm ERR! notarget 查找原因是package-lock.json当中的这个包确实没有这个版本； 解决办法：直接把package-lock.json这个包的信息去掉，然后重新安装即可；千万不要尝试直接在里面改变包的版本号，那样校验不会通过！ 参考文档 通过NVM安装Node.js - CSDN博客]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输入纹理资源]]></title>
    <url>%2Fpost%2Fwebgl-texture-input%2F</url>
    <content type="text"><![CDATA[前言 在webGL中，纹理有两种类型，一种是2d的，另一种是天空盒类型的。纹理除了用于给物体表面贴图之外，还可以用于数据传输，十分有用。 纹理数据的来源可以是图片、视频、帧缓冲、canvas甚至还可以是数组，对于着色器而言，纹理就是一类特定的数据，在着色器可以使用取样器来进行数据取样（解析）。 纹理坐标系 如上图所示（图片来源），纹理坐标系的原点位于纹理区域的左下角，然后s轴从左往右逐渐增大，范围为[0, 1]；同理，t轴从下往上逐渐增大，范围也为[0, 1]。 记住纹理坐标系的特点能便于纹理数据的取样以及坐标系的变换，因为纹理坐标系和webGL的其他坐标系的特点不一样，如果需要将纹理映射到目标坐标系就需要进行坐标系变换了。 单个纹理输入 2D纹理输入的一般流程 加载纹理资源或创建纹理资源； 创建纹理缓冲： 1let textureBuffer = gl.createBuffer() 激活相应的纹理通道： 1gl.activeTexture(gl.TEXTURE0 + textureID) 将纹理缓冲绑定到相应的纹理通道上： 1gl.bindTexture(gl.TEXTURE_2D, textureBuffer) 将纹理通道号传递给纹理取样器属性： 1gl.uniform1i(pos, textureID) // pos指的是纹理取样器属性的地址 绑定纹理数据： 1gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value) 注：这里的texImage2D()方法参数仅是举例，实际上该方法有多种参数形式，需要根据具体情况来设置！ 设置纹理取样参数： 1234gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE) // 指定纹理S轴方向大小适应方式gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE) // 指定纹理T轴方向大小适应方式gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR) // 指定纹理缩小取样算法gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR) // 指定纹理放大取样算法 举的例子是比较常见的取样参数设置。 对于着色器而言，只需要设置一个纹理取样器属性用来接收纹理数据即可，然后使用texture2D()函数来进行取样： 1234567uniform sampler2D u_Texture; // 纹理取样器// ...void main() &#123; //... vec4 textureColor = texture2D(u_Texture, texturePos); // 取样 //...&#125; 不同类型的纹理资源的输入流程基本一致，只是在加载步骤以及绑定纹理数据的时候有所不同。 不同类型纹理资源的加载流程 图片资源 注：这里的图片资源指的是&lt;img&gt;元素（即HTMLImageElement对象），既包DOM中本身存在的元素，也包括通过Image()构造函数手动创建的元素。 图片资源需要在加载完成后才能绑定到纹理缓冲上去，可以利用HTMLImageElement对象自带的onload方法就能监听到图片数据加载完成的事件： 12345678let img = new Image()img.onload = () =&gt; &#123; // ... gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img) // ...&#125;img.src = 'img_path.png' 没错，HTMLImageElement本身可以直接传入texImage2D()方法中做参数！而在DOM中获取到的&lt;img&gt;结点和利用base64字符串构建的图片也是一样的，需要在onload回调中才进行纹理数据的传递！ 视频资源 注：这里的视频资源指的是&lt;video&gt;元素（即HTMLVideoElement对象），既包含DOM中存在的元素也包括createElement()方法创建的&lt;video&gt;元素（&lt;video&gt;元素没有对应的构造函数！）。 1234567891011121314let video = document.createElement('video')function videoLoaded () &#123; // ... video.play() // 开始播放 gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video) // ... video.removeEventListener('canplaythrough', videoLoaded) // 事件触发后马上解绑事件&#125;video.addEventListener('canplaythrough', videoLoaded) // 监听视频缓冲是否能够进行播放了video.muted = true // 静音video.preload = 'auto' // 开启预加载video.src = 'video_path.mp4' // 写入视频地址 同样，HTMLVideoElement对象能够直接传入texImage2D()方法中做参数！ canplaythrough事件会在视频缓冲到一定长度且能够播放时进行触发，因此可以以此来作为视频资源可用的依据，在这个回调里进行纹理数据的传递等操作。不过需要注意的是，该事件在开启loop后，会在视频每一次循环的开始被触发，因此最好将回调事件设置成一次性的。 设置preload属性为auto可用使得视频优先被加载（即使在未播放的状态下）。 在不需要声音信息的情况下可以开启muted属性！ 需要注意的是，视频纹理信息并不会实时更新（其实一次传递就相当于传了当时正在播放的视频帧图像而已），因此需要在帧更新函数（如requestAnimationFrame()函数）中不停地更新当前视频资源到纹理缓冲中！更新的操作流程跟第一次传入类似，只不过不需要再重复创建纹理缓冲了！ ImageData对象 ImageData对象是一个用于描述canvas区域像素数据的数据结构。它含有以下属性： data：一个Uint8ClampedArray类型的数组，数组中的元素按照RGBA的顺序排序。 width：像素区域的宽度。 height：像素区域的高度。 ImageData对象的来源有： canvas上下文对象的createImageData()和getImageData()方法；此外putImageData()方法可以将数据间接地写入ImageData对象。 ImageData()构造函数： new ImageData(array, width, height); array：像素数据，Uint8ClampedArray类型的数组； width：像素区域宽度； height：像素区域高度； 从来源就可以看出，ImageData类型的纹理既可以取自canvas，也可以直接将数组转换成ImageData，即可以手动生成纹理数据！ 同样地，ImageData对象可以作为参数直接传入texImage2D()方法中！如： 123456let img = new ImageData( new Uint8ClampedArray(new Uint8Array(pixelList), width, height), width, height)gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img) 帧缓冲 帧缓冲可以看做等同于屏幕画面的帧，具有显示帧的一切绘制操作，除了不能直接显示。而通过将纹理缓冲绑定到帧缓冲上，可以直接利用webGL的绘制API（包括着色器）来绘制出想要的纹理，然后传递该纹理数据！ 详细步骤可以参考——利用FBO传送粒子数据 | snowdream。 天空盒纹理输入的一般流程 不同于2D纹理，天空盒（skybox）纹理实际上是一个立方体纹理，即包含六个正方形的2D纹理，而取样则是从立方体内部（中心点）通过射线方向来取样。 因此，天空盒纹理实际上就是由6张2D纹理组成的，因此输入的一般流程跟2D类似： 加载纹理资源或创建纹理资源； 创建纹理缓冲： 1let textureBuffer = gl.createBuffer() 激活相应的纹理通道： 1gl.activeTexture(gl.TEXTURE0 + textureID) 将纹理缓冲绑定到相应的纹理通道上： 1gl.bindTexture(gl.TEXTURE_CUBE_MAP, textureBuffer) 注意：这里的纹理类型为TEXTURE_CUBE_MAP！ 将纹理通道号传递给纹理取样器属性： 1gl.uniform1i(pos, textureID) // pos指的是纹理取样器属性的地址 绑定纹理数据： 123456gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[0]) // 右gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[1]) // 左gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[2]) // 上gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[3]) // 下gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[4]) // 前gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[5]) // 后 可以看到，天空盒纹理在绑定纹理数据的时候要分别绑定6个2D纹理数据，每个纹理数据分别对应立方体的一个面，所以千万注意不要把面的对应关系绑定错了！ TEXTURE_CUBE_MAP_POSITIVE_X TEXTURE_CUBE_MAP_NEGATIVE_X TEXTURE_CUBE_MAP_POSITIVE_Y TEXTURE_CUBE_MAP_NEGATIVE_Y TEXTURE_CUBE_MAP_POSITIVE_Z TEXTURE_CUBE_MAP_NEGATIVE_Z 设置纹理取样参数： 1234gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE) // 指定纹理S轴方向大小适应方式gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE) // 指定纹理T轴方向大小适应方式gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR) // 指定纹理缩小取样算法gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR) // 指定纹理放大取样算法 举的例子是比较常见的取样参数设置。 从上面流程可以看到，除了绑定纹理缓冲和绑定纹理数据和2D纹理略有不同之外，其它基本一致。 天空盒纹理资源的加载 纹理资源的来源和类型同上面一致；而加载方式也一样，只是要多注意多个不同资源加载时需要等待所有资源全都加载完后才进行数据传递等操作！ 以六张不同的纹理图片资源为例： 123456789101112131415161718192021222324let skybox = [ '1.png', '2.png', '3.png', '4.png', '5.png', '6.png'] // 6张纹理图片地址// 加载纹理图片function loadImages () &#123; let i = 0 let skyList = [] // 已加载成功的图片资源 skybox.forEach(url =&gt; &#123; let img = new Image() skyList.push(img) img.onload = () =&gt; &#123; i++ if (i === 6) &#123; // 所有纹理图片加载完后进行绘制 // 在这里进行加载完成后的操作 &#125; &#125; img.src = url &#125;)&#125; 上面这种方法是通过闭包的方式来判断图片是否已全部加载完成；当然，也可以将一个图片加载完成过程封装成一个Promise对象，然后利用Promise.all()方法来执行所有图片加载完成的回调。 其它类型的纹理资源也是同理的，不再赘述。 多个纹理输入 输入多个纹理资源，实际上每个纹理资源的加载和传递等步骤同单个纹理资源的是一样的，不同的是多个纹理资源需要额外注意纹理通道的分配和纹理缓冲的对应等问题。 注意事项 纹理通道的分配：因为每个着色器内的取样器连接的地址就是纹理通道，当多个纹理缓冲共用一个通道时，那么就相当于这个通道连接的所有取样器实际上都是共用一个纹理缓冲（最近更新数据那个纹理缓冲）；这显然是不可行的。因此需要给同一个webGL上下文内的所有纹理缓冲进行编号，可以设定一个类似于ID的自增属性（从0开始），在TEXTURE0常量上加上这个自增属性即可得到对应的纹理通道。 12345678let textureID = 0 // 纹理通道的编号// let textureBuffer = gl.createBuffer()gl.activeTexture(gl.TEXTURE0 + textureID)gl.bindTexture(gl.TEXTURE_2D)gl.uniform1i(pos, textureID)// ...textureID++ // 创建并绑定完相应的纹理缓冲后编号自增 TEXTURE0常量指的就是0号纹理通道的地址，后面的纹理通道地址都是在此基础上自增的；上面只是举了一个最简单的例子，实际上可以声明一个纹理资源信息的类，直接将得到纹理编号绑定到纹理资源上。 纹理缓冲的绑定：当需要对多个纹理资源中的某个纹理数据进行更新时，最好是不要重复再创建纹理缓冲，应该使用首次数据传递时用的那个缓冲对象；因此建议同上面类似，在第一次创建好纹理缓冲后将缓冲对象绑定到纹理资源信息上。 参考文档 WebGLRenderingContext.texImage2D() - Web API 接口参考 | MDN 纹理 - LearnOpenGL-CN ImageData() - Web API 接口参考 | MDN WebGL Using 2 or More Textures]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>webGL</tag>
        <tag>纹理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用FBO传送粒子数据]]></title>
    <url>%2Fpost%2Fwebgl-fbo-texture%2F</url>
    <content type="text"><![CDATA[前言 直接用webGL画出成千上万的粒子，并不像在canvas中造出相应数量的粒子“实例”，然后统一绘制那么简单；因为直接在webGL中绘制时，实际上是用着色器去绘制，而着色器的API有限，最重要的是数据传入着色器内的方式有限；但是另一方面由于着色器内可以进行并行运算，因此如果将原本在CPU中进行的计算转移到GPU内就会大幅提高运行效率，画面也就更流畅了。 而帧缓冲就可以解决大量数据传入的问题，不过用帧缓冲来传递数据本质上是利用帧缓冲作为数据写入介质，将数据通过帧缓冲保存到纹理上，然后将纹理传入相应的着色器；帧缓冲实际上的作用其实更加强大。 帧缓冲 帧缓冲（frame buffer）本质上就是一块内存，不过这块内存是可以直接被显示器使用然后进行显示的。 而对应到webGL，帧缓冲就是一种用来组织图像（帧）渲染所需的内存资源的数据结构；图像渲染所需的内存资源，指的就是颜色缓冲（coloc buffer）、深度缓冲（depth buffer）以及模板缓冲（stencil buffer）这三种缓冲。 不过这三种缓冲是作为附加对象（attachment）添加到帧缓冲里面的（我的理解是作为帧缓冲对象的一个属性），也就是这三种缓冲可以自由搭配添加到里面；比如只需要颜色缓冲，或者开启深度测试后加入深度缓冲等等。 在webGL中，绘制操作都是在一个默认的帧缓冲上面进行的，也只有这个帧缓冲才会被显示出来；而其他被创建的帧缓冲虽然也可以进行绘制等操作，但都是不可见的，也就是离屏（off-screen）的；所以可以利用创建的帧缓冲来进行离屏渲染等操作。 A framebuffer (frame buffer, or sometimes framestore) is a portion of random-access memory (RAM) containing a bitmap that drives a video display.[1] In WebGL, a framebuffer is a data structure that organizes the memory resources that are needed to render an image.[2] 在帧缓冲上绘制纹理 基本流程 在帧缓冲上绘制的原理就是：只要着色器程序绑定了某个帧缓冲，那么接下来的绘制操作都是在这个帧缓冲上面进行的。因此大致步骤如下； 创建帧缓冲； 1let frameBuffer = gl.createFramebuffer() 创建纹理对象； 1let frameTexture = gl.createTexture() 激活纹理通道； 1gl.activeTexture(gl.TEXTURE0 + textureID) // 激活对应的纹理 这一步对于着色器如果同时存在多个纹理传入时是必须的； 绑定纹理对象； 1gl.bindTexture(gl.TEXTURE_2D, frameTexture) 纹理数据初始化（很重要！）； 1gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null) // 先初始化纹理数据 如果不进行纹理数据的初始化，相当于纹理的尺寸和格式完全不知道；那么帧缓冲中绘制的信息也就传入不了；而且绘制时会有以下警告： 设置纹理参数； 1234gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE) // 指定纹理S轴方向大小适应方式gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE) // 指定纹理T轴方向大小适应方式gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR) // 指定纹理缩小取样算法gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR) // 指定纹理放大取样算法 大致就是设置纹理的取样算法和裁剪等等相关参数，也可以不设置，使用默认参数； 绑定帧缓冲； 1gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer) // 使用帧缓冲 将纹理对象绑定到帧缓冲的颜色缓冲上； 1gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, frameTexture, 0) // 将纹理绑定到帧缓冲中的颜色缓冲上 void gl.framebufferTexture2D(target, attachment, textarget, texture, level); framebufferTexture2D()函数的第二个参数attachment就是指定帧缓冲的哪个附加对象，即缓冲，在webGL1中，只有三个选项[3]： COLOR_ATTACHMENT0：对应帧缓冲中的颜色缓冲； DEPTH_ATTACHMENT：对应帧缓冲中的深度缓冲； STENCIL_ATTACHMENT：对应帧缓冲中的模板缓冲； 绘制纹理：一般纹理的绘制需要单独的着色器来进行，也就需要另建一个着色器程序，并用这个着色器程序开启帧缓冲，然后绘制；不过需要注意的是，同一上下文创建的不同着色器程序，其纹理通道是共用的（有待验证），因此分配通道编号的时候需要注意！ 如何准确地将数据绘制到纹理 纹理一般保存的就是颜色缓冲数据，而颜色缓冲本质上就是图像的像素信息；每个像素点实际上就是一个vec4类型的数据，颜色值的范围又在[0, 1]之间，所以数据值如果超出这个范围，那么就需要对数据进行处理了。 由于一个像素点最多存放4个数字（维度），因此当一个粒子的信息超过4个数字时就需要将信息进行分割，同时纹理空间也要进行相应地分割； 不需要分割数据时 当一个粒子信息小于等于4个维度时，那么可以直接按像素点的空间位置，连续的进行存储数据；若有剩余维度，可以补0或1； 对粒子数据进行遍历； 得到粒子数据在帧缓冲中的设备坐标位置（坐标范围为[-1, 1]），按顺序存入一个一维数组（空间顺序可以按照从左至右，从上至下）； 得到粒子数据在纹理中的纹理坐标位置（坐标范围为[0, 1]），按顺序存入一个一维数组； 处理粒子数据，按顺序存入一个一维数组； 注：为何存放至一维数组？因为一维数组可以写入ABO（Array Buffer Object，数组缓冲对象）中传入着色器内； 按照上述流程，可以得到三个一维数组；其中设备坐标数组和粒子数据数组用于在帧缓冲中逐像素点绘制纹理，得到纹理后传入需要的着色器程序；纹理坐标数组则用于在着色器内精准地获取对应粒子存放在纹理中的数据； 特别需要注意的是：虽然帧缓冲中绘制的图像就是纹理图像，但是纹理空间和设备空间的坐标系范围不一样！也就是说，同一个像素点在帧缓冲和在纹理中的坐标是不一样的！ 虽然坐标系有点不同，但是按理直接进行坐标系变换不就一样可以将设备坐标转化为同一像素点对应的纹理坐标吗？我一开始确实也是这么做的，但是实际变换后发现着色器展现的信息好像跟我写入纹理的不太一样；我发现着色器展现的数据好像是我写入纹理当中的一半，我左思右想没想到原因；唯一的原因可能就是纹理坐标不是精确的像素点位置，导致取样的时候进行了插值！而且“原本数据的一半”不难让人想到是原像素点和一个空像素点（即vec4(0.0, 0.0, 0.0, 0.0)）之间进行的插值，所以我将变换后得到的纹理坐标统一向右和向下偏移了0.5个像素位置，取样的数据竟然神奇的与我写入的一致了…… 不过目前还不清楚是我写入帧缓冲的像素点位置有问题还是帧缓冲转纹理数据普遍具有这样的问题。 需要数据分割时 当粒子数据超过4个维度时，可以将数据拆分几个不同的4维数据（一般可以按照数据的功能进行拆分，如：速度，大小，颜色信息等等），分区域进行数据填充；实际上仍然可以共用一套索引坐标（即纹理坐标），然后按规律找出其他区域的索引，这样就能够将数据维度扩充到4维以上了！ 只要确定好拆分的规则，以及解析其他区域索引的规则，剩下的就是一样的操作了。 这里有个案例可以参考：[WebGL] 百万流畅流体粒子 - 掘金 设置帧缓冲的尺寸 帧缓冲的默认尺寸实际上就是canvas的尺寸大小，但是为了节省内存和加快数据传输，可以将帧缓冲的尺寸调整成适应数据量长度的大小，以免造成过多的空间被闲置。 可以使用viewport()方法来设置帧缓冲的窗口大小： void gl.viewport(x, y, width, height); x：原点的x坐标（原点的位置是区域的左下角）；单位为像素（下面单位都一样）。 y：原点的y坐标； width：窗口宽度； height：窗口高度； 需要注意的是，在帧缓冲上绘制完纹理后，需要把窗口大小切回原来的尺寸（貌似窗口大小设置对所有的帧缓冲有效……）！ 参考文档 WebGL 渲染到纹理 WebGL 数据纹理 WebGL离屏渲染_逐片元操作_郭隆邦技术博客 WebGL Framebuffer【codepen】 https://wow.techbrood.com/fiddle/44877?vm=full javascript - How to work with framebuffers in webgl? - Stack Overflow【具体步骤参考】 帧缓冲 - LearnOpenGL-CN Framebuffer - Wikipedia ↩︎ Introduction to Computer Graphics, Section 7.4 – Framebuffers ↩︎ WebGLRenderingContext.framebufferTexture2D() - Web APIs | MDN ↩︎]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>webGL</tag>
        <tag>FBO</tag>
        <tag>纹理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS逐帧动画]]></title>
    <url>%2Fpost%2Fcss-frame-animation%2F</url>
    <content type="text"><![CDATA[前言 逐帧动画就有点像gif图，就是将动画的所有帧都提取出来，然后按顺序进行播放； 利用CSS3中的steps()函数以及background-position即可轻易的实现！ 基本步骤 将所有的帧图片按顺序打包成一个雪碧图（一排或一列，这样便于位置偏移）； 设置背景样式和相关的动画样式；举个例子： 假设每帧图片大小为40x60，总共10帧，打包成一排，那么得到的雪碧图大小就为400x60； 1234567891011121314@keyframes frame &#123; from &#123; background-position-x: 0px; &#125; to &#123; background-position-x: -360px; /* 对应最后一帧图片的偏移量 */ &#125;&#125;.demo &#123; background-image: url('xxx.png'); background-size: 400px 60px; animation: frame 1.2s steps(9) infinite;&#125; 注：steps()函数的第二个参数默认为end。为何是steps(9)而不是steps(10)？因为第一帧的背景位置对应的是第一张图，而最后一帧的背景位置对应的是最后一张图（即第10张图），这两者位置之间实际只差了9张图的宽度而已！所以只需要进行9次位移即可，步数不对则会使每帧得到图片位置发生偏差！ 注意事项 如果使用了rem布局，@keyframes和background-size的尺寸单位换成rem后，在移动端可能会出现抖动的情况；因为换成rem后基本上都带小数，由于各种浏览器对精度的取舍有所不同，所以导致得到背景位置并不是准确的，且每帧精度丢失后偏移的位置量并不是相同，最终每帧图片图片尺寸不一致，出现抖动。 解决办法可以参考：CSS技巧：逐帧动画抖动解决方案 | Aotu.io「凹凸实验室」 若动画图片使用的是二倍图，那么在background-size处应该使用的是一倍图的尺寸，而background-position则仍然使用二倍图的尺寸！因为background-size指定的是背景图呈现的大小（相当于&lt;img&gt;元素的宽高），而background-position的位置针对得是原始背景图。 相关知识 background-position是相对于background-origin指定的区域而言的； background-origin指定了元素背景图的区域（盒模型），而background-position则设置了背景图的初始位置。 相关文档 大厂 H5 开发实战手册 - 凹凸实验室 - 掘金小册]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>动效</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于background属性]]></title>
    <url>%2Fpost%2Fcss-background%2F</url>
    <content type="text"><![CDATA[前言 background属性实际上和font、animation、transition等属性一样，是一个缩写属性；实际上是由多个相关的属性组成的。 平时我们可能用的多就是填个背景色或者背景图地址上去，偶尔再调个背景图适应，也就没怎么关注过了。 不过把所有的background-*属性了解一下，会帮助我们更加的理解背景的本质，关键时候就不怕各种微调了。 background相关属性 background相关的属性有：background-clip、background-color、background-image、background-origin、background-position、background-repeat、background-size， background-attachment； 其中background-image、background-attachment、background-origin、background-position、background-repeat和background-size这几个属性只适用于背景图模式（即对背景色不起作用）； background-clip 这个属性是用来指定背景的显示区域。其可选值是&lt;box&gt;类型的，即盒模型。 content-box padding-box border-box；默认值。 text：仅适用于background-clip，目前（2020-2-3）兼容性不大好；大部分浏览器需要带前缀。 该属性使得背景只会在当前元素的文字区域显示，当然要使得文字背景能够显示，首先使得文字的颜色为透明才行： 12345.demo &#123; background-clip: text; -webkit-background-clip: text; color: transparent;&#125; background-color 很明显，这个属性是用来设置纯背景色的；可选值为&lt;color&gt;类型，默认值为transparent。 注意：渐变色不属于&lt;color&gt;类型的！是&lt;image&gt;类型的！！！ background-image 很明显，这属性则是用来设置背景图片的；可选值为&lt;image&gt;类型，默认值为none。此外，支持多个背景图同时设置，可用英文逗号,来分隔： 123.demo &#123; background-image: url("xxx.jpg"), url("sdf.png"), ...;&#125; 目前，&lt;image&gt;类型的数据来源主要有： url()函数引用的图片 渐变色 element()函数引用的DOM对象；该函数目前还未被广泛支持。 background-attachment 这个属性则是用来指定背景区域在滚动时的跟随方式；可选值有： fixed：滚动时，背景区域始终相对于视口不动； local：滚动时，背景区域始终跟随元素内容一起滚动； scroll：默认值；若在元素区域内发生滚动（元素自身出现滚动条），则背景区域始终相对于元素区域不动；若在元素区域外发生滚动，则背景区域跟随元素一起滚动； 这三种行为的具体差异可以参考MDN上的demo。 background-origin 这个属性是用来指定背景图初始位置（background-position）相对的区域。其可选值也是&lt;box&gt;类型的： content-box padding-box；默认值。 border-box 实际上就相当于给背景图初始位置指定了一个坐标系（坐标原点就是区域的左上角）。 background-position（★） 这个属性是用来设置背景图的初始位置，其坐标系区域就是background-origin指定的区域。其可选值为： &lt;length&gt;类型（可以为负值） 百分比（可以为负值） top：相当于0%（y方向）； bottom：相当于100%（y方向）； left：相当于0%（x方向）； right：相当于100%（x方向）； 默认值为0% 0%；当仅给定一个值时，第二个值为center；有两个值时，第一个值代表x方向的位置，第二个值代表y方向的位置。需要注意的是，随着值的类型不同，图片与初始位置的对齐规则有所不同！ 当值为长度类型时，意为背景图左上角距离区域左边界或上边界的长度。如：10px 10px代表背景图左上角距离区域左边界10px且距离区域上边界10px。 当值为百分比类型时，意为背景图对应的百分比位置对齐到区域的相应百分比的位置；如：50% 50%代表背景图的50% 50%位置（正中央）处于区域内的50% 50%这个点；0% 0%代表背景图的0% 0%位置（左上角）处于区域内的0% 0%这个点上。 注：之前总以为background-position是指定背景图左上角位于区域内的位置，不过后来一想不对劲，那为啥center center的位置又恰好是使背景图位于正中央，如果是左上角对齐那肯定就不是处于正中央了。所以我一直没想明白这个初始位置和图片的对齐规则是啥，查了很多地方都没找到，直到我找到了W3C的规范定义，终于才明白了。 为此，我专门制作了一个demo用来查看不同类型值的background-position与背景图的对齐方式，以验证上述说明。 A percentage X aligns the point X% across (for horizontal) or down (for vertical) the image with the point X% across (for horizontal) or down (for vertical) the element’s padding box. For example, with a value pair of ‘0% 0%’,the upper left corner of the image is aligned with the upper left corner of the padding box. A value pair of ‘100% 100%’ places the lower right corner of the image in the lower right corner of the padding box. With a value pair of ‘14% 84%’, the point 14% across and 84% down the image is to be placed at the point 14% across and 84% down the padding box. A length L aligns the top left corner of the image a distance L to the right of (for horizontal) or below (for vertical) the top left corner of the element’s padding box. For example, with a value pair of ‘2cm 1cm’, the upper left corner of the image is placed 2cm to the right and 1cm below the upper left corner of the padding box. —— Colors and backgrounds background-size 这个属性是用来设置背景图的尺寸。可选值有： contain：缩放图片（保持宽高比）使得图片正好能全部显示在区域内（有一边的长度正好充满相应的方向且图片没有超出区域？可能使区域有空白）。 cover：缩放图片（保持宽高比）使得图片正好能覆盖区域（图片可能超出区域外）。 宽高值：可以为&lt;length&gt;类型、百分比或auto关键字；当只有一个值时设置宽度，高度为auto；当有两个值时，第一个值为宽度，第二个值为高度。 当宽高值都为auto时： 图像如果有两个长度，则按这个尺寸。如果没有固有尺寸与固有比例，则按背景区的大小。如果没有固有尺寸但是有固有比例， 效果同 contain。如果有一个长度与比例，则由此长度与比例计算大小。如果有一个长度但是没有比例，则使用此长度与背景区相应的长度。[1] 当一个为auto另一个不是auto时： 如果图像有固有比例，则指定的长度使用指定值，未指定的长度由指定值与固有比例计算。如果图像没有固有比例，则指定的长度使用指定值，未指定的长度使用图像相应的固有长度，若没有固有长度，则使用背景区相应的长度。[1:1] 当两个都不是auto时，图片大小按照设置值显示。 默认值为auto auto。可以查看MDN上的demo来体会不同值的区别。 background-repeat 这个属性是用来指定背景图的重复填充规则（当区域内水平或竖直方向有空白时才能重复？）。可选值有： repeat：进行重复填充； repeat-x：在水平方向进行重复填充；相当于repeat no-repeat。 repeat-y：在竖直方向进行重复填充；相当于no-repeat repeat。 space：相应方向的填充不会裁剪图片，且必须有足够的空间容纳图片相应方向的长度（宽或高）才会进行重复填充；每个重复单元之间的间隔均匀分布（效果同space-between）。 round：当相应方向有足够的空间容纳一个图片时，之前的图片会被挤压以容纳下一个图片；反之，图片则会被拉伸。具体什么时候插入下一个图片什么时候拉伸取决于浏览器的算法实现。 no-repeat：不会重复填充； 当只给定一个值时，相当于水平和竖直方向的重复规则是一致的；有两个值时，第一个为水平重复规则，第二个为竖直重复规则。具体区别可以查看MDN的demo。 参考文档 - CSS（层叠样式表） | MDN background-attachment - CSS（层叠样式表） | MDN Colors and backgrounds background-size - CSS（层叠样式表） | MDN background-repeat - CSS（层叠样式表） | MDN background-size - CSS（层叠样式表） | MDN ↩︎ ↩︎]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于箭头函数]]></title>
    <url>%2Fpost%2Fjs-arrow-function%2F</url>
    <content type="text"><![CDATA[前言 箭头函数的设计目的就是替代函数表达式及匿名函数在某些场景的应用，使用箭头函数能够更加简洁明了地描述匿名函数和函数表达式！ 箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。 —— MDN 语法 总体语法是params =&gt; expression/statement； 箭头（=&gt;）的左侧是函数形参，而右侧则是函数语句或者表达式；需要注意的是左侧参数部分和箭头要保持在同一行，不能进行换行！如： 12(a, b) =&gt; &#123;&#125; 左侧形式 多个（两个及以上参数）或无参数时，用括号进行包裹： 1(a, b, ..., z) =&gt; &#123;&#125; 仅一个参数时可以不用括号包裹： 1a =&gt; &#123;&#125; 可以使用剩余参数（...），仅有一个参数且为剩余参数时必须加上括号： 12(a, ...other) =&gt; &#123;&#125;(...params) =&gt; &#123;&#125; 参数支持解构和默认值： 1([a, b] = [0, 1], c = 3) =&gt; a + b + c // 4 右侧形式 非对象字面量和一般表达式，不需要加大括号，作为返回值： 1234let t1 = () =&gt; 1t1() // 1let t2 = (a, b) =&gt; a + bt2(1, 2) // 3 对象字面量，需要加括号，作为返回值： 1234567let t = (name, age) =&gt; (&#123; name: name, age: age, hello: `hello, I'm $&#123;name&#125;.`&#125;)t('xxx', 10) // &#123; name: 'xxx', age: 10, hello: 'hello, I\'m xxx.' &#125; 函数语句，加大括号，可以return： 123456789let t1 = (a, b) =&gt; &#123; return a + b&#125;t1(1, 2) // 3let t2 = (a, b) =&gt; &#123; let c = a + b&#125;t2(1, 2) // undefined 箭头函数的特性 this的指向：箭头函数内this实际上指向的是声明时所处的最近一层作用域，因此如果将箭头函数作为某个对象的方法，那么this并不会指向该对象，而是该对象所处的作用域；如： 12345678let obj = &#123; a: 'inner a', b: () =&gt; &#123; return this.a &#125;&#125;console.log(obj.b()) // undefined 没有arguments对象； 不能作为构造函数，因此不能使用new关键字调用； 没有prototype属性； 参考文档 箭头函数 - JavaScript | MDN]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS渐变色]]></title>
    <url>%2Fpost%2Fcss-gradient%2F</url>
    <content type="text"><![CDATA[前言 CSS渐变色实际上是一种特殊的&lt;iamge&gt;类型，因此可以被用在任何可以使用&lt;image&gt;类型数据的属性中！而在CSS中，渐变有分为以下几种： 线性渐变：对应linear-gradient()函数。 径向渐变：对应radial-gradient()函数。 圆锥渐变：对应conic-gradient()函数。 重复渐变：对应repeating-linear-gradient()和repeating-radial-gradient()函数。 渐变色的特点就是沿着某一方向，从一种颜色逐渐变化到另一种颜色（两种或两种以上颜色）；关键就在于渐变颜色个数、对应的位置，空间上是如何变化的。 线性渐变 原理 线性渐变有两个关键因素： 渐变方向 渐变点：包括点的位置和颜色。 上图是MDN[1]给出的线性渐变完整定义图，可以看出由起点和终点来决定渐变的方向，然后渐变点位于起点和终点之间。 渐变方向 linear-gradient()有关渐变方向的设置并不像定义中的那样给定起点和终点位置，而是通过旋转角度来确定；默认旋转中心是区域中心点，从底部往上的方向为0deg方向，顺时针增加角度，然后再确定起点和终点的位置。 起点：通过区域左上角与渐变线做一条垂线，垂线与渐变线的交点就是起点。 终点：同理，通过区域右下角与渐变线做一条垂线，垂线与渐变线的交点就是终点。 (可以考虑做个动图，从0~360) 函数的第一个参数可以设置渐变方向（也就是旋转角度），可以不填，默认为从上往下（也就是180deg）；有以下几种设置语法： 弧度值：数字 + deg；或者数字 + turn，turn代表一圈，也就是1trun = 360deg。 关键字：to + top/right/bottom/left（或者组合）；即指定终点方向。进一步可以推出： to top = 0deg to right = 90deg to bottom = 180deg to left = 270deg to top right = 左下到右上（注意并不一定是45deg） 渐变点 渐变点的信息主要有： 位置：渐变点位于渐变线（轴）上的位置；可以是&lt;length&gt;类型数据或者%，百分比相对于渐变线的长度而言。 12345.demo &#123; width: 200px; height: 50px; background: linear-gradient(90deg, black, red 10%, blue 100px, black);&#125; 颜色：渐变点的颜色，用于进行渐变色的插值。 渐变中点位置：即两个渐变颜色的中间颜色处于两个渐变点之间的位置；单位为%，百分比相对于两个渐变点之间的长度。默认值为50%，即两个渐变点的中点上。 123456.demo1 &#123; background: linear-gradient(90deg, red, blue);&#125;.demo1 &#123; background: linear-gradient(90deg, red, 30%, blue);&#125; 如上图所示，渐变中点位置50%和30%的效果完全不一样，渐变中点的位置有种『重心』的感觉，因此改变渐变中点的位置可以使得两个渐变点之间的渐变偏向某一侧。 而在linear-gradient()函数中，渐变点信息的设置语法如下： 1color[ position] 位置可以不设置，此时渐变点的位置就等于前一个渐变点及后一个渐变点的中点位置；如： 123456789.a &#123; background: linear-gradient(90deg, white, red, green, blue, black);&#125;/* 等同于 */.a &#123; background: linear-gradient(90deg, white 0%, red 25%, green 50%, blue 75%, black 100%);&#125; 设置位置时，位置与颜色值之间用空格分开；如果连续两个渐变点的颜色都是一样的时候，可以将两个位置信息进行合并，如： 123456789.demo &#123; background: linear-gradient(90deg, black, red 40%, red 60%, black);&#125;/* 等同于 */.demo &#123; background: linear-gradient(90deg, black, red 40% 60%, black);&#125; 除此之外，如果第一个渐变点没有指定位置，则默认位置为0%；同理，如果最后一个渐变点没有指定位置，则默认位置为100%。不过，即便是第一个和最后一个渐变点设置了位置信息（不是0%和100%的时候），也会默认在第一个渐变点增加一个颜色值相同且位置为0%的渐变点，最后一个渐变点也同样，如： 123456789.demo &#123; background: linear-gradient(90deg, red 20%, blue 80%);&#125;/* 等同于 */.demo &#123; background: linear-gradient(90deg, red 0%, red 20%, blue 80%, blue 100%);&#125; By default, if there is no color with a 0% stop, the first color declared will be at that point. Similarly, the last color will continue to the 100% mark, or be at the 100% mark if no length has been declared on that last stop. [1:1] 由渐变的特点可知，至少需要两个渐变点信息，渐变点之间用英文逗号分隔！而渐变中点则需要设置在两个渐变点的信息之间，如： 1A_color A_position, xx%, B_color B_position 硬分界线（hard line） 当一个渐变点的位置和下一个渐变点的位置相同时（两个渐变点颜色不同），就会出现一条很明显的颜色分界线，此时就没有渐变的特点了，如： 123.demo &#123; background: linear-gradient(90deg, red 50%, blue 50%);&#125; 利用这种特性可以画出具有不同色块的渐变图案，如： 123.demo &#123; background: linear-gradient(90deg, red 20%, orange 20% 40%, yellow 40% 60%, green 60% 80%, blue 80%);&#125; 径向渐变 原理 径向渐变的原理同线性渐变的原理类似，只不过径向渐变的渐变方向是由中心点往外扩散的径向方向上。 径向渐变通过定义一个中心点，以及结束形状（ending shape，即各个径向方向的终点组成的闭合曲线），这个结束形状可以是椭圆或圆；然后由中心点往结束形状上任意一点就形成了一个径向，也就是一个渐变方向，这个方向也叫虚拟渐变射线（virtual gradient）；同样地，中心点的位置为0%，而结束形状上面的点的位置则为100%； 明白了径向渐变的原理后，实际上渐变点的设置跟线性渐变的设置是一样的，区别就在于中心点及结束形状的设置。 中心点 中心点的范围在区域内，可以使用%（百分比相对的是区域的宽高），也可以直接使用&lt;length&gt;类型的数据，可以在radial-gradient()函数中的第一个参数进行设置，不设置时默认为50% 50%（即区域中心位置），设置语法如下： radial-gradient(at x y, …); 如： 123.demo &#123; background: radial-gradient(at 20% 100px, red, blue);&#125; 结束形状（ending shape） 中心点的作用是作为渐变方向的起点，而结束形状的作用则是作为渐变方向的终点；而结束形状要用两个属性才能最终确定： 形状类型：形状类型目前只有圆（circle）和椭圆（ellipse），默认形状为ellipse。 123456.demo1 &#123; background: radial-gradient(circle at 20% 80px, red, blue);&#125;.demo2 &#123; background: radial-gradient(ellipse at 20% 80px, red, blue);&#125; 可以看到两种不同的形状的渐变效果也不一样。 半径：而半径的设置并不是直接指定两个半径来确定，而是由内置关键字来自动确定： closest-side：最近一侧，顾名思义就是按照中心点距离区域横向和纵向最近的一侧来分别计算横向和纵向的半径。当形状类型为circle时，半径取横向半径和纵向半径中较小的那个。 123.demo &#123; background: radial-gradient(circle closest-side at 20% 80px, red, blue);&#125; farthest-side：最远一侧，同理就是按照中心点距离区域横向和纵向最远的一侧来分别计算横向和纵向的半径。 closest-corner：最近一角；形状必须经过区域中离中心点最近的那个角的位置。 farthest-corner：最远一角（默认值）；形状必须经过区域中离中心点最远的那个角的位置。 123456789101112.demo1 &#123; background: radial-gradient(ellipse closest-side at 20% 80px, red, blue);&#125;.demo2 &#123; background: radial-gradient(ellipse farthest-side at 20% 80px, red, blue);&#125;.demo3 &#123; background: radial-gradient(ellipse closest-corner at 20% 80px, red, blue);&#125;.demo4 &#123; background: radial-gradient(ellipse farthest-corner at 20% 80px, red, blue);&#125; 上图可以很明显的看出这四种方法计算半径的区别； 圆锥渐变 原理 圆锥渐变的原理比较简单，就是指定一个中心点，然后区域内所有的点按照所在的角度（以y轴向上为0度）进行渐变的计算，而渐变点的位置也只能按照角度的范围进行指定，因此渐变方向就是弧度方向（顺时针）。 中心点 conic-gradient()中心点的语法设置与径向渐变的语法一样，通过at关键字进行设置，不过要注意的是at的设置要放在第一个参数的最后： 12background: conic-gradient(from 40deg at 20px 50%, red, blue); // 正确的写法background: conic-gradient(at 20px 50% from 40deg, red, blue); // 错误的写法 起点 圆锥渐变的起点跟其他渐变不一样，圆锥渐变的起点实际上只是指定从某个弧度开始（相当于指定0deg的轴）；不设置起点，默认就是0deg；通过from关键字来指定： 123.demo &#123; background: conic-gradient(from 40deg at 20px 50%, red, blue);&#125; 需要注意的是起点的单位只能是deg或turn，不能使用百分比（%）的语法！ 渐变点 渐变点的单位跟起点类似，不过支持百分比的单位，百分比相对的是从起点弧度开始然后顺时针计算（每100% = 360deg，因此可以实测可以超出100%）。 123.demo1 &#123; background: conic-gradient(from 20deg at 20px 50%, red 20%, blue 0.4turn, orange 180deg);&#125; 重复渐变 重复渐变的精髓就是：渐变的定义的部分并没有占渐变线或者渐变范围的全部，因此由这一部分定义好的渐变去重复的填充剩余的未定义部分。 很明显，重复渐变对应前面的渐变也就有三种； 重复线性渐变 repeating-linear-gradient() 重复径向渐变 repeating-radial-gradient() 重复圆锥渐变 repeating-conic-gradient() 相关扩展 关于渐变背景的动画或渐变效果 由于background-image属性本身就不被animation和transition所支持，因此没法直接使用animation和transition来进行渐变背景的动画效果，但是可以利用其它一些可以进行动画或过渡的属性来间接地进行渐变背景的动画效果，这个可以参考一下张鑫旭的文章：几种CSS渐变背景图片transtion动画方法 « 张鑫旭-鑫空间-鑫生活。 相关文档 使用 CSS 渐变 - Web 开发者指南 | MDN linear-gradient - CSS（层叠样式表） | MDN repeating-linear-gradient - CSS（层叠样式表） | MDN radial-gradient() - CSS: Cascading Style Sheets | MDN linear-gradient() - CSS: Cascading Style Sheets | MDN ↩︎ ↩︎]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>动效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS动画]]></title>
    <url>%2Fpost%2Fcss-animation%2F</url>
    <content type="text"><![CDATA[前言 总体上来说，animation的效果比transition的效果更加丰富和可控；有一些动画属性实际上是和渐变里面的效果是一致的； animation属性 同transition一样，animation属性也是一个缩写属性，实际上是由多个动画属性组成的： 动画属性 作用 取值 animation-name 动画的名称，用@keyframes进行声明 &lt;string&gt; animation-duration 动画的周期 单位为s或ms，整数部分为0时可以不写 &lt;time&gt; animation-delay 动画的延迟，可以为负值 负值可以使得动画在一开始就处于某一个中间状态 &lt;time&gt; animation-timing-function 动画的缓动函数 &lt;timing-function&gt; animation-iteration-count 动画运行次数，默认为1 &lt;number&gt; &lt;time&gt; infinite：一直播放 animation-direction 动画运行方向从起点到终点状态的方向 normal：每个周期结束后重置为初始状态； 默认值 reverse：每个周期都从结束状态开始，开始状态结束；周期结束后重置为结束状态；缓动函数也相应反转； alternate：往返运动；即每次周期结束后反转一次运动方向，第一次方向为normal； alternate-reverse：同alternate类似，只是第一次方向为reverse； animation-fill-mode 动画执行开始前和执行结束后的样式表现 none：开始前和结束后不会应用动画里面的样式，默认值 forwards：动画执行结束后会保持最后一帧的样式；要注意这里指的最后一帧并不一定是动画定义的最后一帧，因为animation-direction可以改变动画运行的方向！ backwards：同理，动画执行前会保持第一帧的样式； both：forwards + backwards； animation-play-state 动画的运行状态可以控制动画的暂停和运行 running：正在运行； paused：暂停运行； @keyframes @keyframes可以声明一个动画，该动画由多个关键帧组成，每个关键帧下是当前帧动画所表现的样式（这里的样式只能使用支持动画效果的属性）；声明格式如下： 123456789@keyframes animationName &#123; frame1 &#123; /* 当前帧样式 */ &#125; /* ... */ frameN &#123; /* 当前帧样式 */ &#125;&#125; 关键帧的名称是一个时间进度值，取值如下： from：相当于0%；动画周期的开始； to：相当于100%；动画周期的结束； %：百分比，百分比相对于一个动画周期的时间； 因此，动画实际上就是根据缓动函数以及关键帧的样式来进行插值（补帧），得到每一帧的样式。 animation事件 事件名称 触发时机 animationstart 动画开始执行的时候 animationend 动画执行结束的时候 animationiteration 动画每个周期（除了第一次）开始的时候 扩展 Web Animations API Web Animations API是专门用来控制DOM的animation效果的一套API，通过这套API 可以直接使用js动态来设置动画效果；不过目前这套API的兼容性比较差，只有element.animate()方法还能用用； 参考文档 Using CSS animations - CSS: Cascading Style Sheets | MDN Web Animations API - Web APIs | MDN]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>动效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS过渡效果（transition）]]></title>
    <url>%2Fpost%2Fcss-transition%2F</url>
    <content type="text"><![CDATA[前言 从效果上来看，过渡效果有点像css动画的简化版，即默认两个关键帧（初始和结束），有点像指定了@keyframes里面的from和to，其它的过渡属性跟动画属性的效果大都一致。这种效果实际上就是两个关键帧之间的补间动画。 transition属性 transition属性实际上是多个过渡属性的缩写，每个过渡属性负责一个特性，组合起来就能实现想要的过渡效果； transition-property：指定过渡的css属性；除了可以进行过渡效果的css属性名之外，还有两个关键字：all和none；all就是所有可以进行过渡效果的css属性都会开启过渡效果，none就是没有任何过渡效果。 transition-duration：指定过渡效果的周期；单位为s或ms，整数部分为0时可以不写，如：0.5s可以写成.5s。 transition-timing-function：过渡效果的缓动函数（easing function）；所谓的缓动函数就是使得当前值平滑地过渡到目标值的一类插值函数。 transition-delay：过渡效果的延迟时间；即触发过渡后等待的时间。 过渡属性的简写有很多种组合，不过最常见的就是： 1transition: property duration (timing-function) (delay); 除此之外，过渡属性可以一次定义多个过渡效果，用,隔开即可。 可以开启过渡效果的css属性 详细的所有可过渡/可动画的css属性可以参考MDN的整理： CSS animated properties - CSS（层叠样式表） | MDN 关于缓动函数（timing-function） 简单来说，缓动函数的横坐标t范围为[0, 1]，对应一个动画周期；而纵坐标y范围为[初始值, 目标值]，当前有时候为了表现一些“激烈”的动画效果，y的值可能会超出这个范围；事实上，css里面的内置缓动函数大多是三次贝塞尔曲线得到的。 Timing functions determine how intermediate values of the transition are calculated. Most timing functions can be specified by providing the graph of the corresponding function, as defined by four points defining a cubic bezier. —— Using CSS transitions - CSS: Cascading Style Sheets | MDN css中有一些内置的缓动函数： linear：顾名思义，这个就是单纯的线性函数，一条直线；等同于cubic-bezier(0.0, 0.0, 1.0, 1.0)。 ease-in：ease意为缓慢，in可以理解为“开始”；所以ease-in实际上可以理解为“开始比较缓慢”的函数，缓慢也就是斜率（变化率）比较低。等同于cubic-bezier(0.42, 0.0, 1.0, 1.0)。 ease-out：同理，out可以理解为“结束”；ease-out函数也就是“结束比较缓慢”的效果；等同于cubic-bezier(0.0, 0.0, 0.58, 1.0)。 ease-in-out：同理，开始和结束两端都比较缓慢；等同于cubic-bezier(0.42, 0.0, 0.58, 1.0)。 ease：从谷歌浏览器的缓动函数工具来看，这个函数具有“开始一小段变化较快，其后渐入缓慢”的特点；等同于cubic-bezier(0.25, 0.1, 0.25, 1.0)。 注：以上缓动函数的图片均来自MDN； 除了这些内置的缓动函数，timing-function还有一些强大的函数用来生成缓动函数； cubic-bezier(x1, y1, x2, y2)：顾名思义，这是一个三次贝塞尔曲线函数；起点为(0, 0)，终点为(1, 1)；而(x1, y1)和(x2, y2)分别是两个控制点，x取值范围为[0, 1]，y的取值范围可以超出[0, 1]，主要是用来模拟一些抖动效果； 谷歌浏览器自带贝塞尔曲线绘制工具，只需要在timing-function那里点击小图标就会弹出，然后拖拽两个控制点就ok了。 steps(n[, direction])：生成阶梯式变化的缓动函数；n为步数，direction为阶梯跳跃的方式，有以下选项： jump-start：等同于start；在t = 0处发生一次跳跃。 jump-end：等同于end；在t = 1处发生一次跳跃。 jump-both：同理，在t = 0和t = 1处都发生跳跃。 jump-none：默认值；在t = 0和t = 1处都不发生跳跃，即均分间距。 （上图源自MDN的示例） step-start(n)：等同于steps(n, jump-start)。 step-end(n)：等同于steps(n, jump-end)。 最后，https://easings.net/ 这个网站收录了很多常用的缓动函数，值得参考。 transition相关事件 事实上，DOM里面也配套了一些过渡专用的事件用来监听DOM元素的过渡状态： transitionrun：过渡效果被激活时触发，当有过渡延迟（transition-delay）时，会先于延迟结束触发； transitionstart：过渡效果开始时触发，当有延迟时，延迟结束后才会触发；即是指缓动函数开始时触发。 transitionend：过渡效果结束时触发； 注：以上事件需要注意浏览器的兼容性！关于transitionstart和transitionrun的触发时机可以查看MDN上面的示例，一目了然。 参考文档 transition - CSS（层叠样式表） | MDN - CSS: Cascading Style Sheets | MDN Using CSS transitions - CSS: Cascading Style Sheets | MDN HTMLElement: transitionrun event - Web APIs | MDN]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>动效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Event对象与自定义事件]]></title>
    <url>%2Fpost%2Fjs-event-and-customed-js-event%2F</url>
    <content type="text"><![CDATA[事件对象 当为DOM元素添加一些事件的回调函数后，事件被触发时，会传给回调函数一个Event对象作为第一个参数；而这个Event对象包含关于触发的事件的一些信息及处理方法。 常用属性 bubbles： Boolean（只读）， 表明事件是否冒泡； cancelable： Boolean （只读）， 表明是否可以取消事件的默认行为； currentTarget： Element （只读），事件处理程序当前正在处理事件的那个元素； defaultPrevented： Boolean （只读）， 为true表示已经调用了preventDefault()（DOM3级事件中新增） detail： Integer （只读），与事件相关的细节信息； eventPhase： Integer （只读），调用事件处理程序的阶段： 1表示捕获阶段，2表示『处于目标』（即currentTarget与target一致时），3表示冒泡阶段； target： Element （只读），事件的目标； type： String （只读），被触发的事件的类型； view： AbstractView（只读），与事件关联的抽象视图。等同于发生事件的window对象； 整理自《JavaScript 高级程序设计》 常用方法 preventDefault()：Function（只读），取消事件的默认行为。如果cancelable是true，则可以使用这个方法； stopImmediatePropagation()：Function（只读），取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用（DOM3级事件中新增） stopPropagation()：Function（只读），取消事件的进一步捕获或冒泡。如果bubbles为true，则可以使用这个方法； 整理自《JavaScript 高级程序设计》 DOM事件流 “DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。 构建自定义事件 构建一个自定义事件的关键就是： 拦截原生事件，阻断原事件传播：利用addEventlistener的第三个参数，可以在某父级DOM上事件传播的捕获阶段触发回调函数，然后使用stopPropagation方法阻止原事件的进一步传递； 构造自定义Event对象：利用Event构造函数构造一个自定义属性的事件对象； 派发自定义事件：使用EventTarget对象自带的dispatchEvent方法进行事件对象的派发； addEventlistener方法 1target.addEventListener(type, listener[, useCapture]) addEventListener可以为DOM绑定一个DOM2级事件的监听处理，一般第三个参数useCapture很少使用，其作用就是该事件是否在捕获阶段触发，默认为false，因此设置为true时可在捕获阶段触发监听处理函数！ 创建Event对象 event = new Event(typeArg, eventInit); 通过Event构造函数可以创建一个自定义属性的Event对象，相当于回调函数接收的第一个参数； typeArg：事件的名称； eventInit：事件的设置选项，为一个对象，该对象可以使用以下属性： bubbles：Boolean类型，表示该事件是否可以冒泡，默认值为false； cancelable：Boolean类型，表示该事件是否可以使用preventDefault()方法进行取消，默认为false； composed：Boolean类型，事件是否会在影子DOM根节点（shadow root DOM）之外触发侦听器，默认为false； dispatchEvent() EventTarget.dispatchEvent(event) EventTarget：一般为触发事件时Event对象的target属性所指向的DOM节点； event：Event对象； 使用该方法就相当于某个DOM节点触发了某个event事件； 案例：自定义tap事件 由于现在的移动端设备的屏幕多是触摸屏，因此H5针对触摸屏特别制定了适用于触摸设备的TouchEvent事件规范，这使得触摸屏的点击事件变得更加灵敏了； 为啥使用click事件就不灵敏了？由于一些历史原因，现在的移动端浏览器对于click事件和touch event事件的执行顺序遵守如下规则：touchstart-&gt;touchmove-&gt;touchend-&gt;wait 300ms-&gt;click；没错，click要在所有的touch event执行完后延迟300ms再执行； 因此，如果在移动端使用click事件在点击时会出现一个很明显的延迟，对于用户体验来说是不利；其中一个解决办法就是利用TouchEvent封装一个tap点触事件，消除300ms的延迟： 12345678910111213141516171819202122232425function initTap(eventType = 'tap') &#123; let isTap = false document.body.addEventListener('touchstart', e =&gt; &#123; isTap = true &#125;, true) document.body.addEventListener('touchmove', e =&gt; &#123; isTap = false &#125;, true) document.body.addEventListener('touchend', e =&gt; &#123; if(isTap) &#123; e.stopPropagation() // 阻止原事件继续传递 let tapEvent = new Event(eventType, &#123; bubbles: true, // 可以冒泡 cancelable: false // 没有默认行为，不可取消默认行为 &#125;) // 构建自定义tap事件（点触） tapEvent.touches = e.touches // 保留touchEvent的触点信息 tapEvent.targetTouches = e.targetTouches tapEvent.changedTouches = e.changedTouches e.target.dispatchEvent(tapEvent) // 向target派发事件 &#125; &#125;, true)&#125; 上面给出的initTap方法实际上是在body元素上（也就是全局）劫持TouchEvent事件，只要判断不是touchmove事件，那么在touchend事件阶段就会在target对象上派发一个自定义的tap事件，即相当于在touchend事件后马上触发，因此也就没有click事件的300ms延迟，反应特别灵敏；这种方法可以直接在Vue中利用v-on/@进行监听（如@tap=&quot;xxx&quot;），十分方便！ 而且TouchEvent在移动端的兼容性非常好，可以大胆的使用： 参考文档 Event() | MDN 《JavaScript 高级程序设计》 EventTarget.dispatchEvent() | MDN TouchEvent | MDN EventTarget.addEventListener() | MDN 移动端Click300毫秒点击延迟的来龙去脉(转) - 低调的大白兔 - 博客园 https://github.com/ustbhuangyi/better-scroll/blob/2e9513bd6d0bb1a1fd2a17af172ef600c70dadfd/src/util/dom.js#L137]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>DOM</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音频播放器的制作与WebAudio API]]></title>
    <url>%2Fpost%2Fmusic-player-and-webaudio%2F</url>
    <content type="text"><![CDATA[前言 最近一直在制作一个音乐web app的练习项目，播放器的功能当然是音乐类app的基础；除此之外，个人对于音乐可视化也比较感兴趣，一旦遇上音乐就想着可视化；然而这些功能都离不开HTML5推出的audio元素以及强大的WebAudio API。 audio元素 audio元素是H5新增的多媒体标签，通过它就可以轻松的用来进行音频播放等一些操作； 常用属性 src：音频地址； autoplay：布尔属性，默认值为false；当设置时，音频会马上播放，而非等到音频加载完后再播放； loop：布尔属性，默认值为false；设置时音频播放完后会自动循环播放； controls：布尔属性，默认值为false；设置时浏览器会给audio元素提供一个默认的控制面板（UI，可以进行播放，暂停等操作）； preload：用来提示浏览器以什么方式来加载音频信息，有auto、none和metadata三个选项，当设置值为空字符串时等同于auto；没有规定的默认值，所以不同浏览器的默认值可能不一样；autoplay属性的优先级大于preload！ none：示意用户可能不会播放该音频，或者服务器希望节省带宽；换句话说，该音频不会被缓存； metadata：示意即使用户可能不会播放该音频，但获取元数据 (例如音频长度) 还是有必要的。 auto：示意用户可能会播放音频；换句话说，如果有必要，整个音频都将被加载，即使用户不期望使用。 muted：布尔属性，默认为false；设置时代表音频是静音的； 常用的DOM属性 paused：音频元素是否处于暂停状态（trueorfalse），缓冲状态并不算暂停状态！ currentTime：音频元素的当前播放时间，单位为秒（浮点型）；设置该属性可以调整音频的当前播放时间！ duration：音频元素的总时间长度，单位为秒；没有音频文件时，值为0！ 常用方法 play()：播放音频； pause()：暂停播放； 播放器的制作 虽说audio元素可以使用自带的控制器进行操作，但是一般为了融合进产品，当然会重新设计；所以一般是隐藏audio元素，利用js获取其DOM，然后使用自带的方法和属性进行控制； 播放/暂停/停止：这些利用play()和pause()方法即可实现； 进度条显示：利用currentTime和duration属性即可获知当前播放进度的百分比； 进度跳转：点击进度条元素时获取其event.offsetX及其容器宽度即可知道点击位置对应的进度百分比，然后设置currentTime即可； 123function timePoint(e) &#123; // 歌曲进度条跳转 $player.currentTime = $player.duration * e.offsetX / barWidth&#125; 上一首/下一首/其它切换操作：直接设置src即可； 音频可视化 音频可视化一般是获取音频频率进行相应转换，形成与音乐同步的视觉信息；而要获取频率信息就需要借助WebAudio API的方法了。 上面是来自MDN的一张图，很好地表达了Audio context与Audio node之间的关系，其中Inputs就是音频文件或信息，而Destination则是播放设备；因此，一个Audio context的作用就是引入音源，连接中间节点（AudioNode，可以多个进行串联，有不同类型的AudioNode），最后输出到播放设备； 获取频率信息 创建上下文： 12let AudioContext = window.AudioContext || window.webkitAudioContextlet ctx = new AudioContext() 创建音源： 1let source = ctx.createMediaElementSource(this.$player) createMediaElementSource只是创建音源的其中一种方法，该方法接受一个audio元素或video元素作为音源对象，得到一个MediaElementAudioSourceNode对象（属于AudioNode节点）； 创建分析器节点： 1let analyser = ctx.createAnalyser() createAnalyser方法可以创建一个AnalyserNode，而AnalyserNode可以实时获取音频的频率相关信息（前提是连接了音源节点）； 连接音源、分析器和播放设备： 12source.connect(analyser)analyser.connect(ctx.destination) 将音源与分析器连接后，分析器就可以工作了；destination属性是默认的音频渲染设备，连接destination后就能正常输出音频信息； 以上就是获取音频频率信息的最直接方法，其实可以在音源和destination之间添加多个不同的AudioNode，玩出更多的花样。 AnalyserNode 分析器节点拥有丰富的频率信息，是可视化的主要信息来源；常用的属性和方法有： fftSize：音频频域的FFT样本窗口大小； fftSize 属性的值必须是从32到32768范围内的2的非零幂； 其默认值为2048. frequencyBinCount：数值为fftSize属性值的一半，代表可用于可视化的频率信息数量； getByteFrequencyData(arr)：获取当前频率信息至Uint8Array类型数组中；Uint8Array类型数组中元素值为0~255之间的整数； getFloatFrequencyData(arr)：获取当前频率信息至Float32Array类型数组中；Float32Array类型数组中元素值为32位浮点数，因此方法获取的数据具有更高的精度； 可视化 当成功创建音源和分析器并进行连接后，可以利用AnalyserNode的方法和属性获取实时频率信息，进而进行绘制： 12let arr = new Uint8Array(analyser.frequencyBinCount)analyser.getByteFrequencyData(arr) 以上步骤就能获取实时的音频频率数据了，只需在requestAnimationFrame中不停地利用getByteFrequencyData等方法获取实时数据就能实现各种各样的音乐可视化，数据有了，后面就靠创意了。 移动端兼容性问题 目前使用过程中发现，在移动端的某些浏览器使用getByteFrequencyData获取数据时会出现数据全为0的情况，找了很久也没找到解决办法，可能是某些浏览器内核对于WebAudio API的支持程度不够吧。 参考文档 audio | MDN HTMLMediaElement | MDN AudioContext | MDN AnalyserNode | MDN 媒体相关事件 | MDN]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>H5</tag>
        <tag>WebAudio</tag>
        <tag>visualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何实现歌词同步显示]]></title>
    <url>%2Fpost%2Fsync-lyric%2F</url>
    <content type="text"><![CDATA[前言 最近在做一个仿网易云音乐的web app，其中需要全屏显示同步歌词，然后查了些资料；歌词同步显示最主要的部分就是歌词文件的解析以及随时间轴同步滚动显示。 解析歌词文件 歌词文件 目前最流行的歌词文件就是.lrc形式的，每一行对应一句歌词信息，文本格式有两种： ① 1[mm:ss.ms] lyric content ② 1[mm:ss.ms][mm:ss.ms] lyric content 其中第一种格式代表该句歌词以及其对应的时间轴起点，而第二种格式则是该句歌词对应多个时间轴的起点； 解析方法 根据.lrc文件格式的特性，可以按照如下步骤进行解析： 按行拆分文本，逐行解析； 1let arr = lyric.split('\n') // lyric为.lrc歌词文本 使用正则表达式对每行歌词进行分析匹配；若只有一个时间轴起点则添加一个歌词信息，有多个时间轴起点则添加相应数量的歌词信息； 1/\]\[/.test(line) // 判断某行歌词是否有多个时间轴起点 歌词信息结构如下： 1234lyricInfo = &#123; time: xx.yy, // （某行）歌词的时间轴起点，单位为秒 content: 'str' // （某行）歌词内容&#125; 歌词同步显示 要想使歌词随当前播放的进度同步显示，首先要知道当前歌曲播放的进度，以及在播放进度更新时找到对应时间段的歌词。 timeupdate事件 可以利用WebAudio API中的timeupdate事件来监听audio元素，该事件在audio元素的currentTime属性改变时触发，而currentTime属性即当前播放的进度，单位为秒；因此可以在timeupdate事件中查找当前进度对应的歌词信息进行同步显示。 查找对应歌词 将歌词信息数组按照时间顺序（升序）进行排列； 1lyricArr.sort((a, b) =&gt; a.time - b.time) 根据当前播放时间（currentTime属性值），利用二分法（有序查找）在歌词信息数组查找不大于当前播放时间且差值最小的时间轴起点，该时间轴对应的歌词即当前播放的歌词。 垂直居中显示 一般音乐app的全屏歌词都是可以上下滚动，且当前播放歌词高亮垂直居中显示，歌词切换时有滚动过渡效果（也许是跳到了下一句，也许是歌曲进度人为改变时）； 高亮只需要给当前播放歌词那一行加个类就可以了，主要是高亮的歌词需要垂直居中（在上下可以滚动的状态下）显示；我的做法是将每行歌词放入一个滚动容器中，然后在timeupdate事件中获取高亮歌词那一行元素在容器中的offsetTop设置容器的scrollTop，使得当前行正好滚到垂直中间的位置。 参考文档 媒体相关事件 | MDN 论HTML5 Audio 标签歌词同步的实现]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>H5</tag>
        <tag>WebAudio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于rem布局]]></title>
    <url>%2Fpost%2Frem-layout%2F</url>
    <content type="text"><![CDATA[前言 由于移动端的设备存在许多分辨率的差异，所以一般的面向移动端的网站都不会直接按照某一固定分辨率的屏幕进行设计，而是尽可能的适配所有分辨率的移动端设备。除了响应式布局之外，最近听闻基于rem的等比例适配布局比较流行。还有就是最近面试的时候连续被问到rem是什么，我竟哑口无言，简直惭愧，看来对于移动端这一块了解的确实是太少了，得好好补一补。 等比例适配布局 等比例，顾名思义就是尽管随着设备屏幕分辨率大小的不同页面元素的大小也不同，但是所有分辨率下展示的页面元素之间宽度的比例关系没有发生改变；比如：在一个设备宽度为480px的屏幕下，a元素的宽度为480px，b元素的宽度为240px，而在另一个设备宽度为320px的屏幕下，a元素的宽度为320px，b元素的宽度为160px，这样a元素与b元素之间宽度大小的比例没有变化，且正比于设备宽度。 相关概念 物理像素： 一个物理像素是显示器(手机屏幕)上最小的物理显示单元，在操作系统的调度下，每一个设备像素都有自己的颜色值和亮度值。 设备独立像素（density-independent pixel）： 设备独立像素(也叫密度无关像素)，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css 像素)，然后由相关系统转换为物理像素。 屏幕分辨率：也叫物理像素分辨率，即显示器拥有的物理像素的个数。比如：1080x1920表示该显示器的水平方向有1080个物理像素，而竖直方向有1920个物理像素； 设备独立分辨率：即显示器拥有的设备独立像素的个数（水平，竖直方向）。由于css中的像素为设备独立像素，所以获取的元素的宽高使用的像素也是设备独立像素，比如window.innerWidth实际上获取的是视窗的设备独立像素宽度，而非物理像素的宽度！ 设备像素比（device pixel ratio）：简称dpr； 1设备像素比 = 物理像素个数 / 设备独立像素个数 （水平或竖直方向） 比如：某手机的屏幕分辨率为1080x1920，而其设备独立分辨率为360x640，因此该手机的dpr = 3。dpr = 3的意思就是css中设置的1px实际上对应了3 * 3个物理像素！ 位图像素： 一个位图像素是栅格图像(如：png, jpg, gif 等)最小的数据单元。每一个位图像素都包含着一些自身的显示信息(如：显示位置，颜色值，透明度等)。 rem rem是css3新增的一种相对单位，即root em；而1 em指的就是当前元素的font-size值，因此1 rem就指的是根元素html的font-size值。比如：html元素的font-size: 16px;，那么1 rem就等于16px，同理0.5 rem就是8px。 rem与等比例适配布局 由于rem针对的是html元素，那么只需要将html元素的font-size值与设备屏幕的宽度进行正相关，然后其他页面都使用rem来设置宽度，那么就能很轻易地实现不同大小设备之间的等比例适配布局。 1234567/*** 用来根据当前设备宽度来调整html元素的font-size* @param n: 默认设计稿宽度对应的rem数，即设备宽度被分割成个rem*/function rem(n = 10)&#123; document.documentElement.style.fontSize = document.documentElement.clientWidth / n + 'px'&#125; 一些问题 移动端兼容性 由于移动端（主要是安卓）的浏览器app数量众多，内核又各不相同，因此多少会出现一些意料之外的事情； 目前我发现的兼容性问题主要是某些浏览器对于所有元素的最小font-size值有限制（比如夸克浏览器设置的最小font-size值为8px），当html设置的font-size小于浏览器的最小值时，浏览器默认会使用font-size最小值进行替换，因此会造成其它依赖rem的元素完全变样；除此之外，某些浏览器还有小数点精度的问题，即当设置的font-size值过小，而其它元素的rem值比较大时，小数点后的精度就变得十分敏感了，因此会出现元素尺寸与设计图相差一定px的情况（小米自带浏览器就会出现，当font-size小于1px时，有些元素的尺寸就会出现偏差）； 因此，最好将html的font-size值设置比较大一点；比如可以将设备宽度划分为10rem，使得html的font-size值在不同分辨率的设备之间都保持在一个较大的数字，然后利用scss自动计算元素的rem值即可。 图片模糊 由于&lt;img&gt;元素是位图，因此如果设备的dpr &gt; 1时且设计图的尺寸是按照一倍屏（dpr = 1）进行设计时，图片中一个像素点信息要分到设备中的多个像素点，就相当于把图片放大了；一般图片放大都是利用临近插值算法模拟多余的像素点信息，所以图片自然就模糊了。 解决的办法就是按照二倍屏（dpr = 2）进行设计，因此图片资源尺寸被放大了一倍，在一倍屏和二倍屏上显示自然不会有模糊问题；还有一种办法就是准备多种尺寸的图片资源，利用js检测设备的dpr，然后选择使用对应尺寸的图片。 参考文档 rem布局解析 - 掘金 《css世界》 —— 8.1.2 理解 font-size 与 ex、 em 和 rem 的关系 【原创】移动端高清、多屏适配方案 - 移动端H5 - 前端乱炖]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再论闭包]]></title>
    <url>%2Fpost%2Fjs-closure-again%2F</url>
    <content type="text"><![CDATA[前言 长久以来，我对于js中的闭包的准确定义有所疑惑，我一直在寻找用于准确定义闭包的那个宾语，即『闭包是什么』中的那个『什么』。不过最近看过《你不知道的 JavaScript （上卷）》这本书之后算是解答了我的疑惑，为什么我会被困惑这么久（我相信有不少人也感到疑惑），可能是由于闭包平时使用的场景（显式使用）以及对js的作用域相关机制的不了解造成的。 重新认识闭包 闭包的定义 首先给出我所理解的闭包的『精准』定义： 闭包就是函数在执行时对其定义时的词法作用域的引用。 也就是说由于闭包的存在，可以使得函数无论在何处执行都可以访问定义时的词法作用域内的变量（包括函数，毕竟函数也是一种声明）。 闭包的显式触发条件 为啥要说显式的触发（或者说是『激活』闭包），因为一般隐式的闭包看起来好像没啥用，也就很容易被忽略： 1234567891011function foo() &#123; let a = 123 function bar() &#123; // --&gt;实际上bar函数此时已经具备闭包 console.log(a) &#125; bar() // --&gt; 但是bar函数执行的地方却位于定义时的词法作用域内，闭包与当前词法作用域实际上是一致的&#125;foo() 上面的例子由于bar函数在执行的时候位于foo函数之内，也就是其定义时的词法作用域之内，闭包的范围就刚好与当前词法作用域是一致的，所以此时闭包的作用可以忽略不计（此时的闭包究竟存在与否无法确定，我姑且称之为『隐式的闭包』）。 因此，要想发挥闭包的作用需要两个条件： 该函数要在其定义时的词法作用域之外执行； 该函数作用域内使用了其定义时的词法作用域的其他变量（其他变量指的是自身作用域外的变量） 闭包与js垃圾收集机制 js中最常用的垃圾收集方法就是标记清除（mark-and-sweep）： 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 ——《JavaScript高级程序设计》 也就是说一个变量在离开其声明的作用域时且没有被引用时会被垃圾收集器标记，然后被回收清除内存无法被访问。然而，由于闭包引用了其定义时的词法作用域，所以即便在离开作用域后该词法作用域内的变量仍然属于被引用的状态，因此这些变量都没有被回收，也就能够通过闭包进行访问！ 常见的闭包 实际上，我们在写代码的时候可能无意中使用了闭包，但我们并非有意的去使用，所以就忽略了一些常见的闭包。 回调函数 回调函数由于并非立即执行，所以很容易在定义时的词法作用域外进行执行： 1234567function say(text) &#123; setTimeout(function foo() &#123; console.log(text) &#125;, 1000)&#125;say('hello') 当在回调函数中使用一些词法作用域内的局部变量时，闭包就出现了，尽管有时我们并没有意识到这一点。 for循环 12345678910111213// code 1for(var i = 0; i &lt; 5; i++) &#123; setTimeout(function foo() &#123; console.log(i) &#125;, 0)&#125;// code 2for(let i = 0; i &lt; 5; i++) &#123; setTimeout(function foo() &#123; console.log(i) &#125;, 0)&#125; 这两段代码经常出现在前端的面试中，虽然看似代码仅有一处细微差距，但是实际上却产生了完全不同的结果，背后隐藏着一些容易被忽视的原因： var有变量提升，而let没有变量提升；而var的变量提升会『穿透』块级作用域，也就是会提升到for语句的外层作用域！ 变量在for循环过程中不止被声明一次，每次迭代都会声明！也就是说每次迭代都会创建一个新的块级作用域，但是块级作用域对于var声明不起作用，但是let声明会重新绑定到每个块级作用域。 根据以上的原因可以得知第一段代码中所有setTimeout中的回调函数共用了一个全局变量i，而第二段代码中所有回调函数则分别调用了不同的局部变量i！ 模块机制 js中的模块一般都是通过暴露一个对象来传递模块中的方法或变量，这里的方法就可以使用随意的使用模块内的任何变量，而没有暴露出去的变量和方法就可以看成是『私有』的。 12345678910111213141516171819202122232425function Moudle1() &#123; let name = 'abc' function sayHello() &#123; console.log(`Hello! My name is $&#123;name&#125;`) &#125; function changeName(val) &#123; name = val &#125; return &#123; sayHello, changeName &#125;&#125;let m1 = Moudle1()m1.sayHello() // Hello! My name is abcm1.changeName('ok')m1.sayHello() // Hello! My name is oklet m2 = Moudle1()m2.sayHello() // Hello! My name is abc 类似这种原理暴露出来的模块方法实际上都利用了闭包，闭包引用了整个模块的词法作用域，因此可以访问模块内的所有变量。从上面例子看到即使改变了闭包内的变量值也不会影响到原词法作用域内的变量，大概是因为函数每次执行的时候都是重新创建作用域的？ 一段代码 12345678910111213function foo() &#123; let a = 1 function bar() &#123; console.log(a, b) &#125; bar() let b = 2&#125;foo() 参考文档 《你不知道的 JavaScript（上卷）》 —— 第5章：作用域闭包 《JavaScript 高级程序设计（第3版）》 —— 4.3：垃圾收集]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于js中的作用域与变量]]></title>
    <url>%2Fpost%2Fjs-scope-variable%2F</url>
    <content type="text"><![CDATA[前言 说实话，虽然一直知道js中有全局作用域、函数作用域和块级作用域这几种作用域，但一直说不清到底怎样才算是块级作用域以及作用域到底用来干啥的。还有就是虽然知道var声明和let、const声明的一些表现差异，但根本无法解释这种差异性为何发生以及变量提升的准确定义是什么。总而言之，在实际使用中将js与浏览器绑定得过于紧密，而忽略了js作为一种独立的编程语言的基本特性了！ 作用域 作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。 LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。——《你不知道的js（上卷）》 作用域是在js编译过阶段中产生的，然后在运行阶段发挥作用的。而js的编译过程发生在运行前不久（尽管编译时间很短，且编译完后立即执行，还是属于先编译然后执行，而非实时运行的），编译过程大概经历分词 → 解析 → 代码生成这几个阶段： 分词：将代码字符串划分成具有js语法意义的代码块（词法单元）； 解析：将分词过程中产生的代码块列表转化成具有js程序语法结构的树（抽象语法树AST）； 代码生成：将AST转化成可执行代码； 函数作用域：即函数在声明时的词法作用域。 块级作用域：一对大括号内（不包括function声明后的大括号）的词法作用域，或标记块声明后的大括号内的词法作用域。比如： 12345678910111213141516171819202122232425&#123; statement&#125;if(...)&#123; &#125;else&#123; &#125;for(...;...;...)&#123; &#125;while(...)&#123; &#125;switch(...)&#123; &#125;label: &#123; ...&#125; 变量提升与函数提升 所谓的提升指的就是在代码编译阶段将声明语法单独提前到该作用域的顶部，也就是说每个作用域内都有提升，但是根据声明类型和作用域类型的不同提升的方式也会有所区别。 变量提升 虽然在一般的变量声明赋值操作中，我们觉得好像写的就只有一条语句，然而编译器并不是这么认为，编译器会将诸如var a = 1这样的语句拆分成两部分理解：var a（声明语句）和a = 1（赋值语句）；然后在编译的时候将声明语句单独提升到该作用域的顶部，而赋值语句则留在原地不动（当然，如果仅仅只有变量声明，那就相当于没有赋值）！ 举个例子： 123a = 1var aconsole.log(a) // 1 在不了解变量提升之前，大多数人都会觉得打印出来的a应该是undefined（我之前就是这么觉得的╥﹏╥），然而在编译的时候有了变量提升，实际上执行的代码是这样的： 123var a // ←变量声明提升到作用域顶部了a = 1console.log(a) // 1 函数作用域内也一样： 1234567891011// 编译前function foo()&#123; console.log(a) var a = 123&#125;// 编译后function foo()&#123; var a // ←变量声明提升到该函数作用域顶部了 console.log(a) a = 123 // 赋值语句则留在原地！&#125; 然而并非所有的变量声明都有提升，ES6新增的let和const声明就不会有提升： 12console.log(a) // ReferenceError: a is not definedlet a = 1 除此之外，var声明会自动忽略块级作用域，也就是说如果var声明所在的作用域为块级作用域时会自动向上找到最近的非块级作用域（函数作用域或全局作用域），再进行提升；最著名的例子就是这个： 12345678910for(var i = 0; i &lt; 10; i++)&#123; ...&#125;console.log(i) // 10// 因为实际上编译后时是这样：var i // ←直接跳过块级作用域，提升到上一层作用域for(i = 0; i &lt; 10; i++)&#123; ...&#125;console.log(i) 函数提升 实际上函数声明没有赋值这一说法，因此是整体提升到作用域的顶部的： 1234567891011foo()function foo()&#123; ...&#125;// 编译后：function foo()&#123; ...&#125; // ←整体提升到顶部foo() 然而如果是函数表达式，就不存在函数提升了！如果是将函数表达式作为值进行变量赋值，实际上也只是变量提升罢了： 12345678910111213foo() // TypeError: foo is not a functionvar foo = function()&#123; ...&#125;// 编译后：var foo // 只是普通的变量提升而已foo() // 实际上此时foo等于undefined，所以执行会报错foo = function()&#123; ...&#125; 提升的优先级 当var与function在同一作用域下出现重复声明（即标识符一样）的情况下，优先进行函数提升！ 12345678910111213141516171819foo() // functionvar foo = function()&#123; console.log('var')&#125;function foo()&#123; console.log('function')&#125;// 编译后：function foo()&#123; console.log('function')&#125; // ←函数被优先提升声明！foo()foo = function()&#123; console.log('var')&#125; let、const 和 var 虽然在感觉上知道let，const与var在声明上有一些差异，但是总是说不出来具体差异有哪些，希望在这里详细记录这3种声明的差异性。 差异1：变量提升与暂时性死区 var存在变量提升，而let和const则不存在变量提升； let和const存在暂时性死区（temporal dead zone，简称TDZ）; 暂时性死区：指的是let和const在其声明的作用域内会该标识符强制绑定到该作用域，即该标识符不受外层作用域的影响（外层作用域有同名标识符时无法访问到外层作用域的同名标识符变量，相当于与外层作用域隔离），且无法在声明语句之前对其进行访问！ 12345let tmp = 123&#123; // TDZ starts console.log(tmp) // ReferenceError: tmp is not defined let tmp = 666 // TDZ ends&#125; 差异2：重复声明 var可以在同一作用域对同一变量进行多次声明，而let和const则不允许在同一作用域下对同一变量进行多次声明！ 例1： 123var a = 1var a = 666console.log(a) // 666 例2： 123let a = 1let a = 666 // SyntaxError: Identifier 'a' has already been declaredconsole.log(a) 例3：（同一作用域下的let声明特性优于var声明特性执行？） 123let a = 1var a = 666 // SyntaxError: Identifier 'a' has already been declaredconsole.log(a) 差异3：const的独特性 const相比其他两种声明又多了一些独特性质： 声明时必须赋值！ 12const a // SyntaxError: Missing initializer in const declarationa = 123 值（引用指向）不可修改。当const声明的变量赋值对象是基本类型时，就是值不可更改；，如果赋值对象是引用类型，那就是引用的指向不可修改（实际上引用对象的属性值依然可以更改）。 1234567891011121314151617181920// 例1：const a = 123a = 666 // TypeError: Assignment to constant variable.// 例2：const a = &#123; name: 'foo', some: 'bar'&#125;a = &#123; name: 'nothing'&#125; // TypeError: Assignment to constant variable.// 例3：const a = &#123; name: 'foo', some: 'bar'&#125;a.name = 'foobar' // 引用类型的属性值可以更改console.log(a) // &#123; name: 'foobar', some: 'bar' &#125; const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。 ——《ECMAScript 6 入门》 参考文档 block | MDN 《你不知道的JavaScript（上卷）》 9.4 暂时性死区（temporal dead zone） let 和 const 命令 - ECMAScript 6入门]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论css属性中的百分比与相对单位]]></title>
    <url>%2Fpost%2Fcss-percentage-relative%2F</url>
    <content type="text"><![CDATA[前言 长期以来，每次在css属性中使用百分比或者其他一些相对单位时，心里总是有些迷惑，这些相对单位的比较值或者说比较对象到底是谁（即相对标准是啥）？在使用的时候也不太自信，因为有时候会出现一些超出自己『意料之外』的情况出现，所以说对于这些相对单位的准确定义还是不太了解，因此看起来就是一知半解，说不清个一二三。随着对前端知识体系的深入学习，越来越来发现自己的这种『一知半解』，看起来好像是明白，但实际上遇到问题时才发现自己什么都不知道，希望自己能够逐步地掌握精准的知识！ 百分比相关属性 使用百分比最重要的肯定是要清楚它是什么的百分比，而『百分比的计算值通常是以元素的包含块为对象进行计算』，所以首先需要明白包含块是什么以及如何确定一个元素的包含块！ 包含块 包含块（containing block）：用来确定和影响元素的尺寸和位置属性的矩形区域； The size and position of an element are often impacted by its containing block. Percentage values that are applied to the width, height, padding, margin, and offset properties of an absolutely positioned element (i.e., which has its position set to absolute or fixed) are computed from the element’s containing block. ——MDN 一个元素的包含块完全受其position属性值的影响： static或relative：最近的块级（display属性值为block，inline-block或list-item）祖先元素的content-box区域；或者最近的建立格式上下文的祖先元素，比如：table容器，flex容器，grid容器或块级容器。 absolute：最近的非static（fixed, absolute, relative, or sticky）祖先元素的padding-box区域。 fixed：可视窗口viewport本身（属于continuous media类型时）或页面区域page area（属于paged media类型时），即初始包含块； 当属性值为fixed或absolute时，其包含块还有可能是最近的含有transform或perspective值不为none的祖先元素的padding-box区域。 注：html元素的包含块叫做初始包含块（initial containing block），它具有可视窗口（用于连续媒体）或页面区域（用于分页媒体）的尺寸。 百分比的使用 属性 百分比参照对象 width 包含块的宽度 height 包含块的高度 padding 包含块的宽度 margin 包含块的宽度 top 包含块的高度 right 包含块的宽度 bottom 包含块的高度 left 包含块的宽度 font-size 父元素的font-size值 tranlate()/translate3d() 元素自身的padding-box区域x相对于宽度，y相对于高度，z？ 注：当包含块的height为auto且position为static或relative时，height、top和bottom属性设置百分比无效，即百分比计算值为0！！！ padding的例子 123&lt;section class="container"&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/section&gt; 123456789101112.container&#123; width: 500px; height: 300px; padding: 50px; background-color:lightgreen;&#125;.box&#123; width: 200px; height: 50px; padding: 10%; background-color: #36f;&#125; 从.box的盒模型可以看到padding属性值为50px，正好是其包含块（.container的content-box）宽度的10%。 相对单位 相对单位 参照对象 em 当前元素的font-size属性值；若是设置当前元素的font-size值时，则是父元素的font-size值； rem 文档根元素html的font-size属性值； ex 当前元素下小写x字母的高度；受字体和字体大小的影响。 ch 当前元素下数字0的宽度；受字体和字体大小的影响。 lh 当前元素的line-height属性值；若是设置当前元素的line-height值时，则是父元素的line-height值； rlh 根元素的line-height属性值； vw 可视窗口宽度的1% vh 可视窗口高度的1% vi 初始包含块的inline轴方向大小的1%；inline轴方向指的就是文字排列的方向； vb 初始包含块的block轴方向大小的1%；block轴方向是inline轴垂直的方向； vmin min(vw, wh) vmax max(vw, vh) 参考文档 布局和包含块 - CSS：层叠样式表 | MDN percentage - CSS: Cascading Style Sheets | MDN length - CSS：层叠样式表 | MDN CSS Logical Properties and Values - CSS: Cascading Style Sheets | MDN 《css世界》 —— 8.1.2 理解 font-size 与 ex、 em 和 rem 的关系]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css的尺寸盒子及相关属性]]></title>
    <url>%2Fpost%2Fcss-sizing-box%2F</url>
    <content type="text"><![CDATA[前言 尺寸盒子（呃，我也不知道准确定义是什么），顾名思义就是尺寸属性作用的对象。 从上图可以看出，尺寸盒子从内到外依次可以划分为content-box，padding-box，border-box，margin-box；其中margin-box在实际中没有啥用途。 而尺寸属性就是诸如width，height等直接规定元素尺寸的属性，以及定义width，height作用区域的box-sizing属性，除此之外还有像background-origin和background-clip影响元素背景填充区域和显示区域的属性。 box-sizing box-sizing实际上决定了width和height作用的尺寸盒子，而其属性值有： content-box（默认值）：没错，指的就是width和height设置的值是针对于content-box这个盒子，即content区域； border-box：同理，此时width和height设置的值是针对于border-box这个盒子，即border区域（=content + padding + border）； inherit：继承父级属性值； css说的盒模型实际上就是指的box-sizing的属性值，而一般都说不同的盒模型的元素实际宽高有不同的计算方式，不过明白box-sizing的本质之后，就能理解元素的实际宽高只有一种计算方式：content + padding + border； 举个栗子： 12&lt;div id="box1"&gt;&lt;/div&gt;&lt;div id="box2"&gt;&lt;/div&gt; 1234567891011div&#123; width: 100px; height: 100px; padding: 20px; border: 10px solid darkorchid; background-color: lightcoral; margin-bottom: 50px;&#125;#box2&#123; box-sizing: border-box;&#125; 尽管两个div的尺寸样式设置完全一样，但是可以看出不同的box-sizing确实得到的实际尺寸完全不一样： 根本原因就是不同的box-sizing使得width和height属性作用的尺寸盒子不同，然而元素的实际尺寸计算方式是完全没有变滴…… background-origin background-origin规定了指定背景图片（background-image属性，对普通的背景颜色区域不起作用，背景颜色区域一直是border-box） 的原点位置（background-position属性）相对区域。 注意：当使用 background-attachment 为fixed时，该属性将被忽略不起作用。——MDN background-origin的属性值有： content-box padding-box（默认值） border-box inherit（继承父级元素属性值） 没错，这几个属性值分别对应上述的几个尺寸盒子所在区域； background-clip background-clip属性规定了背景（包括background-color和background-image）的实际显示区域；相当于通过background-origin、background-position和background-repeat等属性绘制出背景或背景图，然后通过background-clip来选取一个区域作为最终显示的区域。 background-clip的属性值有： content-box padding-box border-box（默认值） text（兼容性不好） 栗子 123&lt;div id="b1"&gt;&lt;/div&gt;&lt;div id="b2"&gt;&lt;/div&gt;&lt;div id="b3"&gt;&lt;/div&gt; 123456789101112131415161718div&#123; width: 452px; height: 452px; padding: 20px; border: 10px solid rgba(70, 152, 199, 0.6); background-image: url('lena.png'); margin-bottom: 20px; background-repeat: no-repeat; background-clip: padding-box;&#125;#b2&#123; background-origin: content-box; background-clip: content-box;&#125;#b3&#123; background-origin: border-box; background-clip: border-box;&#125; 注：background-image的绘制区域是从background-position到border-box的右下角？而非background-origin指定的区域的右下角？比如：当background-origin为content-box，而background-clip为border-box时： 可以很明显看出，background-image的绘制区域的右下角并非content-box； 关于margin-box 注：这部分仅是自己的理解，还需要进一步验证。 margin:auto 的作用机制 margin:auto是用来给元素自动计算分配『剩余可分配空间』的margin的，但是触发这个功能有一个前提条件： 触发 margin:auto 计算有一个前提条件，就是 width 或 height 为 auto 时， 元素是具有对应方向的自动填充特性的。——《css世界》 除了块级元素的流动性能够使元素在文档流的方向（文字排列方向）进行自动填充外，还有一种方法就是利用top等属性设置margin-box的边界，元素就会自动填充margin-box。 margin:auto 的填充规则如下。 （1）如果一侧定值，一侧 auto，则 auto 为剩余空间大小。 （2）如果两侧均是 auto，则平分剩余空间。 ——《css世界》 top, bottom, left, right 当利用top, bottom, left, right这几个属性（当然前提是absolute或fixed布局）配合margin:auto;进行使用时，top, bottom, left, right的属性值相当于设定了该元素的margin-box的边界。此时，若width和height为auto时，就会自动填充整个margin-box；如果width和height设定了固定值，且固定值小于margin-box，那么『剩余可分配空间』就会被margin自动计算分配（上下左右四个边界）。 最常用的就是利用margin:auto和top, bottom, left, right来使元素水平垂直居中： 12345678910111213141516#test&#123; position: relative; height: 300px; border: 1px dashed darkblue;&#125;#box&#123; position: absolute; top: 0; bottom:0; left: 0; right: 0; width: 300px; height: 150px; background-color: #39f; margin: auto;&#125; 123&lt;section id="test"&gt; &lt;div id="box"&gt;&lt;/div&gt;&lt;/section&gt; 可以看出当top, bottom, left, right的值全为0时，相当于margin-box就是父级容器的大小，因此设置margin:auto时会自动计算剩余可分配空间（上下左右四个方向），由于四个方向都是auto，因此上下和左右各自平分竖直和水平方向的剩余可分配空间作为margin，因此也就形成了水平垂直居中。 不过在查看firefox（chrome也一样）的计算后规则时，貌似四个方向的margin值都为0，而left等值反而进行了计算： 参考文档 《css世界》—— 3.2 width/height作用的具体细节 background-clip - CSS：层叠样式表 | MDN background-origin - CSS：层叠样式表 | MDN 《css世界》—— 4.3.4 深入理解 CSS 中的margin:auto]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[域名解析二三事]]></title>
    <url>%2Fpost%2Fdomain-parse%2F</url>
    <content type="text"><![CDATA[前言 最近想要把搭建的api服务器和部署项目的路径用二级域名进行关联，以方便进行访问，免得一大串的地址和端口暴露出来。但是发现有时候域名解析还真不是那种随意就能正确的得到自己想要的结果…… 一些域名解析类型 域名的解析也分很多种，以下列出的是我用的比较多的几种类型。 A类型 A类型可以将主机记录（二级域名）指向一个ipv4类型的ip地址；但是需要注意的是，该类型不能在ip地址后加上端口；比如： 12主机记录：xx.test.com记录值：aa.bb.cc.dd 上述记录的意思就是访问xx.test.com的时候实际上是访问ip地址为aa.bb.cc.dd的主机；但是如果在ip地址后加上端口号： 1记录值：aa.bb.cc.dd:port 以上的记录值是非法的；其实我就是想将某个二级域名直接解析到主机的某个端口，然后尝试无果…… CNAME类型 CNAME类型的记录可以将当前记录指向另一个域名；需要注意的是仅仅是域名，不能在域名的后面添加路径或参数！！！ 合法记录值： 123xx.test.comtest.comwww.test.com 非法记录值： 123test.com/path/test.com/123.htmltest.com?a=b URL转发 URL转发就是将当前记录跳转到另一个url地址，因此只要是url地址可以访问的，都可以用来转发；不过URL转发还分为显性URL转发和隐性URL转发，它们的区别在于： 显性URL转发使用301永久重定向，即地址栏上的url地址会换成转发后的url地址，而非当前记录使用的url地址；而隐性URL转发使用的是302临时重定向，访问时浏览器地址栏依然是当前记录使用的url地址，但是实际访问的是转发的url地址。 注：但是实际使用时我发现，如果访问当前记录（域名地址）的路径或参数形式时，并不是把域名部分替换成转发的url然后加上后面的路径或参数，而照样只是访问之前的转发url地址；如： 123类型：URL转发主机记录：xx.test.com记录值：another.com/abc 当我访问xx.test.com/someting时，实际上跳转的还是another.com/abc而非想象中的another.com/abc/something；访问xx.test.com?aa=bb时，实际上跳转的也还是another.com/abc而非想象中的another.com/abc?aa=bb；所以我就很疑惑，这到底是本身就是这样的设计，还是我的设置有问题？如果本身设计就是这样，那未免有点太鸡肋了……]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何迁移linux主机上mongodb数据库]]></title>
    <url>%2Fpost%2Fmongodb-migrate%2F</url>
    <content type="text"><![CDATA[前言 由于いんろな原因，我需要把当前部署在一台linux主机上的mongodb数据库迁移到另外一台linux主机上，通过网上找资料发现，其实由于linux主机（云服务器）都具有ssh连接，所以转移一些备份就很方便。 迁移步骤 在目标linux主机上安装mongodb软件： 由于不同linux主机之间的系统环境有所区别，所以得先安装相适应版本的mongodb软件； 对要迁移的mongodb数据库进行备份： 跳转到mongodb的安装路径下的bin目录，执行mongodump命令： 1mongodump 然后该目录下就会多出一个dump目录，dump目录下备份了当前运行的数据库的所有数据。 注：mongodump命令执行时需要有正在运行的mongodb服务器，默认备份的为127.0.0.1:27017的mongodb服务器； 将备份文件拷贝到目标主机中： 最简单的方法就是将备份目录dump下的文件打包后，上传到目标主机中，然后解压；然后linux主机有一个强大的命令——scp，这个命令可以在两个不同的linux主机之间进行远程拷贝文件或文件夹！比如： 1scp -r ./dump root@xx.xx.xx.xx:/path/bin 上述命令就是将当前目录下的dump（及其子目录下的所有文件）文件夹，远程复制到ip地址为xx.xx.xx.xx的主机下的root用户的/path/bin目录下（注意是该目录的子级而非替换整个目录），执行命令后需要输入该用户的访问密码，密码正确后就会远程复制到目标位置！ 之前都不知道有这么强大的命令，一直通过打包解压的方式转移文件…… 在目标主机中进行mongodb数据恢复： 首先也是需要确保目标主机的mongodb数据库已经运行，然后已经将之前的备份文件夹转移到目标主机中mongodb安装路径的bin目录下，然后执行mongorestore命令即可： 1mongorestore 注：该命令默认以bin目录下的dump为备份文件夹进行数据恢复。 后话 经过以上步骤的折腾后，之前主机上的mongodb数据库中数据就完全转移到目标主机中的mongodb数据库中了。但是这种方法也只是适用于像我这种用来测试或者自己玩玩的项目中，要是属于那种有大量用户正在使用的生产数据库，那就得另寻他法了！ 参考文档 MongoDB 备份(mongodump)与恢复(mongorestore) | 菜鸟教程 scp 跨机远程拷贝 —— Linux Tools Quick Tutorial]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoose的基本操作]]></title>
    <url>%2Fpost%2Fmongoose-basic%2F</url>
    <content type="text"><![CDATA[前言 mongoose与mongodb的关系 mongodb实际上是一个跨平台的nosql型数据库软件，而mongoose是一个基于mongodb的官方js驱动实现的js库，即专门用于在node.js环境下与mongodb数据库进行连接操作。 为什么使用mongoose 事实上mongodb官方已经实现了基于node.js的驱动库，npm包名就叫mongodb，专门用来与mongodb数据库进行连接操作的，所以为何还要使用第三方实现的mongoose库。这是实际上还是取决于每个人的习惯和理念，由于mongodb在设计上就对于collection（对应于sql数据库中的数据表）的结构限制很少，可以认为其存取数据很灵活，也可以认为其存取数据比较松散，这完全是个人口味问题。 而我个人比较习惯对于同一集合（collection）中数据的格式要保持一致性，即每条数据的结构和类型是一致的，不然总觉得不同结构和类型的数据存放于同一集合中就太混乱了（也许是还无法适应mongodb的设计模式）。 而mongoose就加入了Schema这一设计，使得集合中的数据保持结构和类型的一致性成为可能，方便数据管理。 基本操作 数据库连接 123456789101112const mongoose = require('mongoose')// mongodb连接地址：mongodb://ip:port/databaseconst url = 'mongodb://0.0.0.0:27017/test'let db = mongoose.createConnection(url) // 返回数据库的连接对象db.on('error', (err)=&gt;&#123; // 监听数据库连接错误事件 throw err&#125;)db.once('open', function()&#123; // 监听数据库连接成功事件（once就是监听一次） console.log('connect success') db.close() // 关闭数据库连接&#125;) 注：mongodb数据库的默认端口为27017； 连接集合与Model Schema可以看做是Model与collection之间的中介（相当于proxy），因为实际上不同的Schema可以连接到同一个collection，也就是即便是使用mongoose后仍然会出现同一个集合内存在不同数据结构的数据；但是由于有Schema这层中介的存在，使得同一Schema内的数据结构是一致的，就不需要我们自己手动地去集合内约束和判断数据结构了（即把数据结构从集合中抽离出来，集合本身不再有固定的数据结构）。 而Model可以看做某个collecton中具有某个Schema的一部分数据，即一个Model需要通过某个Schema来对某个collection进行数据操作。 12345678const mongoose = require('mongoose')const Schema = mongoose.Schemaconst testSchema = &#123; name: String, age: Number, habits: [String]&#125; // 首先定义一个Schema结构 连接集合的方式有两种，一种是mongoose约定的形式；另一种是给schema指定一个具体的collection，使用此schema的model都自动连接到这个collection； 方法一 12345// 方法一：指定一个具体的collectionlet schema = Schema(testSchema, &#123;collection: 'info'&#125;) // 将testSchema绑定到名为info的集合上// db为数据库连接对象，该model自动连接schema绑定的集合上let model = db.model('Habit', schema) 方法二 123456// 方法二：根据Model的名称自动查找let schema = Schema(testSchema) // schema没有绑定集合// 此时model连接到其名称的复数形式（小写）的集合上，即habits集合let model = db.model('Habit', schema) CRUD 插入数据 一条数据即一条document，而每条document都是某个model的实例；所以插入一条数据到某个集合就要先得到该集合的某个Model，然后new一个该Model的实例，填入数据后可以使用save方法进行插入； 12345678910let schema = Schema(testSchema, &#123;collection: 'info'&#125;)let Habit = db.model('Habit', schema)let habit = new Habit(&#123; 'name': 'xxf', 'age': 22&#125;) // 可以只填部分或不填数据，新增一条数据habit.save(err =&gt; &#123; ...&#125;) // 使用save方法对新增的数据进行插入 查询数据 查询条件应该是数据库操作中用的最多的操作，写法自然也是丰富多样，我觉得有必要单独去专门写一个mongoose条件语句（mongoose实际上使用的条件语句格式是mongodb官方规定的语句）的文章，目前还没有使用那么多的语法（主要是还没有遇到那么多的应用场景……）。 mongoose的查询API有： Model.find() Model.findById() Model.findByIdAndDelete() Model.findByIdAndRemove() Model.findByIdAndUpdate() Model.findOne() Model.findOneAndDelete() Model.findOneAndRemove() Model.findOneAndUpdate() 经常使用的方法主要是find()和findOne()这两个，前者可以返回多条满足条件的数据，而后者只返回第一条匹配条件的数据； 123456let schema = Schema(testSchema, &#123;collection: 'info'&#125;)let Habit = db.model('Habit', schema)Habit.findOne(&#123;'name': 'xxf'&#125;, (err, data) =&gt; &#123; ...&#125;) 如上，findOne()方法的第一个参数为查询条件，第二个参数为回调函数（回调函数第一个参数为Error对象，当不为undefined时则代表查询发生错误，第二个参数为匹配条件的数据）； 123456let schema = Schema(testSchema, &#123;collection: 'info'&#125;)let Habit = db.model('Habit', schema)Habit.findOne(&#123;'age': &#123;$gt: 18&#125;&#125;, (err, docs) =&gt; &#123; ...&#125;) 而find()方法的用法几乎与findOne()的一致，只是回调函数的第二个参数是一个数组，包含所有满足查询条件的数据； 更新数据 更新的本质就是先查询后修改，所以也需要用到查询语句；但是除此外还需要用到修改语句，又是有许多内容可讲； mongoose的更新数据API有： Model.replaceOne() Model.updateMany() Model.updateOne() 删除数据 删除操作也是先进行查询在删除的，所以也要用到查询语句； mongoose的删除数据API有： Model.deleteMany() Model.deleteOne() 注意事项 当对某条数据的一部分（字段）的内容进行增删操作时，实际上还是属于更新数据的范畴，注意不要混淆！ 后话 实际上还有很多需要整理的，但是目前使用的场景并不多，使用的语法的也比较零散，还是需要时间和项目的使用慢慢积累才行。 参考文档 Mongoose v5.3.9: Getting Started MongoDB CRUD Operations Query and Projection Operators —— MongoDB Manual]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
        <tag>mongoose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于this的指向]]></title>
    <url>%2Fpost%2Fjs-this%2F</url>
    <content type="text"><![CDATA[前言 在写js代码的时候，尤其是写带有面向对象编程式的代码的时候，我总是会想我这里使用的this到底指的是什么，这个问题真是困扰了我很久。虽然代码写久了会有一些基于经验的直觉感受，不过从本质出发是最直接的理解途径。 this的指向 默认情况 当在某个函数（function）中使用了this时，这个this指向的是该函数调用时所在的作用域，比如： 1234567function foo()&#123; console.log(this.a)&#125;let a = 1foo() // 会输出 1 可以看出上面的foo函数在执行的时候，实际上位于全局作用域（即window的作用域）中，所以this实际上指向了全局对象window，而全局作用域内声明的变量实际上都变成了window对象的属性，所以foo函数内部的this.a实际上就是window.a；但是需要注意的是，如果使用的为严格模式（&quot;use strict&quot;），函数在执行时是不能指向全局对象的！ 123456789"use strict"function foo()&#123; console.log(this.a)&#125;let a = 1foo() // TypeError: this is undefined 这时候foo函数的内部的this实际上就是undefined； 函数引用 当函数被某个对象的属性所引用时，该函数属性（即指向该函数的对象属性）在执行的时候，this指向的为该属性所属的对象（需要注意的是对象属性可以为对象，也就是对象可以嵌套，因此该对象指的是直接包含该属性的那层对象）；比如： 12345678910function foo()&#123; console.log(this.a)&#125;let obj = &#123; a: 'just do it', fn: foo&#125;obj.fn() // 输出 'just do it' 注：当函数已经被某个对象属性所引用，然后又有其他变量或对象属性指向该对象属性，其实际上还是指向原函数；如同a → foo，b → a，实际上就是b → foo；不管中间经历多少个指向，最终指向的一定是原函数。比如： 1234567891011function foo()&#123; console.log(this.a)&#125;let obj = &#123; a: 'just do it', fn: foo&#125;let bar = obj.fn // obj.fn实际指向foo，因此bar指向了foo，实际上相当于 bar = foobar() // undefined 从上面可以看出，中间经历多重指向后，实际上还是指向原函数，因此this具体指向要看执行时该函数是作为函数属性还是普通函数执行的。 直接绑定 Function.prototype具有3个特殊的方法：call()、apply()和bind()。这个三个函数之所以特殊，是因为它们都提供了一个参数用来绑定函数内部的this对象，因此可以利用这3个函数直接将我们想要this指向的对象与this进行绑定。 123456789function foo()&#123; console.log(this.a)&#125;let obj = &#123; a: 'ok'&#125;foo.call(obj) // 输出 'ok' 上面的obj对象利用call方法绑定到foo函数的this上，因此执行的时候this.a实际上就是obj.a。 new绑定 在进行面向对象式的编程时，经常将函数作为构造器使用new来『构造』一个新对象，之前总以为new返回了函数的内部this对象，且this指向的应该就是新『构造』的实例。然而实际上这种想法是错误的，new关键词所做的无非是一个稍微特殊的函数调用：当该函数没有返回值或返回值不是对象（引用类型？）时时，new会构造一个对象，将该对象的__proto__属性连接到函数的prototype属性，并将该对象指向函数内部的this对象，然后返回该对象；若该函数有对象返回值，则直接返回该对象返回值（即此时相当于普通函数的调用而已）。 123456789101112131415161718192021222324252627282930// 1. 没有返回值的情况function foo()&#123; this.a = 'nothing' let b = '何でもない'&#125;let o1 = new foo()console.log(o1) // &#123;a: 'nothing'&#125;// 2. 有对象返回值的情况function bar()&#123; this.a = 'nothing' let b = '何でもない' return &#123;a: b&#125;&#125;let o2 = new bar()console.log(o2) // &#123;a: '何でもない'&#125;// 3. 有返回值，但不是对象的情况function fb()&#123; this.a = 'nothing' let b = '何でもない' return b&#125;let o3 = new fb()console.log(o3) // &#123;a: 'nothing'&#125; 箭头函数 ES6新增的箭头函数中使用的this跟普通定义的函数有所不同，这里的this指向的实际上是箭头函数定义时离得最近的一层外层函数作用域内的this对象； 1234567891011function foo()&#123; return () =&gt; &#123; console.log(this.a) &#125;&#125;let obj = &#123; a: 'so what'&#125;let bar = foo.call(obj)bar() // 输出 'so what' 上面通过将obj对象作为foo函数的this对象，然后返回一个箭头函数，该箭头函数在定义的时候内部的this实际上指向的就是此时foo函数内部的this对象，即obj对象。 注：当有多个箭头函数嵌套时，this的指向也是在定义处一层一层往上直至最近的外层非箭头函数的内部this对象。 参考文档 《你不知道的JavaScript（上卷）》——第二章：this全面解析]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用3D transform实现视差滚动]]></title>
    <url>%2Fpost%2F3d-transform-parallax-scrolling%2F</url>
    <content type="text"><![CDATA[前言 最近在网页中运用『视差滚动』比较流行，能让网页有一种立体层次感。 视差滚动（Parallax Scrolling）是指让多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。作为网页设计的热点趋势，越来越多的网站应用了这项技术。 ——百度百科 说白了，『视差滚动』就是让同一页面的不同元素在滚动的时候，滚动速度各不相同，从而让人觉得页面有层次。然而css3新增的3D transform特性本身就可以为元素增加立体感，所以很适合用来实现『视差滚动』。 原理 相当于在同一三维坐标系中，为不同层次的元素设置不同的z坐标，就自然形成了不同的立体层面，滚动的时候不同z坐标的元素拥有不同的滚动速度（从结果上来说是这样的），且z坐标越小（即离屏幕平面向内越远）的平面，滚动速度看起来越慢。 利用perspective属性构造一个相机（观察者）容器，然后设置perspective-origin（消失点？相机焦点？）； 利用transform-style属性构造一个3d容器： 1transform-style: preserve-3d; 也就是其内的元素呈现方式为3d，相当于构建了一个三维坐标系； 在3d容器内利用transform: translateZ()设置不同的z坐标，体现层次；不过只设置z坐标，元素在投影到屏幕平面时，尺寸就不是原来的尺寸了，需要使用scale()进行缩放： 1缩放系数 = （z坐标 - perspective设置值）/ perspective设置值 光有z坐标并不会自动按照z的大小进行层次覆盖，而是按照html的先后顺序进行覆盖，所以还需要按照层级手动添加z-index属性； 实际上不同层面处于不同的z平面 表面上看起来就是层叠 示例 12345678910111213141516171819#view&#123;/* 相机容器 */ position: relative; perspective: 300px; perspective-origin: 0 0; overflow-x: hidden; overflow-y: scroll;&#125;.layer&#123;/* 3d容器 */ position: absolute; left: 0; width: 100%; transform-style: preserve-3d;&#125;.l1&#123;/* 第一层级 */ transform: translateZ(0);&#125;.l2&#123;/* 第二层级 */ transform: translateZ(-300px) scale(2);&#125; 1234567891011121314&lt;section id="view"&gt; &lt;section class="layer"&gt; &lt;div class="l1"&gt;Layer 1&lt;/div&gt; &lt;div class="l1"&gt;Layer 1&lt;/div&gt; &lt;div class="l1"&gt;Layer 1&lt;/div&gt; &lt;div class="l1"&gt;Layer 1&lt;/div&gt; &lt;div class="l1"&gt;Layer 1&lt;/div&gt; &lt;/section&gt; &lt;section class="layer"&gt; &lt;div class="l2"&gt;Layer 2&lt;/div&gt; &lt;div class="l2"&gt;Layer 2&lt;/div&gt; &lt;div class="l2"&gt;Layer 2&lt;/div&gt; &lt;/section&gt;&lt;/section&gt; 查看demo 参考文档 [译]高性能视差滚动｜DuMengjie’s blog A grouped pure CSS parallax demo by Keith Clark]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数据类型及复制引用]]></title>
    <url>%2Fpost%2Fjs-value-use%2F</url>
    <content type="text"><![CDATA[类型与值 虽然js/es中声明变量的时候并不能限定变量的数据类型，然而实际上值的类型就是该变量的数据类型（虽说中途可以换成其他任意数据类型的值）。 内置类型 js目前有七种内置数据类型：undefined，null，number，string，boolean，object，symbol（ES6新增）；其中除了object之外的都为基本类型（也叫原始类型，Primitive Type），与基本类型相对的就是复杂类型（即引用类型）；因为object是由多个无序键值对组成的，这些值可以是基本类型也可以是object； JavaScript 中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值。——《你不知道的JavaScript（中卷）》 typeof操作符 typeof操作符可以用来判断变量或表达式的类型，有以下几种可能： 变量值的类型或状态 typeof 返回值 值未定义 “undefined” 布尔值 “boolean” 字符串 “string” 数值 “number” 对象或null “object” 函数 “function” Symbol类型（ES6） “symbol” 为何typeof null的结果是 “object”，这是js建立以来就存在的一个bug： 有些时候， typeof 操作符会返回一些令人迷惑但技术上却正确的值。比如，调用 typeof null会返回&quot;object&quot;，因为特殊值 null 被认为是一个空的对象引用。——《JavaScript高级程序设计（第三版）》 1typeof null === 'object'; // 从一开始出现JavaScript就是这样的 在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null的类型标签也成为了 0，typeof null就错误的返回了&quot;object&quot;。 ECMAScript提出了一个修复（通过opt-in），但被拒绝。这将导致typeof null ===‘object’。——MDN 注：typeof Object的结果并不是想象的'object'，而是'function'；可以这么理解，Object本身是一个构造器函数，而不是一个具体的对象实例，只有对象实例的typeof结果为'object'！ 123456789var obj = new Object();var fun = new Function();var arr = new Array();console.log(typeof Object); // 'function'console.log(typeof Function); // 'function'console.log(typeof obj); // 'object'console.log(typeof fun); // 'function'console.log(typeof arr); // 'object' 要注意的是，不是所有属于对象实例范畴的typeof结果必定就是'object'，函数的实例从某种意义来说就是Function的实例，但是结果是'function'！ 值的复制与引用 复制：即复制一个值的复本，即从值的内存复制到一块新的内存，但是值的内容是一致的； 引用：指向该值，并非指向该值的内存，不是所谓的指针！ JavaScript 引用指向的是值。如果一个值有 10 个引用，这些引用指向的都是同一个值，它们相互之间没有引用 / 指向关系。 JavaScript 对值和引用的赋值 / 传递在语法上没有区别，完全根据值的类型来决定。 ——《你不知道的JavaScript（中卷）》 在js中，值在进行赋值和传递的过程中，会根据值的类型不同来选择到底是复制复本还是引用；若是基本类型，在赋值/传递过程中是对值进行了复制，若是引用类型则直接对值进行引用；如： 12345678910var a = 2;var b = a; // b是a的值的一个复本b++;a; // 2b; // 3var c = [1,2,3];var d = c; // d是[1,2,3]的一个引用d.push(4); // 通过引用的值本身的方法使值发生了改变，因而c，d指向的值也就改变了c; // [1,2,3,4]d; // [1,2,3,4] 简单值（即标量基本类型值， scalar primitive） 总是通过值复制的方式来赋值 / 传递，包括null、 undefined、字符串、数字、布尔和 ES6 中的 symbol值。 复合值（compound value）——对象（包括数组和封装对象）和函数，则总是通过引用复制的方式来赋值 / 传递。 ——《你不知道的JavaScript（中卷）》 要注意的是，引用仅仅只是对值的引用，而该变量并不等同于该值的内存地址，所以直接改变该变量的引用指向并不能改变其它变量对该值的引用，如： 12345678var a = [1,2,3];var b = a; // 由于a的值是引用类型，所以b直接引用了a的值a; // [1,2,3]b; // [1,2,3]// 然后b = [4,5,6]; // b的指向发生了改变，但并不能改变a对[1,2,3]的引用指向！a; // [1,2,3]b; // [4,5,6] 向函数中传递参数时，实际上就是把实参赋值给形参！因而实参值的类型决定了是复制还是引用，这就是js中的参数传递。如： 1234567891011121314function foo(x) &#123; x.push( 4 ); x; // [1,2,3,4] // 然后 x = [4,5,6]; // x的指向发生改变，同理，之前的a对值的指向并没改变！ x.push( 7 ); x; // [4,5,6,7]&#125;var a = [1,2,3];foo(a); // 传递参数过程相当于：var x = a;// 由于a的值为引用类型，所以把a传递给形参x时，x就直接用了a的值a; // 是[1,2,3,4]，不是[4,5,6,7] 引用类型的深复制与浅复制 由于引用类型的『特殊性质』，导致我们对于引用类型的赋值和传递可能会产生意想不到的副作用，所以我们平时在对引用类型的值进行赋值或传递的时候，一定要思考『我们需要的是深复制还是浅复制？』。 深复制：即重新开辟一块内存，将值的内容复制到新的内存中，即新的值与原先的值不在同一内存了！需要注意的事，深复制必须是每个层级的属性值都要深复制，比如某对象的属性也为对象，对这个属性如果直接浅复制的话，则并没有完成深复制！ 浅复制：浅复制就是对值的引用，即不会重新开辟新的内存，复制后指向的是同一个值；在js中直接对引用类型进行赋值或传递就是浅复制！ 首先深复制和浅复制只针对像 Object, Array 这样的复杂对象的。简单来说，浅复制只复制一层对象的属性，而深复制则递归复制了所有层级。 ——https://www.zhihu.com/question/23031215/answer/46220227 因此对引用类型进行深复制不会造成改变当前对象的属性值会影响到原对象的属性值的情况，然而浅复制有这种风险！ PS：有一次我做了一道前端面试题中要求对引用类型进行复制，然而我以为可以直接用var obj2 = new Object(obj)的方法就可以实现深复制，结果实践证明大错特错！该方法也是直接对原对象进行引用： 12345var obj = &#123;a: "1"&#125;;var bar = new Object(obj);bar.a = "xxf";console.log(bar, obj); // &#123; a: 'xxf' &#125; &#123; a: 'xxf' &#125; 如何实现引用类型的深复制？ 由于引用类型存在着嵌套引用类型的情况，也就是需要根据每一层级的情况来逐一判断，单纯的遍历可能无法解决所有的层级，一般需要用到递归； P.s：不知道有没有一种不需要循环递归且能适用于所有引用类型的深复制方法？ 1. Object.assign()方法 assign是ES6新增的Object方法，用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）；如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 1Object.assign(target, source1, ..., sourceN); 会返回合并后的对象？可以用assign方法进行一层复制，即若该对象的某一属性为引用类型，那么实现的还是浅复制（引用）！如： 12345678910let target = &#123;a: 1, b: 'xxf'&#125;;let source = &#123;a: 4, c: &#123;name: 'n'&#125;&#125;;Object.assign(target, source);console.log(target); // &#123; a: 4, b: 'xxf', c: &#123; name: 'n' &#125; &#125;target.c.name = 'my';console.log(source); // &#123; a: 4, c: &#123; name: 'my' &#125; &#125; 2. JSON方法 使用JSON.parse()和JSON.stringify()方法也能实现一定程度的深复制，只不过无法复制对象的函数属性，且无法继承原对象的原型链！如： 1234567891011let source = &#123;a: 4, c: &#123;name: 'n'&#125;, b: function () &#123;&#125;&#125;;let target = JSON.parse(JSON.stringify(source));console.log(target); // &#123; a: 4, c: &#123; name: 'n' &#125; &#125;target.c.name = 'my';console.log(source); // &#123; a: 4, c: &#123; name: 'n' &#125;, b: [Function: b] &#125; 3. 递归处理 123456789101112131415161718192021222324252627282930313233343536373839function deepClone(data) &#123; var obj; switch(data.constructor)&#123; // 使用构造器函数对不同类型的对象进处理 case Array: // array和object类型的数据需要对嵌套进行处理 obj = []; for(var i in data)&#123; obj.push(deepClone(data[i])); &#125; break; case Object: obj = &#123;&#125;; for(var k in data)&#123; obj[k] = deepClone(data[k]); &#125; break; default: // 默认的基本数据类型和function直接赋值 obj = data; break; &#125; return obj;&#125;var o1 = &#123;a: 1, b:[2, 3, 4], c: &#123;name: "xxf"&#125;, d: function () &#123;&#125;&#125;;var o2 = deepClone(o1);console.log(o2); // &#123; a: 1, b: [ 2, 3, 4 ], c: &#123; name: 'xxf' &#125;, d: [Function: d] &#125;o2.c.name = "xyz";o2.b[1] = 1.5;o2.d = function () &#123; return 123;&#125;;console.log(o1, o2.d === o1.d); // &#123; a: 1, b: [ 2, 3, 4 ], c: &#123; name: 'xxf' &#125;, d: [Function: d] &#125; false 参考资料 你不知道的JavaScript（中卷）—— 第二章]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css元素水平垂直居中的方法]]></title>
    <url>%2Fpost%2Fcss-center-center%2F</url>
    <content type="text"><![CDATA[前言 还记得刚开始出来找工作那段时间，有一次去一家公司面试，结果出了个小项目要当场实现，然后是一个移动端登录界面，要求整体位置水平垂直居中，结果当时基础薄弱，根本想不起来怎么实现水平垂直居中，现在想起来都有点自愧不如。 后面虽然回去详细了查看了一些使元素水平垂直居中的方法，也有所收获，但是也没来得及整理一下具体方法。 实现方法 一般来说，根据元素的宽高是否是固定的还是不定的（即随内容不同而改变），适用的方法也有所不同。 固定宽高的元素 方法一：负margin + position + (50%, 50%) 由于元素本身的宽高是固定的，也就是无论其内容怎么改变，width和height是不变的，因此可以直接『计算』出该元素在其父元素内水平垂直居中的位置：正中心位置（即left和right都为50%的位置）向左上角方向偏移自身宽高的一半。如图所示： 图1 关键就在于使用负margin进行偏移，使元素处于水平居中的位置： 12345678910.father&#123; position: relative;&#125;.children&#123; position: absolute; left: 50%; top: 50%; margin-left: -0.5*w; /* w和h就是该元素本身的宽高 */ margin-top: -0.5*h;&#125; 方法二：margin:auto + position + (0,0,0,0) 这种方法实际上利用了margin:auto这个属性的特点： 12345margin:auto的填充规则如下。（1）如果一侧定值，一侧auto，则auto为剩余空间大小。（2）如果两侧均是auto，则平分剩余空间。 以上来自张鑫旭大佬的《css世界》—— 4.3.4 深入理解CSS中的margin:auto 可以这么理解：当设置元素的left,right,top,bottom都为0时，代表该元素实际上可以分配的空间大小为父元素（最近的非static祖先元素）的全部大小（即自动填充父元素所有空间），但是该元素又设置了width和height属性，所以就有所谓的『剩余空间』，利用margin:auto就可以自动平分『剩余空间』，使『剩余空间』成为margin。 基本css形式如下： 12345678910111213.father&#123; position: relative;&#125;.children&#123; position: absolute; left: 0; right: 0; top: 0; bottom: 0; width: w; /* w和h为固定宽高 */ height: h; margin: auto;&#125; 方法三：position + calc 这种方法的原理与方法一是相同的，也是先定位到(50%, 50%)的位置，然后向左上角进行偏移；只不过这里利用了css3的calc()方法代替负margin进行偏移： 12345678.father&#123; position: relative;&#125;.children&#123; position: absolute; left: calc(50% - 0.5*w); /* w和h就是该元素本身的宽高 */ top: calc(50% - 0.5*h);&#125; 可以看出calc()方法中的%是相对于父元素（最近的非static祖先元素）而言的。 不定宽高的元素 所谓的不定宽高就是指元素的width和height都没有预先设置，而是随内容不同发生改变（撑开）。既然适用于不定宽高元素的水平垂直居中，那肯定也适用于固定宽高元素。 方法一：flex大法 说句实话，要是css3完全普及并没有兼容性问题的时候，所有的布局几乎都可以使用flex伸缩盒模型来完成，根本不用像之前那么麻烦。利用flex进行水平垂直居中，主要是使用justify-content和align-items这两个属性，前者是用来控制主轴元素的排列布局方式，而后者就是用来控制侧轴元素的排列布局方式。而flex盒模型中默认的主轴就是水平方向，所以可以用justify-content:center;使元素水平居中，用align-items使元素垂直居中： 12345.father&#123; display: flex; justify-content: center; align-items: center;&#125; 方法二：position + (50%, 50%) + transform 利用css3的tansform属性也可以使元素水平垂直居中，其原理和图1一样，先定位到(50%, 50%)，然后使用transform属性中的translate()方法进行偏移即可： 123456789.father&#123; position: relative;&#125;.children&#123; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);&#125; 没错，transform的%是相对于自身的宽高而言的，因此无论宽高多少都可以达到水平垂直居中的效果。 不过使用上面方法的时候，我发现如果该元素没有设置宽度（子元素是文本，宽度由内容撑开），那么该元素的最大宽度只能到父元素的50%（即文本宽度超过50%时会自动换行）。 后话 查了一些文章和资料后，其实还有一些方法可以实现水平垂直居中；如table布局以及line-height+vertical-align+text-align，但是我在尝试line-height方案时，有时会不成功，也不知道原因是啥。 所有的实现效果可以查看：http://xiexuefeng.cc/demo/css_test/centet_center.html 参考文章 CSS实现水平垂直居中的10种方式（史上最全） 《css世界》—— 4.3.4 深入理解CSS中的margin:auto]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>css</tag>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在node上搭建一个mongodb服务器]]></title>
    <url>%2Fpost%2Fnode-mongodb-server%2F</url>
    <content type="text"><![CDATA[前言 由于Cloud Studio中每个工作空间只能使用1G的内存，当后台运行进程过多时，如果当前运行的进程需要比较多的内存时，就会造成该进程『killed』（由于可用内存不够导致内存溢出）；比如使用npm run dev或npm run build时，被kill时就会报一个137的错误，对于node可以通过设置--max-old-space-size来限制node或npm本身占用的最大内存；但是限制内存后程序自然就运行得慢了。 而像mongodb这种进程在后台运行肯定会占用较多的内存，因此决定将其单独设立到另一个主机空间，做成远程服务器（即不是集成到当前空间和项目中，而是利用ip或网址进行访问，就是调用API接口的形式）进行连接。 准备工作 要使用mongodb光在node项目中引入相关依赖包是不够的，因为那些包只是对mongodb数据库进行连接和操作的！！！所以，首先必须在主机空间里安装mongodb软件。 安装mongodb 由于Cloud Studio给定的主机是Ubuntu 16.04 x64的，所以需要去Mongodb官网下载中心选择对应系统版本的安装包，然后下载，如： 1wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-3.6.7.tgz 下载完安装包后，进行解压： 1tar -xvf mongodb-linux-x86_64-ubuntu1604-3.6.7.tgz 解压后顺便把文件夹名称一改，因为这文件夹名实在是有点长： 1mv mongodb-linux-x86_64-ubuntu1604-3.6.7 mongodb 现在相当于把mongodb安装在~/path/mongodb文件夹下了。 添加到环境变量中： 由于studio使用的命令行是zsh，所以需要在~/.zhsrc的末尾添加： 12export MONGODB_HOME="$HOME/path/mongodb"export PATH="$MONGODB_HOME/bin:$PATH" 添加完后执行更新命令： 1source .zshrc 然后就可以使用mongodb的命令了。 启动mongodb数据库 启动一个mongodb数据库，需要给定一个存放数据库文件的文件夹路径；比如在~下新建了一个dbdata文件夹，然后指定为数据库文件存放路径并启动mongodb数据库： 1mongod -dbpath=./dbdata 启动的数据库默认端口是27017，如果要使数据库一直保持运行（后台运行），可以在启动命令的最后添加&amp;即可。 搭建Express服务器 显然，只有数据库是无法完成API接口的；因此需要一个用来接收request，返回response的服务器组件。经过一番查询后，发现在Node.js使用较多的是Express这个服务器框架，看了一下确实比较方便，只需要关心输入输出即可，不需要考虑太多的配置，所以决定搭建一个Express服务器来处理request和response。 安装依赖 1npm i express -S 简单的Express服务器 在项目文件夹创建一个app.js文件，然后写一个简单的处理request和response的服务器： 123456789101112131415const express = require('express')let app = express() // 创建一个express服务器// 设置路由，根据请求地址的路径来处理request，输出相应的responseapp.get('/', (req, res)=&gt;&#123; res.send('Hello World!')&#125;)// listen函数用来设置监听端口和ip地址let server = app.listen('3000', '0.0.0.0', ()=&gt;&#123; let host = server.address().address let port = server.address().port console.log('app listening at http://%s:%s', host, port)&#125;); 上面的代码就相当于建立了一个服务器，这个服务器的地址就是0.0.0.0:3000；然后当使用get方法访问服务器根路径/时，给出的response正文为Hello World!。 使用node app.js启动服务器，访问效果如下： Mongoose 由于node并不能直接连接mongodb服务器进行数据获取和操作，因此需要能够在node下对mongodb服务器进行操作的工具。事实上mongodb官方早就实现了基于Node.js的驱动和API，只需要在node项目中安装mongodb这个依赖包就可以实现对mongodb服务器的连接和操作；但是由于对数据结构没有限定，使用比较自由，所以觉得另一个基于官方驱动的mongoose更符合我的胃口，因为mongoose的Schema可以实现对数据的结构和数据类型进行限定。 安装 1npm i mongoose -S 连接数据库 12345678910111213const mongoose = require('mongoose')const Schema = mongoose.Schema // Schema构造函数// mongodb连接地址：mongodb://ip:port/databaseconst url = 'mongodb://0.0.0.0:27017/test'let db = mongoose.createConnection(url) // 返回数据库的连接对象db.on('error', (err)=&gt;&#123; // 监听数据库连接错误事件 throw err&#125;)db.once('open', function()&#123; // 监听数据库连接成功事件（once就是监听一次） console.log('connect success') db.close() // 关闭数据库连接&#125;) 显然，所有的CRUD操作肯定需要在连接成功事件（open）内进行。 Schema、model和document 由于mongodb属于nosql类型数据库，对于数据库中的表（在mongodb中并没有表这一说，相对应的是集合（collection），一个集合并没有数据结构和类型限制，集合内的数据并不需要格式相同）；而Schema算是mongoose对于mongodb没有限定集合内数据结构和类型的补充，而model可以看做具有给定Schema的集合，而docuement则是model的实例，可以看做是该集合内的一条数据。 Schema Schema以键值对的形式来定义数据结构和类型，键名就是字段名称，而值就是类型限制或更加详细的设定；其中可以使用的数据类型有： String Number Date Buffer Boolean Mixed：Schema.Types.Mixed，实际上就相当于一个Object；这种类型无法对其内部数据类型进行准确限定！ ObjectId Array：数组内元素类型可以是Schema或其它数据类型 Decimal128 Schema：一个已经被定义的Schema可以作为一种类型使用，也就是Schema可以嵌套！ P.s：当某个字段的类型为一个对象，且对象的字段全都给定了类型限定，则会被自动转为一个Schema作为该字段的类型！ 实例： 123456789101112131415161718192021222324252627282930const mongoose = require('mongoose')const Schema = mongoose.Schemalet user = new Schema(&#123; name: String&#125;) // 一个已定义的Schemalet group = &#123; id: Number, name: String&#125; // 一个所有字段被限定类型的对象let habit = &#123; group: Number, name: String, tip: String, start: Number, theme: Number, icon: Number, day: [Number]&#125; // 一个所有字段被限定类型的对象let data = &#123; uid: Number, user: user, // Schema作为类型使用 habits: [habit], // 对象作为类型，自动转换成Schema，作为数组元素的类型 group: [group]&#125;let dataType = new Schema(data) // 最终的Schema数据结构和类型 model，document 123456// 按给定数据结构和类型生成Schema，并绑定到指定集合let schema = Schema(schemaType, &#123;collection: 'info'&#125;)// 按照给定的Schema生成modellet model = dbase.model('', schema)// 按照给定的model和参数生成一条数据let data = new model(&#123;...&#125;) 事实上，Schema只是格式，真正具有CRUD的是model和document；而model具有最直接的数据操作。 收尾 简单地来说：mongodb数据库也有了，Express服务器也有了，剩下的就是在相应的路由里由mongoose连接数据库进行CRUD操作，并在response中返回相应的数据，这样就构成了一个完整的API服务器了。 参考文档 node+vue+MongoDB从构建项目到服务器部署 为什么用NPM安装mongodb开启服务不成功？ 使用vue-cli结合express获取mongodb里面的数据 - 明明一颗大白菜 - 博客园 一个简单的 Express 路由 Express 4.x - API 中文手册 Mongoose 5.0 中文文档]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
        <tag>mongoose</tag>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在vue-cli项目中使用scss]]></title>
    <url>%2Fpost%2Fvue-cli-scss%2F</url>
    <content type="text"><![CDATA[前言 最近想在一个使用vue-cli的小项目中，使用scss来编写样式；如果不需要引入公共的scss文件的话，那只需要在&lt;style&gt;中设置lang=&quot;scss&quot;即可。但是一般使用scss的时候，都会设置公共文件进行引用，方便代码复用。所以，如果需要像普通引入公共scss文件的话，需要进行一些配置。 配置 安装相关依赖包 123npm i node-sass --save-devnpm i sass-loader --save-devnpm i sass-resources-loader --save-dev 修改Loader配置 vue-cli项目的loader配置文件是build/utils.js： 然后新增一个函数，如下： 1234567891011121314151617181920212223function generateSassResourceLoader() &#123; let loaders = [ cssLoader, 'sass-loader', &#123; loader: 'sass-resources-loader', options: &#123; // 引入多个文件时用数组的形式传入，单个文件时可以直接使用如下形式 resources: path.resolve(__dirname, '../src/style/common.scss') &#125; &#125; ] // Extract CSS when that option is specified // (which is the case during production build) if (options.extract) &#123; return ExtractTextPlugin.extract(&#123; use: loaders, fallback: 'vue-style-loader' &#125;) &#125; else &#123; return ['vue-style-loader'].concat(loaders) &#125;&#125; 最后把exports.cssLoaders的return项中的scss属性值改成上面新增的函数： 1scss: generateSassResourceLoader() 效果如下： 123456789return &#123; css: generateLoaders(), postcss: generateLoaders(), less: generateLoaders('less'), sass: generateLoaders('sass', &#123; indentedSyntax: true &#125;), scss: generateSassResourceLoader(), // 修改成自定义的loader函数 stylus: generateLoaders('stylus'), styl: generateLoaders('stylus')&#125; 使用 配置完后，就可以在vue文件使用引入的公共scss文件中的变量和样式了。 参考文档 vue引入sass全局变量 在vue-cli中安装scss，且可以全局引入scss的步骤]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>sass</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex基本使用]]></title>
    <url>%2Fpost%2Fvuex-basic%2F</url>
    <content type="text"><![CDATA[前言 在使用Vue.js制作项目时，有时发现一些变量和参数需要在多个组件之间进行使用，且组件A中该参数的改变需要同时使组件B发生相应更新；因此就需要在这些组件能够共同访问的地方定义公共参数。 之前使用过一个『不太好』的方法，就是直接在Vue对象（准确来说相当于Vue class）的prototype上添加需要使用的公共变量，因此所有Vue实例（包括组件，因为组件实际上也是Vue实例？）都可以继承并访问到这个属性，也就可以在多个组件间进行使用。然而这里实际上有个『坑』，理解原型链就能知道，对Vue实例的属性进行改变并不会影响到Vue的prototype同名属性，自然也就无法对其他组件进行及时更新；这么做也无法使用Vue本身的数据依赖机制，但是如果那个公共属性是常量的话完全可以使用上述方法。 Vuex Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 简言之，Vuex就是用来在Vue中管理组件状态的官方工具。 基本概念 State 相当于Vue实例或组件中的data属性，在组件中可以通过this.$store.state来访问获取相应的state属性； Getter 相当于Vue实例或组件中的computed属性，定义一个方法来对某一个或多个state进行处理，并返回相应的值，因此该方法依赖于用到的state属性，只要依赖的state属性没有发生改变，该getters的值就不会发生改变；在组件中可以通过this.$store.getters来访问获取相应的getters属性； Mutation 为了方便进行管理数据依赖，并不能直接对store里的state进行直接更改，唯一的方法就是使用mutations里注册的方法进行相应更改；因此mutations就相当于Vue实例或组件中的methods属性，并且类似于组件中的自定义事件，需要使用的时候要『触发』相应的方法，即在组件中要使用this.$store.commit('type', payload)，其中type就是mutations中定义的方法名，prelaod就是需要传给该方法的参数。需要注意的是在mutations中的方法必须是同步的，即不能有异步回调！！！ Action 跟mutations类似，actions也相当于Vue实例或组件中的methods属性；但是actions里的方法一般都是执行异步回调操作，并在回调完成后执行commit操作来『触发』mutations中的方法。在组件中可以使用this.$store.dispatch('type', payload)来『触发』相应的actions方法。 响应式获取状态 在组件中如果要响应式地依赖状态值，那么最好在computed属性中返回一个状态，这样状态一旦改变，这边的值也会相应的更新。如： 12345678910export default &#123; computed: &#123; playing()&#123; return this.$store.state.playing &#125;, song()&#123; return this.$store.getters.curSong &#125; &#125;&#125; 参考文档 Vuex 是什么？ | Vuex]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[client、offset、scroll相关属性]]></title>
    <url>%2Fpost%2Foffset-client-scroll%2F</url>
    <content type="text"><![CDATA[在动态获取元素的位置和鼠标位置时，总是被诸如offset、client和scroll等种类所困惑，这些位置属性之间到底有什么差异，到底我该怎样获取我想要的位置。 offset相关属性 offsetWidth：元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、（可见的）垂直滚动条的宽度、左边框宽度和右边框宽度。 offsetHeight：元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、（可见的）水平滚动条的高度、上边框高度和下边框高度。 offsetTop：元素的上外边框至包含元素的上内边框之间的像素距离。 offsetLeft：元素的左外边框至包含元素的左内边框之间的像素距离。 什么是当前元素的包含元素？可以理解为父级DOM结点中离得最近的具有大小（宽高不为0）的元素，可以通过offsetParent属性来访问这个包含元素！ client相关属性 clientWidth：元素内容区宽度加上左右内边距（padding）宽度； clientHeight：元素内容区高度加上上下内边距（padding）高度； clientTop：元素的上边框的高度，以像素表示；若上下两端出现水平滚动条，则应加上滚动条的高度。 clientLeft：元素的左边框的宽度，以像素表示；若左右两侧出现垂直滚动条，则应加上滚动条的宽度。 scroll相关属性 scrollWidth：元素内容的总宽度，包含滚动内容的宽度； scrollHeight：元素内容的总高度，包含滚动内容的高度； scrollTop：被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。 scrollLeft：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。 MouseEvent中的相关属性 MouseEvent对象即专门用来处理鼠标事件的事件对象；其中有些属性与上面的DOM属性有关； offsetX：鼠标x位置距离元素左内边框的距离； offsetY：鼠标y位置距离元素上内边框的距离； clientX：鼠标位于元素客户端区域（client dimension）中的x坐标； clientY：鼠标位于元素客户端区域（client dimension）中的y坐标； screenX：鼠标在整个屏幕中的x坐标； screenY：鼠标在整个屏幕中的y坐标； pageX：鼠标位于整个文档（包括水平和垂直滚动条滚动的内容）的水平（x）位置； pageY：鼠标位于整个文档（包括水平和垂直滚动条滚动的内容）的垂直（y）位置； 以上属性都是只读属性，所以改动并不会使鼠标位置发生改变！！！元素客户端区域指的是元素内容及其内边距所占据的空间。 参考文档 JS中client/offset/scroll等的宽高解析 | Visugar个人博客 MouseEvent() - Web API 接口 | MDN MouseEvent.offsetX - Web API 接口 | MDN MouseEvent.clientX - Web API 接口 | MDN MouseEvent.screenX - Web API 接口 | MDN MouseEvent.pageX - Web API 接口 | MDN 《JavaScript高级程序设计（第3版）》——12.2.3 元素大小]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>DOM</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3伪元素探究：before和after]]></title>
    <url>%2Fpost%2Fcss-before-after%2F</url>
    <content type="text"><![CDATA[::before和::after伪元素在网页中有着各种的应用，比如清除浮动，作为字体图标等进行使用；但是一直很好奇这两个伪元素与设置元素（设置元素指的是设置伪元素的依赖元素）之间到底是何种关系，以及相当于何种标签元素。 before和after伪元素的默认属性 ::before和::after伪元素实际上就是在设置元素内处于『特殊』位置的子元素。 样式 ::before和::after伪元素的默认css样式就相当于行内元素，与&lt;span&gt;元素类似。 位置 ::before伪元素就相当于在设置元素内通过prepend（即前插）的方式插入一个行内元素；同理，::after伪元素相当于在设置元素内通过append（即后插）的方式插入的一个行内元素。 文本 ::before和::after伪元素可以通过content属性来设置显示的文本，就相当于DOM节点的innnerText属性。 before和after伪元素的使用 其实知道这两个伪元素的性质之后，基本上就可以把它们视为普通的行内元素来使用，只不过不需要通过在html代码中添加，而是通过css样式来控制，甚至可以『批量』控制。而且作为『特殊』性质的默认位置，也可以通过position属性来轻松改变。]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svg之文本]]></title>
    <url>%2Fpost%2Fsvg-text%2F</url>
    <content type="text"><![CDATA[基本概念 字符：在XML文档中，字符是指带有一个数字值的一个或多个字节，数字值与Unicode标准对应。例如，字母g是Unicode值为103的字符。 符号：符号（glyph）是指字符的视觉呈现。每个字符都可以用很多不同的符号来呈现。 一个符号可能由多个字符构成。一些字体为特定的字母组合（如fl和ff）准备了单独的符号，以使它们更好看，这种特性叫作“连字”（ligature）。有时候，一个字符也可能由几个符号组合而成，比如打印程序可能会组合符号e和重音符号（ˊ）来打印字符é（Unicode 值为 233）。 字体：字体是指代表某个字符集合的一组符号。 基线：字体中的所有符号以基线对齐。需要注意的是，中文字体中的基线概念并没有西文字体那么明确。 上坡度：基线到字体中最高字符顶部的距离称为上坡度（ascent）。 下坡度：基线到最深字符底部的距离称为下坡度（descent）。 em高度：字符的总高度为上坡度和下坡度之和，也称为em高度。 em box：指宽度为em高度的方块。 大写字母高度：大写字母高度（cap-height）是指基线上的大写字母的高度。 x高度：指基线到小写字母x顶部的高度。x 高度通常能比em高度更好地衡量一个字体的尺寸和可读性。 属性设置 基本属性 svg字体的基本属性与css的属性基本一致： font-family： font-size： font-weight： font-style： text-decoration： word-spacing： letter-spacing： 文本方向 可以通过writing-mode属性（css3中也有这个属性）来设置文本排列的方向，如从右往左，从上往下等等；不过在svg中writing-mode属性使用的选项值是按照IE的规则： 1-ms-writing-mode: lr-tb | rl-tb | tb-rl | bt-rl | tb-lr | bt-lr | lr-bt | rl-bt | lr | rl | tb 不过在实际使用中这些属性值貌似不是每一个都被支持，只有tb（top to bottom，纵向排列）是被支持的： 文本对齐 可以通过设置&lt;text&gt;元素的x，y属性来确定文本的起点位置，而根据不同的对齐方式，字体符号所呈现的方式有所不同；可以通过text-anchor属性来设置文本与起点坐标的关系，text-anchor属性有以下几个选项： start（默认值）：以文本从左往右排列为例，x表示该文本第一个符号的em box的左侧位置，而y表示基线位置； middle：同理，x表示该文本的水平中点位置，而y表示基线位置； end：x表示该文本最后一个符号的em box的右侧位置，而y表示基线位置； 文本路径 通过在&lt;text&gt;元素内使用&lt;textPath&gt;元素可以为文字指定一条path，并按照path的形状进行文字排列；使用方法如下： 12&lt;path d="M100 200h150 v100" id="pathID" fill="none"&gt;&lt;/path&gt;&lt;text&gt;&lt;textPath xlink:href="#pathID"&gt;一段文字&lt;/textPath&gt;&lt;/text&gt; 这样textPath内包含的文字就会按照所指定的#pathID路径进行排列，这里既可以指定定义在&lt;defs&gt;内的路径，也可以是实际出现过的路径；需要注意的是只能是&lt;path&gt;元素所定义的路径，像诸如&lt;rect&gt;这样的基本形状是不能被指定为路径的！ 文本长度 在&lt;text&gt;元素内文本并不会由于超过某一长度就会自动换行，也无法事先知道文本的终点在哪，但是可以通过textLength来控制文字的总长度（若文字原长度超过总长度也会被『压缩』在总长度内），并通过lengthAdjust属性来设置文本符号之间的间距和符号自身的大小；lengthAdjust属性有以下选项： spacing（默认值）：只调整符号之间的间距，而不会改变符号本身的尺寸大小；因此当设置的textLength小于文本原有长度时，字符的间距为『负』，也就是会被挤压重叠到一块： spacingAndGlyphs：间距和符号本身的大小一起调整，按比例缩放。 tspan元素 &lt;tspan&gt;元素有点类似html中的行内元素&lt;span&gt;，可以用来对&lt;text&gt;内的一段文本进行单独调整；除了基本的文字样式之外，&lt;tspan&gt;元素还可以调整文本的位置和变形。 位置调整 x，y：指定绝对位置坐标； dx，dy：指定相对位置坐标； 需要注意的是，设置以上属性会影响该&lt;tspan&gt;后面的文本！ baseline-shift：调整文本符号的基线位置，可以是一个长度值，也可以是super（上标）和sub（下标）；该属性只会对&lt;tspan&gt;内产生作用！ 变形 rotate：对&lt;tspan&gt;内的每个文本符号进行旋转（单独地？），单位为度数。 参考文档 改变CSS世界纵横规则的writing-mode属性 « 张鑫旭-鑫空间-鑫生活 《SVG精髓（第2版）》]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>svg</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svg之渐变填充]]></title>
    <url>%2Fpost%2Fsvg-gradient%2F</url>
    <content type="text"><![CDATA[与图案（pattern）一样，渐变也只是专门用来被填充的，所以也需要事先在defs中进行定义。 SVG中的渐变分为线性渐变（linearGradient）和径向渐变（radialGradient）两种，从名字就能看出这是两种不同方向的渐变，所以参数也会有所不同。 线性渐变 线性渐变由linearGradient标签所定义，线性渐变主要受直线的方向和渐变点的位置的影响，也就是沿着直线的方向按照渐变点的颜色设置进行变化。 渐变点 渐变点就是在linearGradient标签内所定义的&lt;stop&gt;元素，该元素有以下的属性： offset：偏离位置，范围为0-1（0%-100%）；实际上就是在直线方向（这个方向其实可看作向量方向）上的位置。 stop-color：该渐变点的颜色 stop-opacity：该渐变点的不透明度 12345678&lt;defs&gt; &lt;linearGradient id="lg1"&gt; &lt;stop offset="0%" stop-color="#ff3366"&gt;&lt;/stop&gt; &lt;stop offset="100%" stop-color="#3366ff"&gt;&lt;/stop&gt; &lt;/linearGradient&gt;&lt;/defs&gt;&lt;rect x="50" y="50" width="300" height="60" fill="url(#lg1)"&gt;&lt;/rect&gt; 上面的示例就是在首尾两端（即0%和100%处）各定义了一个不同颜色的渐变点。 1234567&lt;defs&gt; &lt;linearGradient id="lg1"&gt; &lt;stop stop-color="#36f" stop-opacity="1" offset="0"&gt;&lt;/stop&gt; &lt;stop stop-color="#36f" stop-opacity="0.2"offset="0.618"&gt;&lt;/stop&gt; &lt;stop stop-color="#36f" stop-opacity="0" offset="1"&gt;&lt;/stop&gt; &lt;/linearGradient&gt;&lt;/defs&gt; 而这个示例不仅在首尾两端，还在中间设置了一个渐变点；这里的渐变点颜色都是一致的，只是每个渐变点的不透明度是不相同的。 直线方向 默认情况下的直线方向是从左端的中点(0%, 50%)指向右端的中点(100%, 50%)的。如下图所示： 可以通过设置直线的起点(x1,y1)和终点(x2,y2)的位置（这里的单位为比例大小，相对于被填充元素的大小而言）来控制线性渐变的方向： x1：起点的x坐标，范围为0-1（0%-100%）； y1：起点的y坐标 x2：终点的x坐标 y2：终点的y坐标 注：这里的单位也可以设置为用户坐标系的单位，通过设置gradientUnits属性即可；默认属性值为objectBoundingBox，设置为userSpaceOnUse即可使用用户坐标系的单位！ 123456&lt;defs&gt; &lt;linearGradient id="lg1" x1="0" y1="0" x2="1" y2="1"&gt; &lt;stop offset="0%" stop-color="#ff3366"&gt;&lt;/stop&gt; &lt;stop offset="100%" stop-color="#3366ff"&gt;&lt;/stop&gt; &lt;/linearGradient&gt;&lt;/defs&gt; 上面的示例当中，把起点设置在(0,0)，终点设置在(1,1)，也就是从左上角到右下角进行渐变。 过渡填充：spreadMethod属性 因为可能出现指定的起始点并没有覆盖被填充元素全部范围的情况，因此没有被定义渐变的区域该如何进行填充就可以通过spreadMethod属性来设置： pad（默认值）：没有定义渐变的区域直接按照起始点的渐变颜色进行填充，即相当于未定义渐变的区域只有单色填充； repeat：即定义渐变的区域会首尾相连（即起始点0%外侧相连的是100%处，反之终点100%的外侧相连的是0%处）的方式对未定义渐变的区域进行填充； reflect：镜像填充，即首和首相连，尾和尾相连； 径向渐变 径向渐变则是由radialGradient标签进行定义的，径向渐变则受渐变点的位置与焦点的位置所控制。 渐变点 与线性渐变的渐变点不同的是，径向渐变的渐变点偏移的位置（offset）是相对于从焦点（0%）到最外层的圆弧（100%）之间的。 offset：范围依然是0-1（0%-100%）2x3 12345678&lt;defs&gt; &lt;radialGradient id="rg1"&gt; &lt;stop offset="0%" stop-color="#ff3366"&gt;&lt;/stop&gt; &lt;stop offset="50%" stop-color="#66ff99"&gt;&lt;/stop&gt; &lt;stop offset="100%" stop-color="#3366ff"&gt;&lt;/stop&gt; &lt;/radialGradient&gt;&lt;/defs&gt;&lt;rect x="50" y="50" width="100" height="100" fill="url(#rg1)"&gt;&lt;/rect&gt; 上例定义了三个渐变点（0%，50%，100%），其中『圆心』、『半径』和『焦点』默认参数为： 属性 默认属性值 cx 50%（相对于被填充元素的大小，下同） cy 50% r 50% fx 与cx相同（注意并非指的是50%，而是跟cx的设置值相同！） fy 与cy相同 因此，默认情况下，『圆心』在元素正中心(50%,50%)，而『焦点』就在『圆心』处，『半径』为元素长宽的一半；也就是说，默认情况下0%处就在『圆心』，而最外层的圆弧即为元素边框的内切圆： 径向设置：『圆心』、『半径』和『焦点』 不像线性渐变那样直接通过起始点的方向来控制渐变的方向，径向渐变是通过焦点到最外层圆弧的方向来控制渐变的方向，这就是所谓的『径向』。在这里，『圆心』的作用就是和『半径』一起定义最外层圆弧位置的；当『焦点』使用默认值时，实际上就是由『圆心』向『最外层圆弧』进行渐变的。但是如果『焦点』改变时，比如下面这个： 12345678&lt;defs&gt; &lt;radialGradient id="rg1" cx="0" cy="0" r="1" fx="0.5" fy="0.5"&gt; &lt;stop offset="0%" stop-color="#ff3366"&gt;&lt;/stop&gt; &lt;stop offset="50%" stop-color="#66ff99"&gt;&lt;/stop&gt; &lt;stop offset="100%" stop-color="#3366ff"&gt;&lt;/stop&gt; &lt;/radialGradient&gt;&lt;/defs&gt;&lt;rect x="50" y="50" width="100" height="100" fill="url(#rg1)"&gt;&lt;/rect&gt; 『圆心』位置为(0,0)，『半径』为1（也就是元素本身的大小），而『焦点』位置为(0.5,0.5)；所以渐变的方向就是从正中心的『焦点』（蓝色点）指向『最外层圆弧』（黑色圆弧），而『焦点』处为0%，『最外层圆弧』处为100%！而没有改变『焦点』的效果如下： spreadMethod 同线性渐变中的设置！ 渐变引用 可以在渐变的定义中直接引用已经定义好的同一类型的渐变，使用的是xlink:href属性，如： 12345&lt;linearGradient id="lg1" x1="0.2" x2="0.8"&gt; &lt;stop offset="0%" stop-color="#ff3366"&gt;&lt;/stop&gt; &lt;stop offset="100%" stop-color="#3366ff"&gt;&lt;/stop&gt;&lt;/linearGradient&gt;&lt;linearGradient id="lg2" xlink:href="#lg1" spreadMethod="repeat"&gt;&lt;/linearGradient&gt; 参考文档 《SVG精髓（第2版）》]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>svg</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svg之图案填充]]></title>
    <url>%2Fpost%2Fsvg-pattern%2F</url>
    <content type="text"><![CDATA[在SVG中的图案（pattern），可以理解为通过重复填充某一图形得到的图像。因此被重复填充的那个图形可视为图案的填充单元（tile，直译就是瓷砖），最终得到的图案就取决于如何在整个图案区域中重复这一填充单元以及在分配到的单元格中如何填充这个图形。 图案的使用 定义 需要在defs标签内进行定义，然后必须要使用pattern标签包裹path，这样才算是定义了一个图案，也就是说pattern标签内所包裹的所有path标签组成了填充单元；比如： 123456&lt;defs&gt; &lt;pattern id="t1" x="0" y="0" width="20%" height="20%" patternUnits="objectBoundingBox"&gt; &lt;path d="M 0 0 Q 5 20 10 10 T 20 20" style="stroke: black; fill: none;"&gt;&lt;/path&gt; &lt;path d="M 0 0 h 20 v 20 h -20 z" style="stroke: gray; fill: none;"&gt;&lt;/path&gt; &lt;/pattern&gt;&lt;/defs&gt; 使用 使用的时候需要在fill属性中指定图案的路径，可以使用url()来指定；如： 12345&lt;g id="pattern1"&gt; &lt;rect x="20" y="20" width="100" height="100" style="fill: url(#t1); stroke: black;"&gt;&lt;/rect&gt; &lt;rect x="135" y="20" width="60" height="80" style="fill: url(#t1); stroke: black;"&gt;&lt;/rect&gt; &lt;rect x="220" y="20" width="150" height="130" style="fill: url(#t1); stroke: black;"&gt;&lt;/rect&gt;&lt;/g&gt; 图案的设置 patternUnits patternUnits属性定义了图案是如何分配重复单元格的，需要配合width和height属性来使用。 属性值 作用 objectBoundingBox （默认值） 此时单元格的大小按比例计算，即被填充的元素大小为100%，单元格的大小由width和height决定，取值为比例；比如当width='0.1'时，代表一个单元格的宽度为元素宽度的10%，height也同理； userSpaceOnUse 此时单元格的大小按用户坐标系的单位计算，并且直接铺放在用户空间（即SVG容器内），只不过铺放的起始位置需要通过x和y属性进行设定；因此在该模式下的图案被使用时实际上与元素的位置相关，就像在固定的图像上截取某一块区域一样！ patternContentUnits patternContentUnits属性则是用来定义在一个单元格内如何填充tile，即决定图案内所定义的图形（即path标签）使用的单位是什么。 属性值 作用 objectBoundingBox 此时图形绘制的单位按比例来计算，即以被填充的元素大小（而非单元格的大小！）为100%，以此进行推算，因此在该模式下path内的数值需要换算成比例，不然会超出！ userSpaceOnUse （默认值） 此时图形绘制按照用户坐标系的单位进行计算，并且图形的原点（0,0）位于此单元格的左上角！ 举个栗子 例1 假设使用一个实际大小为20x20的填充单元： 当patternUnits属性设置为objectBoundingBox，patternContentUnits属性设置为userSpaceOnUse，width为0.2，height为0.2时，对元素进行填充的效果为： 123456789&lt;svg width="200" height="200" id="container"&gt; &lt;defs&gt; &lt;pattern id="t1" x="0" y="0" width="0.2" height="0.2" patternUnits="objectBoundingBox" patternContentUnits="uesrSpaceOnUse"&gt; &lt;path d="M 0 0 Q 5 20 10 10 T 20 20" style="stroke: black; fill: none;"&gt;&lt;/path&gt; &lt;path d="M 0 0 h 20 v 20 h -20 z" style="stroke: gray; fill: none;"&gt;&lt;/path&gt; &lt;/pattern&gt; &lt;/defs&gt; &lt;rect height="100" width="100" x="50" y="50" fill="url(#t1)"&gt;&lt;/rect&gt;&lt;/svg&gt; 分析：由于patternUnits属性设置为objectBoundingBox，所以单元格大小是按照元素的比例进行分配，width和height都为0.2，表明单元格的大小相当于元素大小的20%，而元素大小为100x100，因此得到的单元格大小为20x20，刚好与填充图形的大小一样。而patternContentUnits属性设置为userSpaceOnUse，即表明单元格内使用的单位为用户坐标系的单位（一般默认为px）。 如果将上述中的元素大小改为130x120时，效果如下： 分析：同上，分配到的单元格大小为27.5x24，而绘制的图像只有20x20，因此会出现空余的间隔，而不是想象的填满。 如果将上述中的元素大小改为80x70时，效果如下： 分析：同上，分配到的单元格大小为16x14，而绘制的图像大小为20x20，因此单元格的大小不够绘制，在单元格范围外的部分就不会被显示！ 例2 同样使用上面20x20的填充图形；当patternUnits属性设置为userSpaceOnUse，patternContentUnits属性设置为userSpaceOnUse，width为20，height为20时，x=0，y=0，对元素进行填充的效果为： 分析：由于patternUnits属性设置为userSpaceOnUse，所以单元格的分配实际上就放到SVG画布中去了，与元素本身无关了；width和height都为20，所以单元格的大小为20x20，然后设置的x和y都为0，也就是说图案填充的起点为(0,0)；因此实际上就相当于在画布中(0,0)的开始填充大小为20x20的图形，然后元素所在位置(50,50)截取一块大小为元素本身大小100x100的图案作为填充图案！ 从画布(0,0)开始填充： 然后截取从(50,50)开始截取一块大小为100x100的区域： 如果将width和height改为10x10，其他的都不变，效果如下： 分析：同上，由于单元格的大小变成了25x25，所以在单元格内绘制填充单元后还有剩余空间，所以看起来就有间隔了。 如果保持单元格大小为25x25，而x和y的坐标变为(15,15)，效果如下： 分析：同上，实际上就是图案在画布上的填充起点发生了改变了，变成了下面这样： 可以看到，填充的方向实际上是由起点向四周进行，而不是只向右和下进行！ 例3 当patternUnits属性设置为objectBoundingBox，patternContentUnits属性设置为objectBoundingBox，width为0.2，height为0.2时，如果还是使用上面20x20的填充图形；那么对元素进行填充的效果就会变成： 123456789&lt;svg width="200" height="200" id="container"&gt; &lt;defs&gt; &lt;pattern id="t1" width="0.2" height="0.2" patternUnits="objectBoundingBox" patternContentUnits="objectBoundingBox"&gt; &lt;path d="M 0 0 Q 5 20 10 10 T 20 20" style="stroke: black; fill: none;"&gt;&lt;/path&gt; &lt;path d="M 0 0 h 20 v 20 h -20 z" style="stroke: gray; fill: none;"&gt;&lt;/path&gt; &lt;/pattern&gt; &lt;/defs&gt; &lt;rect width="100" height="100" x="50" y="50" fill="url(#t1)"&gt;&lt;/rect&gt;&lt;/svg&gt; 分析：patternUnits为objectBoundingBox，且width和height都为0.2，元素本身大小为100x100，因此单元格大小为20x20；但是问题是patternContentUnits为objectBoundingBox，因此图案内部绘制时的单位为比例，而填充图形内stroke-width为1，也就是说stroke-width的大小实际上为整个元素的大小，因此也就超出了整个单元格！所以需要对填充图形内的path中的单位进行修正，全部转化为比例： 1234&lt;pattern id="t1" width="0.2" height="0.2" patternUnits="objectBoundingBox" patternContentUnits="objectBoundingBox"&gt; &lt;path d="M 0 0 Q 0.05 0.20 0.1 0.1 T 0.20 0.20" style="stroke: black; fill: none;stroke-width: 0.01;"&gt;&lt;/path&gt; &lt;path d="M 0 0 h 0.20 v 0.20 h -0.20 z" style="stroke: gray; fill: none;stroke-width: 0.01;"&gt;&lt;/path&gt;&lt;/pattern&gt; 修正填充图形后的效果为： 如果将元素大小改为130x120后，效果如下： 分析：同理，单元格大小为27.5x24，但是由于图案内部的填充图形只有0.2的比例大小，而正好与单元格的大小比例一致，因此填充之间没有出现间隙；可以把width和height的大小设置为0.25，此时单元格比例和图案内部的图形的比例不一致，可以看看此时的效果： 可以看到填充的图案并没有按比例进行，因为图案内部的填充图形本身只用了0.2的比例大小，而这个比例是对于被填充元素的本身大小而言，所以此时填充图形并没有单元格大小那么大！所以就相当于单元格内看起来有空余部分。（P.S：这里真的很有疑问，为啥不把比例相对于单元格进行设计，而是非得相对于被填充元素本身？难道不是对于单元格进行比例设计会更方便一些吗？！！） 例4 当patternUnits属性设置为userSpaceOnUse，patternContentUnits属性设置为objectBoundingBox，width为20，height为20时，x和y都为0，使用按比例进行修正的填充图形，效果如下： 123456789&lt;svg width="200" height="200" id="container"&gt; &lt;defs&gt; &lt;pattern id="t1" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse" patternContentUnits="objectBoundingBox"&gt; &lt;path d="M 0 0 Q 0.05 0.20 0.1 0.1 T 0.20 0.20" style="stroke: black; fill: none;stroke-width: 0.01;"&gt;&lt;/path&gt; &lt;path d="M 0 0 h 0.20 v 0.20 h -0.20 z" style="stroke: gray; fill: none;stroke-width: 0.01;"&gt;&lt;/path&gt; &lt;/pattern&gt; &lt;/defs&gt; &lt;rect width="100" height="100" x="50" y="50" fill="url(#t1)"&gt;&lt;/rect&gt;&lt;/svg&gt; 分析：需要注意的是，这里的单元格仍然是在画布上进行排列，但是对于填充图形的绘制则是相当于被填充元素本身的大小按照比例进行的，而图案内部的填充图形比例为0.2，所以只是刚好与单元格的大小相匹配而已！如果把单元格大小设置为25x25，效果如下： 可以看到单元格分布确实是截取画布上进行排列过的，但是单元格内的填充元素确实是按照被填充元素大小进行比例绘制的，可以通过两个完全不同大小的元素填充上述的图案进行对比： 如图，填充元素大小为200x200和100x100的单元格分布时是一致的，但是可以明显看到填充的图案不同；填充元素大小为200x200时，由于图案内部的填充图形只占了0.2的比例，所以此时绘制出来后大小则为40x40；同理当填充元素大小为100x100时，绘制出来后的大小为20x20，因此图案完全不同！ 例子总结 当使用patternContentUnits属性的objectBoundingBox时，尤其需要注意图案绘制时的比例大小是相对于被填充元素本身的！ 图案的嵌套 一个被定义的图案，可以在其他图案的填充图形中被使用（即在内部的元素中使用fill属性即可），这就是图案的嵌套。 参考文档 《SVG精髓（第2版）》]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>svg</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3 3D transform]]></title>
    <url>%2Fpost%2Fcss3-transform-3d%2F</url>
    <content type="text"><![CDATA[transform是css3新增的功能，可以用来改变元素的形状和位置，分为2D和3D两种，实际上2D变换可以看做是3D变换的一种特殊形式。 原理 可以联想到计算机图形中的摄像机与物体的空间关系，以及透视投影原理，就能理解3D transform的基本原理了。 透视投影原理 透视投影的标准模型 3D坐标系 在浏览器中，一般二维坐标系的原点为左上角，而三维坐标系z轴的方向是由屏幕向外增大的，除此之外x轴和y轴的方向与二维坐标系无异。所以屏幕所在平面就相当于z=0平面。 perspective属性 perspective属性的值相当于视点（应该是投影平面）离屏幕（z=0平面）的距离，距离越远则成像的效果越接近于平行投影，也就是越没有立体效果，反之则更具有立体效果；需要注意的是该属性作用于其子元素，因此常放置在容器元素中！ 一般要体现出立体效果，还需要结合translateZ来对元素的z坐标进行控制； perspective-origin属性 perspective-origin属性表示视点在成像平面（即屏幕）所在的位置，默认为center center，即平面的正中心位置。参数值选项与transform-origin一样，只不过没有z轴的参数（？）。 transform-style属性 通过设置transform-style的属性，可以控制其子元素的呈现方式，也就是投影方式。当属性为flat（默认值）时，其子元素为2D呈现，即平行投影；当属性为preserve-3d时，为3D呈现，即透视投影。由于其作用在其子元素上，所以一般用来当做立体容器来使用。 transform-origin 顾名思义，transform-origin属性就是用来设置元素的坐标原点位置，而transform的变换需要依靠坐标原点。其默认值为center center，即元素的正中心；而在三维变换中，还有另一个transform-origin-z属性用来设置原点的z轴坐标，其默认值为0，即屏幕平面；transform-origin-z属性目前只有谷歌浏览器支持，所以需要加-webkit-前缀。不过，transform-origin是可以接受第三个参数的，其默认值也是0！ 参数值： 值 描述 x-axis 定义视图被置于 X 轴的何处。可能的值： left center right length % y-axis 定义视图被置于 Y 轴的何处。可能的值： top center bottom length % z-axis 定义视图被置于 Z 轴的何处。可能的值： length backface-visibility属性 backface-visibility属性决定元素旋转后背面是否可见，默认值为visible（可见），设置为hidden后背面不可见。 基本变换类型 其实学过计算机图形就差不多知道，在三维空间中，物体自身的所有变换都可以通过一个4x4的变换矩阵来表示： 二维的变换可以用一个3x3矩阵来表示： 计算方式就是将变换矩阵与元素的二维或三维坐标进行相乘，就能得到变换后的新坐标： 所有的变换都是以transform-origin属性值作为坐标原点，然后计算的。 translate 即平移，平移就是相对于目前位置发生偏移；有translate()，translateX()，translateY()，translateZ()，translate3d()这几种可供选择。 rotate 即旋转，依照旋转轴（如X轴）对元素进行旋转；变换函数名字与上面类似。 scale 即缩放，相对于目前的坐标对点的坐标进行相应的放大或缩小；变换函数与上面类似。 skew 即错切，通过在X轴方向（水平方向）上平移x坐标或在Y轴方向（垂直方向）上平移y坐标形成倾斜；只有二维的变换函数skew()，skewX()和skewY()； matrix 定义变换矩阵，分为matrix()（即二维的，3x3矩阵）和matrix3d()（即三维的，4x4矩阵）。可以说矩阵变换是上述所有变换的基础，即上述所有变换都可以通过矩阵变换实现！ 参考文档 CSS3 transform-origin 属性 CSS3 Transform-3D空间变换成像原理浅析 - w3ctech 透视投影的原理和实现 - CSDN博客 css3 transform matrix 深入理解 - CSDN博客]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js拖拽移动效果]]></title>
    <url>%2Fpost%2Fjs-drag-move%2F</url>
    <content type="text"><![CDATA[需求 有时候需要对某一元素进行拖拽，并要求在拖拽过程中跟随鼠标进行移动；比如下面的效果： 实现 可以依靠mousedown，mousemove和mouseup三个js原生事件来实现；除了被拖动的元素之外，还需要一个用来充当『容器』的元素，被拖动的元素为『容器』元素的子元素； 为需要被拖动的元素绑定mousedown事件，并在mousedown事件中为『容器』元素绑定mousemove元素； 根据具体需求和event对象的clientX以及clientY属性，在mousemove事件中更新被拖动元素的位置； 为『容器』元素绑定mouseup事件，且在mouseup事件中移除『容器』元素的所有mousemove事件！ why? 为什么是对『容器』元素绑定mousemove事件，而不是直接对被拖动的元素进行绑定？ 因为被拖动的元素（实时更新位置后）跟不上鼠标移动的速度，所以很有可能鼠标在拖动过程中超出了被拖动元素本身的范围，导致拖动停止！ 为什么是对『容器』元素绑定mouseup事件，而不是直接对被拖动的元素进行绑定？ 同上，鼠标若移出被拖动元素的范围后再松开按键就不会奏效！ 移动端的实现 在移动端是没有mousedown,mousemove,mouseup事件的，但是有相对应的移动端事件：touchatart、touchmove、touchend；所以移动端的原理也是类似的。 参考文档 JavaScript实现最简单的拖拽效果 « 张鑫旭-鑫空间-鑫生活 js实现一个可以兼容PC端和移动端的div拖动效果 - 最骚的就是你 - 博客园]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svg基本使用]]></title>
    <url>%2Fpost%2Fsvg-basic%2F</url>
    <content type="text"><![CDATA[基本概念 SVG（Scalable Vector Graphics），即可缩放矢量图形，用于描述二维矢量图形；SVG是基于XML制定的，因此遵循XML语法。 坐标系统 SVG的坐标系统跟canvas以及window的一样，都是以左上角为原点，X轴向右变大，Y轴向下变大； 视口（viewPort） 视口就是指SVG画布所呈现的大小，即实际尺寸；可以通过属性width和height来设置，也可以通过style来设置。默认长度单位为px，其它单位有em,ex,pt,cm,mm,in等。 viewBox viewBox可以理解为设置SVG画布的坐标刻度；viewBox属性有四个参数，分别是x轴刻度最小值，y轴刻度最小值，x轴总长度，y轴总长度。坐标刻度铺满整个画布，并等比例缩放，因此并不总是1：1的比例！ 12&lt;svg width="500" height="500" viewBox="-100 -100 500 500"&gt;&lt;/svg&gt; 上例中的SVG画布的视口大小为500x500，而坐标的左上角为（-100，-100），坐标系的总大小为500x500；所以可以理解为画布的右下角坐标为（400，400），左上角坐标为（-100，-100）。 基本形状 SVG基本形状有line（线段），polyline（折线段），rect（矩形），polygon（多边形），circle（圆形），ellipse（椭圆）；基本属性如下： 坐标系统变换 在SVG中可以对某一图形添加transform属性来实现坐标变换，就类似于CSS3中的transform；基本使用方法如下： SVG中使用的坐标变换原理：先对当前坐标系进行一系列变换（按变换序列的顺序进行），然后把图形按变换前的坐标位置放到变换后的坐标系中！ 矩阵变换参数： 路径 所有的基本形状指令都是基于path标签来实现的，因此path可谓是SVG的画图指令之精髓。 path通过在d属性中使用一系列指令来描绘各种线段或曲线；其中大写的指令使用的是绝对坐标，而小写的坐标使用的是相对坐标（即相对当前点的位移）；具体指令用法如下： 注：路径命令必须要以M开头，若以m开头也是自动使用绝对坐标！闭合路径使用Z，大小写效果是一样的。 椭圆弧 椭圆弧绘制由7个参数确定： 点所在椭圆的 x 半径和 y 半径。 椭圆的 x 轴旋转角度x-axis-rotation。 large-arc-flag，如果需要圆弧的角度小于180度，其为0；如果需要圆弧的角度大于或等于180度，则为1。 sweep-flag，如果需要弧以负角度绘制则为 0（逆时针），以正角度绘制则为 1（顺时针）。 终点的 x 坐标和 y 坐标（起点由最后一个绘制的点或者最后一个 moveto 命令确定）。 原理： 贝赛尔曲线 二次贝赛尔曲线：包括起始点、终点和一个控制点 三次贝赛尔曲线：包括起始点、终点和两个控制点，其中两个控制点分别对应起点和终点！ 参考文档 《SVG精髓（第2版）》]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>svg</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js正则表达式]]></title>
    <url>%2Fpost%2Fjs-regexp%2F</url>
    <content type="text"><![CDATA[正则表达式是用于匹配字符串中字符组合的模式。在js中正则表达式即为RegExp对象； 构造正则表达式 方法一：pattern代表一个正则表达式（两个/之间）；flags代表匹配标志，可以由多个标志符组成！这样的一组符号（注意不是字符串）为字面量形式； 1var expression = / pattern / flags ; 匹配标志：可以单独使用，也可以多个不同的标志组合使用，如：i，gi,gm,gmi等； 标志符 作用 g 表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止； i 表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写； m 表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项 y 执行“粘性”搜索,匹配从目标字符串的当前位置开始（MDN） 方法二：直接用new构造一个RegExp对象； 12345678910/* new RegExp(pattern [, flags])*/let regex = new RegExp("ab+c");// 字面量形式let regex = new RegExp(/^[a-zA-Z]+[0-9]*\W?_$/, "gi"); // 字符串形式，省略 /let regex = new RegExp("^[a-zA-Z]+[0-9]*\\W?_$", "gi"); 正则表达式的组成 一个正则表达式可以包含字符类、限定符、分组、向前查找以及反向引用；其中有一些元字符代表着特殊含义，因此如果要匹配这些元字符就不得不转义，转义使用符号\； 方括号 方括号[]用来表示某一范围内的字符，如： 元字符 元字符与转义符一起使用，代表某类特定范围的字符集； 量词 量词对字符出现的次数和位置做出规定； 括号的作用 在正则表达式中可以使用括号(,)来围住一段表达式，又称为捕获括号，表示对相应的子匹配模式进行『记录』，并可以在某些返回数组中或特定变量中进行使用！ 12345// MDN 示例var re = /(\w+)\s(\w+)/;var str = "John Smith";var newstr = str.replace(re, "$2, $1");console.log(newstr); // Smith, John RegExp对象方法 test方法：按指定正则模式来判断字符串是否含有满足该模式的子串，返回true或false； 12// 匹配字符串是否满足国内手机号码的模式console.log(/^1[3|4|5|8]\d&#123;9&#125;$/.test("18329682154")); // true exec方法：在一个指定字符串中执行一个搜索匹配，返回一个结果数组或 null。当返回一个数组时，但此数组还包含两个额外的属性index和lastIndex，index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。 1234567891011var myRe = /ab*/g;var str = 'abbcdefabh';var myArray;while ((myArray = myRe.exec(str)) !== null) &#123; var msg = 'Found ' + myArray[0] + '. '; msg += 'Next match starts at ' + myRe.lastIndex; console.log(msg);&#125;// Found abb. Next match starts at 3// Found ab. Next match starts at 9 字符串中的正则表达式方法 match方法：与RegExp对象的exec()类似： 1str.match(regexp); search方法：类似于RegExp对象的test方法，如果匹配成功，则返回正则表达式在字符串中首次匹配项的索引，否则返回-1。 replace方法：返回一个由替换值替换一些或所有匹配的模式后的新字符串。模式可以是一个字符串或者一个正则表达式,替换值可以是一个字符串或者一个每次匹配都要调用的函数。该方法并不会改变原字符串！ 1str.replace(regexp|substr, newSubStr|function) 当使用字符串作为替换参数时，在字符串内可以使用一些特殊的变量： 变量名 代表的值 $$ 插入一个 “$”。 $&amp; 插入匹配的子串。 $` 插入当前匹配的子串左边的内容。 $’ 插入当前匹配的子串右边的内容。 $n 假如第一个参数是 RegExp对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。 当使用函数作为替换参数时，对每个匹配的子串调用该函数并使用该函数的返回值作为替换值。 该函数具有特定的参数名： 变量名 代表的值 match 匹配的子串。（对应于上述的$&amp;。） p1,p2, … 假如replace()方法的第一个参数是一个RegExp对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。） offset 匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1） string 被匹配的原字符串。 1234//一个替换函数示例function replacer(match, p1, p2, p3, offset, string) &#123; return [p1, p2, p3].join(' - ');&#125; split方法：使用指定的分隔符字符串或正则匹配模式将一个String对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。『相当于把分隔字符串敲掉，剩下的每截字符串组成结果数组？』 1str.split([separator[, limit]]) 当使用正则表达式作为分隔符时，表达式中若使用了捕获括号（capturing parentheses），则其匹配结果将会包含在返回的数组中。 12345// MDN示例var myString = "Hello 1 word. Sentence number 2.";var splits = myString.split(/(\d)/);console.log(splits); // [ "Hello ", "1", " word. Sentence number ", "2", "." ] 参考文档 JavaScript RegExp 对象 正则表达式 - JavaScript | MDN]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sass基本使用]]></title>
    <url>%2Fpost%2Fsass-use%2F</url>
    <content type="text"><![CDATA[注意：sass有两种文件格式，同时也是两种不同的语法体系，默认使用.scss的语法！ 基本操作 变量声明 形式为：$ + 变量名: value;，值可以是css的任意属性值（包括各种颜色）；如： 12345$blue: #3399ff;body&#123; backgrond-color: $blue;&#125; 需要注意的是属性值不必加引号！值还可以定义为列表（list）或映射（map）的形式，形成多值，可以按照索引进行取用，如： 123456789$color: #ff3366 #66ff99 #6699ff;.div1&#123; color: nth($color, 1);&#125;.div2&#123; color: nth($color, 3);&#125; 利用nth函数对变量进行指定索引的取值，索引从1开始；（当一些css属性值本身就是多个值用空格断开的时候，是否也可以把其当做列表？） 注释 sass中有两种注释风格，一种就是css中使用的那种/* */，另一种就是单行注释//（单行注释不会编译到css文件中）； 导入 在scss文件中可以导入工程内的其它scss文件（包括带_的文件），语法为： 1@import ('someFile'); 导入文件时不需要添加scss文件的后缀，也不需要添加_（若是以下划线_开头的文件）；导入后，就相当于把导入的文件中所有内容都添加到当前文件中！ 嵌套 在sass中代码可以嵌套，即在一个选择器内部再嵌入子选择器（最后并非一定是父子关系，但通常是这么做的）；如： 123456789101112131415nav &#123; ul &#123; margin: 0; padding: 0; list-style: none; &#125; li &#123; display: inline-block; &#125; a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125;&#125; 编译成正常css为： 123456789101112131415nav ul &#123; margin: 0; padding: 0; list-style: none;&#125;nav li &#123; display: inline-block;&#125;nav a &#123; display: block; padding: 6px 12px; text-decoration: none;&#125; &amp;符号 在嵌套的时候，有一个特殊符号&amp;代表该级选择器的父选择器（即嵌套的上一层选择器），如： 12345678a&#123; text-decoration: none; color: #333333; &amp;:hover&#123; color: #3366ff; &#125;&#125; 编译后的代码为： 1234567a &#123; text-decoration: none; color: #333333;&#125;a:hover &#123; color: #3366ff;&#125; 扩展/继承 通过@extend继承任何已定义的选择器样式（貌似与先后顺序无关，即前面定义的样式可以继承后面定义的样式），如： 1234567891011#div1&#123; background-color: #00ffdd; width: 100px; height: 100px;&#125;#div2&#123; @extend #div1; font-size: 14px; color: #000;&#125; 占位符 可以通过占位符%的形式来定义一个专门用来被继承的基础样式选择器，如： 12345678910%box&#123; border: 1px solid #3399ff; border-radius: 5px; padding: 5px;&#125;.box1&#123; @extend: %box; color: #333;&#125; 通过%定义的占位符选择器，只会在被继承使用的地方进行编译，本身并不会单独的编译成css代码！即如果没有一个选择器继承使用该占位符选择器的样式，该占位符选择器的内容是不会被编译的。 混合宏（mixin） 混合宏有点类似于函数，可接受一组参数（当然也可以定义无参数的），然后返回一段css代码，如： 12345@mixin box($style)&#123; -webkit-box-sizing: $style; -moz-box-sizing: $style; box-sizing: $style;&#125; 然后可以通过@include命令来引用定义的混合宏： 123#box&#123; @include box(border-box);&#125; 编译后为： 12345#box &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125; 参考文档 sass入门 - sass教程（w3plus） sass语法（w3plus）]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用coding.net搭建小程序的合法request域名]]></title>
    <url>%2Fpost%2Fweixin-https%2F</url>
    <content type="text"><![CDATA[问题由来 由于微信小程序的网络请求不能通过XMLHTTPRequest对象或是通常的一些封装好的网络请求库（如axios，fetch，jquery等等），只能使用微信小程序运行环境提供的wx.request()方法进行网络请求；然而该方法只能接受https协议的域名作为合法请求域名，所以首先必须要有SSL证书以及可以配置SSL证书的主机。 所以问题来了，阿里云所有的虚拟主机都不能对服务器端配置进行修改，所以即便申请到了SSL密钥也没法进行配置，因此只能间接配置； 解决方案一：CDN 从网上搜了很多答案，几乎都提到了直接利用CDN加速服务，将流量转换成https，手动配置好申请的SSL证书即可。 然而，我在腾讯云上配置好CDN和SSL证书后，使用https对域名进行访问会报错，所以也不知道哪一步弄错了，心累…… 解决方案二：coding.net 突然想到github提供了一个支持https访问的个人域名https://username.github.io，然而这只是静态页面，无法对api请求做出反应。 不过，好在国内也有一个不错的git代码托管网站——https://coding.net/，不仅支持静态page，而且前不久还开放了动态page（支持PHP），而且默认提供https支持，简直太慷慨了……、 coding.net的动态page 直接对某个git项目设置为动态page后，就能得到一个随机分配的https域名，由于被滥用，微信貌似对这类域名进行了屏蔽（果然很多人早就开始利用这个了），不过好在还可以进行自定义域名绑定，用自己备案好的域名绑定就可以了。 真是帮了大忙，把php文件上传进去就可以在微信小程序进行API访问了！ 后话 所以还是要好好支持一下coding.net，功能确实强大；除了动态page，webIDE也是很不错的！]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中的继承方法]]></title>
    <url>%2Fpost%2Fjs-inherit%2F</url>
    <content type="text"><![CDATA[继承是面向对象编程中很重要的一个概念，通过继承可以把父类中的属性和方法传递到子类中，就像是『财产继承』； 原型链继承 由于原型链的特性，只需要在子类的原型链上加入父类的属性和方法，子类就自动能够访问这些属性和方法，如： 1234567891011121314151617181920function SuperType()&#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;;function SubType()&#123; this.subproperty = false;&#125;//继承了 SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function ()&#123; return this.subproperty;&#125;;var instance = new SubType();alert(instance.getSuperValue()); //true 一般是通过将父类的实例赋予给子类的原型（prototype），从而将父类的属性和方法加入至原型中； 疑问：一般而言，一个构造函数的原型（prototype）的构造器（constructor）会指向本身，但是如果该构造函数作为子类按照上述方法改变原型，其原型的构造器便指向了其父类的构造器; 借用构造函数 通过call或apply函数的特性，调用父类构造函数，将子类作为this参数传入，从而将父类的属性和方法绑定到子类，如： 1234567891011121314function SuperType()&#123; this.colors = ["red", "blue", "green"];&#125;function SubType()&#123;//继承了 SuperType SuperType.call(this);&#125;var instance1 = new SubType();instance1.colors.push("black");console.log(instance1.colors); //"red,blue,green,black"var instance2 = new SubType();console.log(instance2.colors); //"red,blue,green" 组合继承 组合继承（combination inheritance），有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承（传入参数）。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sass的安装与配置]]></title>
    <url>%2Fpost%2Fsass-install%2F</url>
    <content type="text"><![CDATA[安装 安装Ruby 由于Sass和Compass都是依赖于ruby的，所以首先得安装ruby；windows直接去官网下载或者使用rubyinstaller，推荐使用后者，下载一键配置，关键是下载速度快！ 在ruby中安装各种包都是基于gem命令（类似于node.js中的npm），由于服务器在国外，安装包的速度当然慢的要死，所以要更换一下镜像，推荐使用ruby-China的镜像（淘宝的镜像今后不会维护了）： 更换前最好把自带的镜像删除（可以用gem source --remove命令移除），查看镜像列表可以使用命令行gem source -l； 1gem source -a https://gems.ruby-china.org 安装Sass 1gem sass 安装compass 1gem compass 创建compass工程 通过compass create可以创建一个compass工程； 1compass create projectNmae 创建后会生成一个名为projectName的文件夹，该文件夹代表了一个compass和sass工程，该文件夹下还会有一些默认生成的文件夹和文件： 1234567|---stylesheets |---*.css|---sass |---*.scss|---.sass-cache |---|---config.rb 这些文件夹的名称可以通过命令行参数进行定制，也可以直接在config.rb配置文件中进行设定； 1compass create -sass-dir "sass" -css-dir "css" -javascript-dir "js" -image-dir "img" 也可以创建一个空的compass工程，即没有一些预定的css和scss文件； 1compass create --bare config.rb文件 config.rb文件时compass工程的核心，它设定了如何编译sass文件，怎么生成css文件； 一个常见的配置文件如下： 12345678910111213141516171819202122require 'compass/import-once/activate'# 通过 require 命令导入其它的compass插件# http_path代表工程根目录的路径http_path = "/"css_dir = "css"sass_dir = "sass"images_dir = "images"javascripts_dir = "javascripts"# cache代表是否开启sass编译缓存，默认开启（true）cache = false# output_style代表css文件输出样式# output_style = :expanded or :nested or :compact or :compressed# 是否开启资源相对路径功能# relative_assets = true# 是否在css文件中选择器的位置显示调试注释，默认开启line_comments = false css输出样式有四种：:expanded，:nested，:compact，:compressed； 在webStorm中配置compass工程 找到setting-language-stylesheets-compass，设置正确的compass安装路径和compass工程的config.rb文件路径；要注意的是compass安装路径指的是compass.bat文件所在地方，如：D:\Ruby\bin\compass.bat； 到setting-tool-File Watchers中新增一个Compass Scss的实例，以实现自动监视scss文件的改动并进行实时编译； 编译 当编译的时候，对于文件名以下划线_开头的.scss文件是不会编译的；且编译后的.css文件名与.scss的文件名一致！]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[灵活的flex布局]]></title>
    <url>%2Fpost%2Fcss3-flex%2F</url>
    <content type="text"><![CDATA[基本概念 flexbox模型又称伸缩布局盒模型，是css3新引入的一种布局机制，可以很方便的进行多列布局；可以从两个角度来看待flex属性：一个就是flex容器，另一个就是flex项目。 flex容器：顾名思义就是用来承载flex布局的容器盒子，即其内部的元素遵循flex布局机制； flex项目：即装在flex容器中的元素； flex容器 flex容器有6种属性来控制其内部元素的整体排布规定： flex-direction：flex容器的主轴方向（row | row-reverse | column | column-reverse）； 选项 作用 row 水平方向（从左开始） row-reverse 逆水平方向（从右开始） column 竖直方向（从上开始） column-reverse 逆竖直方向（从下开始） flex-wrap：flex容器的换行方式（nowrap | wrap | wrap-reverse）； 选项 作用 nowrap 不换行，即当主轴尺寸固定时，当空间不足时，项目尺寸会随之调整而并不会挤到下一行。 wrap 项目主轴总尺寸超出容器时换行，第一行在上方 wrap-reverse 换行，第一行在下方 flex-flow：上面两个的总和（主轴方向+换行方式） 123.container &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-content：主轴的对齐方式（flex-start | flex-end | center | space-between | space-around） 选项 作用 flex-start 向主轴方向的起点的方向对齐 flex-end 向主轴方向的终点的方向对齐 center 居于主轴的中间 space-betwwen 两端对齐，项目之间的间隔相等，即剩余空间等分成间隙。 sapce-around 每个项目两侧的间隔相等，所以项目之间的间隔比项目与边缘的间隔大一倍。 align-items：侧轴的对齐方式（flex-start | flex-end | center | baseline | stretch） 选项 作用 flex-start 向侧轴方向的起点的方向对齐 flex-end 向侧轴方向的终点的方向对齐 center 居于侧轴的中间 baseline 项目的第一行文字的基线对齐 stretch 默认值，即如果项目未设置高度或者设为 auto，将占满整个容器的高度。 align-content：多根轴的对齐方式（轴与轴之间，与主轴平行的轴，开启换行才有效！），选项有：flex-start | flex-end | center | space-between | space-around | stretch； flex项目 order：定义项目在容器中的排列顺序，数值越小，排列越靠前，默认值为 0； 123.item &#123; order: &lt;integer&gt;;&#125; flex-basis：定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间，默认值为auto；auto，即项目本来的大小, 这时候 item 的宽高取决于 width 或 height 的值。 123.item &#123; flex-basis: &lt;length&gt; | auto;&#125; flex-grow：定义项目的放大比例 flex-shrink：定义了项目的缩小比例 flex：flex-grow, flex-shrink 和 flex-basis的简写 align-self：允许单个项目有与其他项目不一样的对齐方式 flex布局示例 柱状统计图： 123456789101112131415161718192021222324252627282930313233343536373839#container&#123; display: flex; flex-direction: row; justify-content: center; align-items: flex-end; width: 400px; height: 300px; border: 1px solid #333333;&#125;.col&#123; width: 40px; margin: 0 10px; transition: all .3s ease-in;&#125;.col:hover&#123; cursor: pointer; opacity: 0.8; box-shadow: 2px 2px 10px darkblue, -2px -2px 10px darkblue;&#125;.col:nth-of-type(1)&#123; height: 50%; background-color: #ff3366;&#125;.col:nth-of-type(2)&#123; height: 75%; background-color: #6699cc;&#125;.col:nth-of-type(3)&#123; height: 23%; background-color: darkorange;&#125;.col:nth-of-type(4)&#123; height: 61%; background-color: lightseagreen;&#125;.col:nth-of-type(5)&#123; height: 31%; background-color: lightsalmon;&#125; 1234567&lt;div id="container"&gt; &lt;div class="col"&gt;&lt;/div&gt; &lt;div class="col"&gt;&lt;/div&gt; &lt;div class="col"&gt;&lt;/div&gt; &lt;div class="col"&gt;&lt;/div&gt; &lt;div class="col"&gt;&lt;/div&gt;&lt;/div&gt; 参考文档 30 分钟学会 Flex 布局（图文丰富，一目了然！）]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie与webStorage]]></title>
    <url>%2Fpost%2Fcookie-webStorage%2F</url>
    <content type="text"><![CDATA[cookie Cookie 是一些数据, 存储于你电脑上的文本文件中。 当 web 服务器向浏览器发送 web 页面时，在连接关闭后，服务端不会记录用户的信息。 Cookie 的作用就是用于解决 『如何记录客户端的用户信息』: 1. 当用户访问 web 页面时，他的名字可以记录在 cookie 中。 2. 在用户下一次访问该页面时，可以在 cookie 中读取用户访问记录。 一个cookie是以键值对的形式存储的，如： 1name = xxf cookie的不足 cookie的大小限制在4KB； cookie会伴随http请求一起被发送，会浪费网络带宽 cookie的正确操作比较困难 session 所谓session，指的就是用户在浏览某个网站时，从进入网站到关闭浏览器所经过的这段时间，也就是用户浏览这个网站所花费的时间。 Web Storage Web Storage 是HTML5新增的一种用来在客户端本地进行数据保存的功能。 分为sessionStorage和localStorage两种，其中sessionStorage保存期限（即有效使用期限）即一次session的时间；而localStorage则会直接将数据保存到客户端本地的硬件设备（通常是硬盘）中，浏览器关闭后也不会销毁，下次打开浏览器时依然能被使用！ sessionStorage为临时保存 localStorage为永久保存（没有默认保存期限？） Web Storage 是按浏览器来保存数据的，即不同浏览器之间保存的Web Storage不能互用！ sessionStorage和localStorage是window对象的属性，不需要声明定义！ api操作 保存数据：使用setItem()方法来保存一对数据，如： 12// 第一个参数为键名，第二个参数为键值sessionStorage.setItem("name", "xxf"); 也可以直接对sessionStorage对象设定自定义属性来保存数据： 1sessionStorage.name = "xxf"; 读取数据：使用getItem()方法来读取某键名对应的数据： 1console.log(sessionStorage.getItem("name")); // xxf 同理，也可以直接访问对象属性来获取数据： 1console.log(sessionStorage.name); // xxf 删除单个数据：使用removeItem()方法删除某一数据： 1sessionStorage.removeItem("name"); 删除所有数据：使用clear()方法删除所有的数据： 1sessionStorage.clear(); 按照索引获取对应数据的键名：使用方法key()： 参考文档 HTML5 Web 存储 | 菜鸟教程]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>html5</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对js原型的一些理解]]></title>
    <url>%2Fpost%2Fjs-prototype%2F</url>
    <content type="text"><![CDATA[个人感悟 构造器函数的constructor等于其本身 1console.log(Function.constructor === Function); // true 某一构造器的实例，其constructor指向该构造器（从实例的角度来看可以理解为指向上一级的构造器） 1234567function foo() &#123; this.name = "xxf";&#125;var f1 = new foo();console.log(f1.constructor === foo); // true 只有自身能充当构造器的才会有prototype 只要是函数（包括匿名函数）都可以做构造器 12345678var fun = new Function();var fun1 = new fun(); // fun1为一个普通对象，而非函数对象console.log(fun1); // anonymous &#123;&#125;console.log(fun); // [Function: anonymous]console.log(fun1.constructor === fun); // trueconsole.log(fun1.prototype); // undefined// fun1 为函数的实例对象，所以并不具有prototype 需要注意的是new Function()直接返回匿名函数对象（而非匿名函数的实例！），所以与直接赋值为匿名函数完全不同（直接赋值匿名函数相当于构造了一个函数对象的实例！）： 1234567var fun = function () &#123;&#125;; // 相当于 function fun()&#123;&#125;，但是没有函数声明提升！！！var fun1 = new fun();console.log(fun); // [Function: fun]console.log(fun1); // fun &#123;&#125; Object实例对象的constructor为[Function: Object] 1console.log(&#123;&#125;.constructor); // [Function: Object] 只要是原型（prototype），其constructor必然指向下一级（即若该原型为Object实例对象，其constructor并不会指向[Function: Object]） 某个对象原型（prototype）的constructor等于该对象本身 123456var fun = new Function();console.log(fun.prototype); // anonymous &#123;&#125;console.log(typeof fun.prototype); // objectconsole.log(fun.prototype.constructor); // [Function: anonymous]console.log(fun.prototype.constructor === fun); // true 属性__proto__指的是上一级构造器的prototype 12345var fun = new Function();console.log(fun.prototype); // anonymous &#123;&#125;console.log(fun.prototype.__proto__); // &#123;&#125;console.log(fun.prototype.__proto__.constructor); // [Function: Object] 从上面的例字可以看出fun的prototye确实是object类型的，但是直接使用construcor并不能得到想要的结果，通过使用属性__proto__就能准确得到上一级构造器的原型！ 个人总结 参考文档 js中__proto__和prototype的区别和关系？ - 苏墨橘的回答 - 知乎]]></content>
      <categories>
        <category>探索</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于jsonp]]></title>
    <url>%2Fpost%2Fjsonp%2F</url>
    <content type="text"><![CDATA[Jsonp(JSON with Padding) 是 json 的一种&quot;使用模式&quot;，常用来进行跨域请求json数据。 原理 利用script标签可以跨域的特点，返回一段js代码对服务器获取的json数据进行处理。 举个栗子 比如： 123456789&lt;?phpheader('Content-type: application/json');//获取回调函数名$jsoncallback = htmlspecialchars($_REQUEST ['jsoncallback']);//json数据$json_data = '["customername1","customername2"]';//输出jsonp格式的数据echo $jsoncallback . "(" . $json_data . ")";?&gt; 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;JSONP 实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="divCustomers"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; function callbackFunction(result, methodName)&#123; var html = '&lt;ul&gt;'; for(var i = 0; i &lt; result.length; i++)&#123; html += '&lt;li&gt;' + result[i] + '&lt;/li&gt;'; &#125; html += '&lt;/ul&gt;'; document.getElementById('divCustomers').innerHTML = html; &#125;&lt;/script&gt;&lt;script src="http://someurl/jsonp.php?jsoncallback=callbackFunction"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 从上面例子可以看出，实际上就是从服务端获取json数据，然后在服务器端把json数据插入到回调函数中作为参数，然后服务端返回一段js代码给客户端的script标签，最后作为js代码执行。也就是间接的使用json数据！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于js闭包]]></title>
    <url>%2Fpost%2Fjs-closure%2F</url>
    <content type="text"><![CDATA[闭包 闭包就是（在外部？）引用特定的局部变量实例的功能； 闭包是函数和声明该函数的词法环境的组合，这个环境包含了这个闭包创建时所能访问的所有局部变量。——MDN https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures 闭包是指有权访问另一个函数作用域中的变量的函数。——《js高级程序设计第三版》 一般在js中，闭包用来在外部访问某一函数中的局部变量，该局部变量被保存在一个内部函数块中；如： 123456789101112131415function makeAdder(x) &#123; return function(y) &#123; return x + y; &#125;;&#125;var add5 = makeAdder(5);/*5被赋值给局部变量x，局部变量x被保存在闭包环境中而闭包被赋值给add5，因此函数add5内还能继续使用x（=5）*/var add10 = makeAdder(10);console.log(add5(2)); // 7console.log(add10(2)); // 12 使用场景 通常使用只有一个方法的对象的地方，都可以使用闭包；（将数据与函数进行绑定的时候） 闭包很有用，因为他允许将函数与其所操作的某些数据（环境）关联起来。这显然类似于面向对象编程。在面向对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。——MDN 12345678910111213function makeSizer(size) &#123; return function() &#123; document.body.style.fontSize = size + 'px'; &#125;;&#125;var size12 = makeSizer(12);var size14 = makeSizer(14);var size16 = makeSizer(16);document.getElementById('size-12').onclick = size12;document.getElementById('size-14').onclick = size14;document.getElementById('size-16').onclick = size16; 模拟私有方法：即只有实例才能使用的方法，且不能直接修改对象的方法！（对比将方法绑定到this对象或原型prototype上，那样可以通过直接修改对象方法从而影响所有的实例！此谓之私有？） 123456789101112131415161718192021222324252627var makeCounter = function() &#123; var privateCounter = 0; function changeBy(val) &#123; privateCounter += val; &#125; return &#123; increment: function() &#123; changeBy(1); &#125;, decrement: function() &#123; changeBy(-1); &#125;, value: function() &#123; return privateCounter; &#125; &#125; &#125;;var Counter1 = makeCounter();var Counter2 = makeCounter();console.log(Counter1.value()); /* logs 0 */Counter1.increment();Counter1.increment();console.log(Counter1.value()); /* logs 2 */Counter1.decrement();console.log(Counter1.value()); /* logs 1 */console.log(Counter2.value()); /* logs 0 */ 注意事项 如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数组属性和方法]]></title>
    <url>%2Fpost%2Fjs-array%2F</url>
    <content type="text"><![CDATA[js中的数组实际上就是一个Array对象的实例，继承来自Array.prototype的属性和方法！ 属性 length（Array.prototype.length）：返回数组的长度；注意只有数字索引或者能被转换为数字的索引才会被计入！ 12345678var arr = [];arr[0] = 1;arr[3] = "xxf";arr["name"] = "xuefeng";arr.length; // 4arr[1]; // undefinedarr.name; // xuefeng js数组的长度是根据索引中最大的数字决定的（？），且中间没有被赋值的索引被访问时的值默认为undefined！且其中的非数字索引或者对象属性不会被计入到length中的，但是可以强制转化为十进制数字的索引是有效的： 1234var arr = [];arr["12"] = "cctv"; // 索引"12"可以强制转化为数字12！arr.length; // 13 constructor（Array.prototype.constructor）：返回的就是Array本身！即所有数组实例的构造器都是继承自Array对象！ 12var arr = [1, 2, 3];arr.constructor; // [Function: Array] 访问方法 所有的访问方法绝对不会改变调用它们的对象的值，只会返回一个新的数组或者返回一个其它的期望值。 concat方法：用于合并多个数组或多个元素，返回一个新的数组； 12345/*接受一个或多个数组或元素与原数组合并返回到一个新的数组！*/Array.prototype.concat(val1[, val2[, ...[, valN]]]); join方法：连接数组内所有的元素并返回一个字符串；数组中元素值为null或undefined的，该元素则转化为空字符串！ 12345678910111213/*separator为连接字符，可以不填当不填时separator参数时，默认为","当连接字符为空字符串""时，元素之间没有连接字符，直接相连*/Array.prototype.join(separator);//Examplevar arr = [1, 2, 3];arr.join(); // "1,2,3"arr.join(""); // "123"arr.join("-"); // "1-2-3"arr.join(", "); // "1, 2, 3" （最后一个空格自动去除？） slice方法：返回一个从开始到结束（不包括结束索引的那个元素！）选择的数组的一部分浅拷贝到一个新数组对象。原始数组不会被修改。 12345678910111213141516/*begin和end参数分别为开始和结束索引，都是可选的当两个参数都不填时，直接复制整个数组当end参数不填时，复制从begin开始到最后一个的元素begin和end的索引可以为负，代表倒数第几个元素！*/Array.prototype.slice([begin[, end]]);//Examplevar arr = [1, 2, 3];arr.slice(); // [1, 2, 3]arr.slice(1); // [2, 3]arr.slice(0, 2); // [1, 2]arr.slice(0, -1); // [1, 2] toString方法：相当于arr.join()，即直接用,连接所有元素返回一个字符串； indexOf方法：返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1； 123456/*elem参数为所查找的元素startIndex为开始查找的索引，可以为负，同上当startIndex超出数组length时直接返回-1！*/Array.prototype.indexOf(elem[, startIndex=0]); 修改器方法 所有的修改器方法会改变调用它们的对象自身的值！ push方法：在数组的末尾添加一个或多个元素，并返回数组的新长度； pop方法：删除数组的最后一个元素，并返回这个元素； reserve方法：颠倒数组中所有元素的顺序，并返回颠倒后的数组； shift方法：删除数组中第一个元素，并返回这个元素； unshift方法：在数组的开头添加一个或多个元素，并返回数组的新长度； sort方法：对数组元素进行排序，并返回当前数组； 12345678910111213141516171819202122232425262728293031323334353637383940/*compareFunction参数为比较函数，是可选的；若不填参数，默认按Unicode码进行排序；compareFunction(a, b)若大于0，则b在a之前；若小于0，则a在b之前；若等于0，则a与b的相对位置不变！*/Array.prototype.sort([compareFunction]);//MDN Examplevar fruit = ['cherries', 'apples', 'bananas'];fruit.sort(); // ['apples', 'bananas', 'cherries']var scores = [1, 10, 21, 2]; scores.sort(); // [1, 10, 2, 21]// 注意10在2之前,// 因为在 Unicode 指针顺序中"10"在"2"之前var things = ['word', 'Word', '1 Word', '2 Words'];things.sort(); // ['1 Word', '2 Words', 'Word', 'word']// 在Unicode中, 数字在大写字母之前,// 大写字母在小写字母之前.//要想让数字数组按照数值从小到大排序//可以自定义一个compareFunction/* 当a &gt; b时，返回值大于0 当a &lt; b时，返回值小于0 a = b时，返回值为0*/function compare(a, b)&#123; return a - b;&#125;var arr = [4, 1, 12, 9];arr.sort(compare); // [1, 4, 9, 12] splice方法：通过删除现有元素和/或添加新元素来更改一个数组的内容，并且返回被删除的元素（以数组的形式）； 1234567891011121314151617181920212223array.splice(start)// 删除数组从start开始到末尾的所有元素，start可以为负值array.splice(start, deleteCount) /* 删除数组从start开始的deleteCount个元素；deleteCount可以为0，即不删除任何元素；当deleteCount大于从start开始到末尾元素的个数，则删除从start开始到末尾的所有元素*/array.splice(start, deleteCount, item1, item2, ...)/*item1,irem2,...为要添加的元素从start开始添加*///示例：删除数组中的某一个元素var arr = [1, 2, 3];arr.splice(1, 1); // 2 （即删除数组中索引为1的元素）//MDN示例：从第2位开始删除所有的元素var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];var removed = myFish.splice(2);// 运算后的myFish ：["angel", "clown"] // 被删除的元素数组： ["mandarin", "sturgeon"] 迭代方法 在下面的众多遍历方法中，有很多方法都需要指定一个回调函数作为参数。在每一个数组元素都分别执行完回调函数之前，数组的length属性会被缓存在某个地方，所以，如果你在回调函数中为当前数组添加了新的元素，那么那些新添加的元素是不会被遍历到的。此外，如果在回调函数中对当前数组进行了其它修改，比如改变某个元素的值或者删掉某个元素，那么随后的遍历操作可能会受到未预期的影响。总之，不要尝试在遍历过程中对原数组进行任何修改，虽然规范对这样的操作进行了详细的定义，但为了可读性和可维护性，请不要这样做。（MDN） forEach方法：为数组中的每个元素执行一次回调函数；该方法没有返回值！ 1234567891011121314/*callback为回调函数thisArg为可选参数，作为callback函数中this对象进行使用*/array.forEach(callback[, thisArg]);callback = function(currentValue, index, array)&#123; //do something&#125;;/*currentValue为当前遍历的元素值index为当前遍历的元素索引array为所遍历的数组本身*/ every方法：如果数组中的每个元素都满足测试函数，则返回true，否则返回 false；该方法不会改变原数组！ 1234/*参数同上*/arr.every(callback[, thisArg]); every方法为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 false（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。callback只会为那些已经被赋值的索引调用。不会为那些被删除或从来没被赋值的索引调用。（MDN） some方法：如果数组中至少有一个元素满足测试函数，则返回 true，否则返回 false。 1arr.some(callback[, thisArg]); filter方法：将所有在过滤函数中返回true 的数组元素放进一个新数组中并返回。 1234567891011//语法var new_array = arr.filter(callback[, thisArg]);//MDN Examplefunction isBigEnough(value) &#123; return value &gt;= 10;&#125;var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);// filtered is [12, 130, 44] map方法：返回一个由回调函数的返回值组成的新数组； 12345678var new_array = arr.map(function callback(currentValue, index, array) &#123; // Return element for new_array &#125;[, thisArg]);// MDN实例：求每个元素的平方var numbers = [1, 4, 9];var roots = numbers.map(Math.sqrt);// roots的值为[1, 2, 3], numbers的值仍为[1, 4, 9] reduce方法： 12345678910111213141516171819/*callback为回调函数，有四个参数initialValue为可选参数，为累计值的初始值！*/arr.reduce(callback[, initialValue]);/*accumulator：累加器累加回调的返回值;它是上一次调用回调时返回的累积值，或initialValuecurrentValue：数组中正在处理的元素currentIndex（可选）：数组中正在处理的当前元素的索引。如果提供了initialValue，则索引号从0开始，否则为索引从1开始array：调用reduce的数组*/callback = function(accumulator, currentValue, currentIndex, array)&#123; /* do something */ return /* some value */;&#125; 回调函数第一次执行时，accumulator 和currentValue的取值有两种情况：调用reduce时提供initialValue，accumulator取值为initialValue，currentValue取数组中的第一个值；没有提供 initialValue，accumulator取数组中的第一个值，currentValue取数组中的第二个值。（MDN） find方法：返回数组中满足提供的测试函数的第一个元素的值，否则返回 undefined。 12345678910111213/*callback为回调函数，参数分别为（val，index，array）thisArg用来指定callback的this参数*/arr.find(callback[, thisArg]);function enough(val) &#123; return val &gt; 20;&#125;var arr = [12, 16, 6, 23, 8, 29];console.log(arr.find(enough)); // 23 参考文档 Array - JavaScript | MDN]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>
