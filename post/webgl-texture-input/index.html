<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"note.xiexuefeng.cc","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.13.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":true,"nav":null,"activeClass":"utterances"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"manual","top_n_per_article":-1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="前言 在webGL中，纹理有两种类型，一种是2d的，另一种是天空盒类型的。纹理除了用于给物体表面贴图之外，还可以用于数据传输，十分有用。 纹理数据的来源可以是图片、视频、帧缓冲、canvas甚至还可以是数组，对于着色器而言，纹理就是一类特定的数据，在着色器可以使用取样器来进行数据取样（解析）。">
<meta property="og:type" content="article">
<meta property="og:title" content="输入纹理资源">
<meta property="og:url" content="https://note.xiexuefeng.cc/post/webgl-texture-input/index.html">
<meta property="og:site_name" content="snowdream">
<meta property="og:description" content="前言 在webGL中，纹理有两种类型，一种是2d的，另一种是天空盒类型的。纹理除了用于给物体表面贴图之外，还可以用于数据传输，十分有用。 纹理数据的来源可以是图片、视频、帧缓冲、canvas甚至还可以是数组，对于着色器而言，纹理就是一类特定的数据，在着色器可以使用取样器来进行数据取样（解析）。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.xiexuefeng.cc/markdown/20200209164113.png?imageslim">
<meta property="article:published_time" content="2020-02-09T08:15:38.000Z">
<meta property="article:modified_time" content="2020-05-30T08:18:14.343Z">
<meta property="article:author" content="xuefeng">
<meta property="article:tag" content="webGL">
<meta property="article:tag" content="纹理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.xiexuefeng.cc/markdown/20200209164113.png?imageslim">


<link rel="canonical" href="https://note.xiexuefeng.cc/post/webgl-texture-input/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://note.xiexuefeng.cc/post/webgl-texture-input/","path":"post/webgl-texture-input/","title":"输入纹理资源"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>输入纹理资源 | snowdream</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">snowdream</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">record and share</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text"> 前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%B9%E7%90%86%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="nav-number">2.</span> <span class="nav-text"> 纹理坐标系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E4%B8%AA%E7%BA%B9%E7%90%86%E8%BE%93%E5%85%A5"><span class="nav-number">3.</span> <span class="nav-text"> 单个纹理输入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2d%E7%BA%B9%E7%90%86%E8%BE%93%E5%85%A5%E7%9A%84%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B"><span class="nav-number">3.1.</span> <span class="nav-text"> 2D纹理输入的一般流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%BA%B9%E7%90%86%E8%B5%84%E6%BA%90%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="nav-number">3.2.</span> <span class="nav-text"> 不同类型纹理资源的加载流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90"><span class="nav-number">3.2.1.</span> <span class="nav-text"> 图片资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90"><span class="nav-number">3.2.2.</span> <span class="nav-text"> 视频资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#imagedata%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.2.3.</span> <span class="nav-text"> ImageData对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A7%E7%BC%93%E5%86%B2"><span class="nav-number">3.2.4.</span> <span class="nav-text"> 帧缓冲</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A9%E7%A9%BA%E7%9B%92%E7%BA%B9%E7%90%86%E8%BE%93%E5%85%A5%E7%9A%84%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B"><span class="nav-number">3.3.</span> <span class="nav-text"> 天空盒纹理输入的一般流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A9%E7%A9%BA%E7%9B%92%E7%BA%B9%E7%90%86%E8%B5%84%E6%BA%90%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="nav-number">3.4.</span> <span class="nav-text"> 天空盒纹理资源的加载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E7%BA%B9%E7%90%86%E8%BE%93%E5%85%A5"><span class="nav-number">4.</span> <span class="nav-text"> 多个纹理输入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">4.1.</span> <span class="nav-text"> 注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="nav-number">5.</span> <span class="nav-text"> 参考文档</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="xuefeng"
      src="/images/photo.jpg">
  <p class="site-author-name" itemprop="name">xuefeng</p>
  <div class="site-description" itemprop="description">时不我待</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">109</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">81</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/xxf1996" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xxf1996" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://note.xiexuefeng.cc/post/webgl-texture-input/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/photo.jpg">
      <meta itemprop="name" content="xuefeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="snowdream">
      <meta itemprop="description" content="时不我待">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="输入纹理资源 | snowdream">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          输入纹理资源
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-09 16:15:38" itemprop="dateCreated datePublished" datetime="2020-02-09T16:15:38+08:00">2020-02-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8E%A2%E7%B4%A2/" itemprop="url" rel="index"><span itemprop="name">探索</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>在<code>webGL</code>中，纹理有两种类型，一种是<code>2d</code>的，另一种是天空盒类型的。纹理除了用于给物体表面贴图之外，还可以用于数据传输，十分有用。</p>
<p>纹理数据的<strong>来源</strong>可以是图片、视频、帧缓冲、<code>canvas</code>甚至还可以是数组，对于着色器而言，纹理就是一类特定的数据，在着色器可以使用取样器来进行数据取样（解析）。</p>
<span id="more"></span>
<h2 id="纹理坐标系"><a class="markdownIt-Anchor" href="#纹理坐标系"></a> 纹理坐标系</h2>
<p><img src="https://pic.xiexuefeng.cc/markdown/20200209164113.png?imageslim" alt="20200209164113" /></p>
<p>如上图所示（<a target="_blank" rel="noopener" href="https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/06%20Textures/">图片来源</a>），纹理坐标系的原点位于<strong>纹理区域</strong>的<em>左下角</em>，然后<code>s</code>轴从左往右逐渐增大，范围为<code>[0, 1]</code>；同理，<code>t</code>轴从下往上逐渐增大，范围也为<code>[0, 1]</code>。</p>
<p>记住纹理坐标系的特点能便于纹理数据的取样以及坐标系的变换，因为纹理坐标系和<code>webGL</code>的其他坐标系的特点不一样，如果需要将<strong>纹理映射到目标坐标系</strong>就需要进行坐标系变换了。</p>
<h2 id="单个纹理输入"><a class="markdownIt-Anchor" href="#单个纹理输入"></a> 单个纹理输入</h2>
<h3 id="2d纹理输入的一般流程"><a class="markdownIt-Anchor" href="#2d纹理输入的一般流程"></a> 2D纹理输入的一般流程</h3>
<ol start="0">
<li>
<p>加载纹理资源或创建纹理资源；</p>
</li>
<li>
<p><strong>创建纹理缓冲</strong>：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> textureBuffer = gl.<span class="title function_">createBuffer</span>()</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>激活相应的纹理通道</strong>：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.<span class="title function_">activeTexture</span>(gl.<span class="property">TEXTURE0</span> + textureID)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>将纹理缓冲绑定到相应的纹理通道上</strong>：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.<span class="title function_">bindTexture</span>(gl.<span class="property">TEXTURE_2D</span>, textureBuffer)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>将纹理通道号传递给纹理取样器属性</strong>：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.<span class="title function_">uniform1i</span>(pos, textureID) <span class="comment">// pos指的是纹理取样器属性的地址</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>绑定纹理数据</strong>：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.<span class="title function_">texImage2D</span>(gl.<span class="property">TEXTURE_2D</span>, <span class="number">0</span>, gl.<span class="property">RGBA</span>, gl.<span class="property">RGBA</span>, gl.<span class="property">UNSIGNED_BYTE</span>, value)</span><br></pre></td></tr></table></figure>
<p><strong>注</strong>：这里的<code>texImage2D()</code>方法参数仅是举例，实际上该方法有多种参数形式，需要根据具体情况来设置！</p>
</li>
<li>
<p><strong>设置纹理取样参数</strong>：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gl.<span class="title function_">texParameteri</span>(gl.<span class="property">TEXTURE_2D</span>, gl.<span class="property">TEXTURE_WRAP_S</span>, gl.<span class="property">CLAMP_TO_EDGE</span>) <span class="comment">// 指定纹理S轴方向大小适应方式</span></span><br><span class="line">gl.<span class="title function_">texParameteri</span>(gl.<span class="property">TEXTURE_2D</span>, gl.<span class="property">TEXTURE_WRAP_T</span>, gl.<span class="property">CLAMP_TO_EDGE</span>) <span class="comment">// 指定纹理T轴方向大小适应方式</span></span><br><span class="line">gl.<span class="title function_">texParameterf</span>(gl.<span class="property">TEXTURE_2D</span>, gl.<span class="property">TEXTURE_MIN_FILTER</span>, gl.<span class="property">LINEAR</span>) <span class="comment">// 指定纹理缩小取样算法</span></span><br><span class="line">gl.<span class="title function_">texParameterf</span>(gl.<span class="property">TEXTURE_2D</span>, gl.<span class="property">TEXTURE_MAG_FILTER</span>, gl.<span class="property">LINEAR</span>) <span class="comment">// 指定纹理放大取样算法</span></span><br></pre></td></tr></table></figure>
<p>举的例子是比较常见的取样参数设置。</p>
</li>
</ol>
<p>对于<strong>着色器</strong>而言，只需要设置一个纹理取样器属性用来接收纹理数据即可，然后使用<code>texture2D()</code>函数来进行取样：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> u_Texture; <span class="comment">// 纹理取样器</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="type">vec4</span> textureColor = <span class="built_in">texture2D</span>(u_Texture, texturePos); <span class="comment">// 取样</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不同类型的纹理资源的输入流程基本一致，只是在<strong>加载步骤</strong>以及<strong>绑定纹理数据</strong>的时候有所不同。</p>
<h3 id="不同类型纹理资源的加载流程"><a class="markdownIt-Anchor" href="#不同类型纹理资源的加载流程"></a> 不同类型纹理资源的加载流程</h3>
<h4 id="图片资源"><a class="markdownIt-Anchor" href="#图片资源"></a> 图片资源</h4>
<p><strong>注</strong>：这里的图片资源指的是<code>&lt;img&gt;</code>元素（即<code>HTMLImageElement</code>对象），既包<code>DOM</code>中本身存在的元素，也包括通过<code>Image()</code>构造函数手动创建的元素。</p>
<p>图片资源需要在<strong>加载完成后</strong>才能绑定到纹理缓冲上去，可以利用<code>HTMLImageElement</code>对象自带的<code>onload</code>方法就能监听到图片数据加载完成的事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>()</span><br><span class="line"></span><br><span class="line">img.<span class="property">onload</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    gl.<span class="title function_">texImage2D</span>(gl.<span class="property">TEXTURE_2D</span>, <span class="number">0</span>, gl.<span class="property">RGBA</span>, gl.<span class="property">RGBA</span>, gl.<span class="property">UNSIGNED_BYTE</span>, img)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&#x27;img_path.png&#x27;</span></span><br></pre></td></tr></table></figure>
<p>没错，<code>HTMLImageElement</code>本身可以直接传入<code>texImage2D()</code>方法中做参数！而在<code>DOM</code>中获取到的<code>&lt;img&gt;</code>结点和利用<code>base64</code>字符串构建的图片也是一样的，需要在<code>onload</code>回调中才进行纹理数据的传递！</p>
<h4 id="视频资源"><a class="markdownIt-Anchor" href="#视频资源"></a> 视频资源</h4>
<p><strong>注</strong>：这里的视频资源指的是<code>&lt;video&gt;</code>元素（即<code>HTMLVideoElement</code>对象），既包含<code>DOM</code>中存在的元素也包括<code>createElement()</code>方法创建的<code>&lt;video&gt;</code>元素（<code>&lt;video&gt;</code>元素没有对应的构造函数！）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> video = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;video&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">videoLoaded</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    video.<span class="title function_">play</span>() <span class="comment">// 开始播放</span></span><br><span class="line">    gl.<span class="title function_">texImage2D</span>(gl.<span class="property">TEXTURE_2D</span>, <span class="number">0</span>, gl.<span class="property">RGBA</span>, gl.<span class="property">RGBA</span>, gl.<span class="property">UNSIGNED_BYTE</span>, video)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    video.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;canplaythrough&#x27;</span>, videoLoaded) <span class="comment">// 事件触发后马上解绑事件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">video.<span class="title function_">addEventListener</span>(<span class="string">&#x27;canplaythrough&#x27;</span>, videoLoaded) <span class="comment">// 监听视频缓冲是否能够进行播放了</span></span><br><span class="line">video.<span class="property">muted</span> = <span class="literal">true</span> <span class="comment">// 静音</span></span><br><span class="line">video.<span class="property">preload</span> = <span class="string">&#x27;auto&#x27;</span> <span class="comment">// 开启预加载</span></span><br><span class="line">video.<span class="property">src</span> = <span class="string">&#x27;video_path.mp4&#x27;</span> <span class="comment">// 写入视频地址</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>同样，<code>HTMLVideoElement</code>对象能够直接传入<code>texImage2D()</code>方法中做参数！</p>
</li>
<li>
<p><code>canplaythrough</code>事件会在视频缓冲到一定长度且能够播放时进行触发，因此可以以此来作为<strong>视频资源可用</strong>的依据，在这个回调里进行纹理数据的传递等操作。不过需要注意的是，该事件在开启<code>loop</code>后，会在视频每一次循环的开始被触发，因此最好将回调事件设置成一次性的。</p>
</li>
<li>
<p>设置<code>preload</code>属性为<code>auto</code>可用使得视频优先被加载（即使在未播放的状态下）。</p>
</li>
<li>
<p>在不需要声音信息的情况下可以开启<code>muted</code>属性！</p>
</li>
<li>
<p>需要注意的是，视频纹理信息并不会实时更新（其实一次传递就相当于传了当时正在播放的<strong>视频帧图像</strong>而已），因此需要在<strong>帧更新函数</strong>（如<code>requestAnimationFrame()</code>函数）中不停地更新当前视频资源到纹理缓冲中！更新的操作流程跟第一次传入类似，只不过<font color=red><strong>不需要再重复创建纹理缓冲</strong></font>了！</p>
</li>
</ul>
<h4 id="imagedata对象"><a class="markdownIt-Anchor" href="#imagedata对象"></a> ImageData对象</h4>
<p><code>ImageData</code>对象是一个用于描述<code>canvas</code>区域像素数据的数据结构。它含有以下属性：</p>
<ul>
<li><code>data</code>：一个<code>Uint8ClampedArray</code>类型的数组，数组中的元素按照<code>RGBA</code>的顺序排序。</li>
<li><code>width</code>：像素区域的宽度。</li>
<li><code>height</code>：像素区域的高度。</li>
</ul>
<p><code>ImageData</code>对象的<strong>来源</strong>有：</p>
<ul>
<li>
<p><code>canvas</code>上下文对象的<code>createImageData()</code>和<code>getImageData()</code>方法；此外<code>putImageData()</code>方法可以将数据间接地写入<code>ImageData</code>对象。</p>
</li>
<li>
<p><code>ImageData()</code>构造函数：</p>
<blockquote>
<p>new ImageData(array, width, height);</p>
</blockquote>
<ul>
<li><code>array</code>：像素数据，<code>Uint8ClampedArray</code>类型的数组；</li>
<li><code>width</code>：像素区域宽度；</li>
<li><code>height</code>：像素区域高度；</li>
</ul>
</li>
</ul>
<p>从来源就可以看出，<code>ImageData</code>类型的纹理既可以取自<code>canvas</code>，也可以直接将数组转换成<code>ImageData</code>，即<font color=red><strong>可以手动生成纹理数据</strong></font>！</p>
<p>同样地，<code>ImageData</code>对象可以作为<strong>参数</strong>直接传入<code>texImage2D()</code>方法中！如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> <span class="title class_">ImageData</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Uint8ClampedArray</span>(<span class="keyword">new</span> <span class="title class_">Uint8Array</span>(pixelList), width, height),</span><br><span class="line">    width,</span><br><span class="line">    height</span><br><span class="line">)</span><br><span class="line">gl.<span class="title function_">texImage2D</span>(gl.<span class="property">TEXTURE_2D</span>, <span class="number">0</span>, gl.<span class="property">RGBA</span>, gl.<span class="property">RGBA</span>, gl.<span class="property">UNSIGNED_BYTE</span>, img)</span><br></pre></td></tr></table></figure>
<h4 id="帧缓冲"><a class="markdownIt-Anchor" href="#帧缓冲"></a> 帧缓冲</h4>
<p>帧缓冲可以看做等同于屏幕画面的帧，具有显示帧的一切绘制操作，除了不能直接显示。而通过将纹理缓冲绑定到帧缓冲上，可以直接利用<code>webGL</code>的绘制<code>API</code>（包括着色器）来绘制出想要的纹理，然后传递该纹理数据！</p>
<p><strong>详细步骤</strong>可以参考——<a href="https://note.xiexuefeng.cc/post/webgl-fbo-texture">利用FBO传送粒子数据 | snowdream</a>。</p>
<h3 id="天空盒纹理输入的一般流程"><a class="markdownIt-Anchor" href="#天空盒纹理输入的一般流程"></a> 天空盒纹理输入的一般流程</h3>
<p>不同于<code>2D</code>纹理，天空盒（<code>skybox</code>）纹理实际上是一个立方体纹理，即包含六个正方形的<code>2D</code>纹理，而取样则是从立方体内部（中心点）通过<strong>射线方向</strong>来取样。</p>
<p>因此，天空盒纹理实际上就是由<code>6</code>张<code>2D</code>纹理组成的，因此输入的一般流程跟<code>2D</code>类似：</p>
<ol start="0">
<li>
<p>加载纹理资源或创建纹理资源；</p>
</li>
<li>
<p><strong>创建纹理缓冲</strong>：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> textureBuffer = gl.<span class="title function_">createBuffer</span>()</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>激活相应的纹理通道</strong>：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.<span class="title function_">activeTexture</span>(gl.<span class="property">TEXTURE0</span> + textureID)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>将纹理缓冲绑定到相应的纹理通道上</strong>：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.<span class="title function_">bindTexture</span>(gl.<span class="property">TEXTURE_CUBE_MAP</span>, textureBuffer)</span><br></pre></td></tr></table></figure>
<p><font color=red><strong>注意</strong></font>：这里的纹理类型为<strong>TEXTURE_CUBE_MAP</strong>！</p>
</li>
<li>
<p><strong>将纹理通道号传递给纹理取样器属性</strong>：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.<span class="title function_">uniform1i</span>(pos, textureID) <span class="comment">// pos指的是纹理取样器属性的地址</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>绑定纹理数据</strong>：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gl.<span class="title function_">texImage2D</span>(gl.<span class="property">TEXTURE_CUBE_MAP_POSITIVE_X</span>, <span class="number">0</span>, gl.<span class="property">RGBA</span>, gl.<span class="property">RGBA</span>, gl.<span class="property">UNSIGNED_BYTE</span>, images[<span class="number">0</span>]) <span class="comment">// 右</span></span><br><span class="line">gl.<span class="title function_">texImage2D</span>(gl.<span class="property">TEXTURE_CUBE_MAP_NEGATIVE_X</span>, <span class="number">0</span>, gl.<span class="property">RGBA</span>, gl.<span class="property">RGBA</span>, gl.<span class="property">UNSIGNED_BYTE</span>, images[<span class="number">1</span>]) <span class="comment">// 左</span></span><br><span class="line">gl.<span class="title function_">texImage2D</span>(gl.<span class="property">TEXTURE_CUBE_MAP_POSITIVE_Y</span>, <span class="number">0</span>, gl.<span class="property">RGBA</span>, gl.<span class="property">RGBA</span>, gl.<span class="property">UNSIGNED_BYTE</span>, images[<span class="number">2</span>]) <span class="comment">// 上</span></span><br><span class="line">gl.<span class="title function_">texImage2D</span>(gl.<span class="property">TEXTURE_CUBE_MAP_NEGATIVE_Y</span>, <span class="number">0</span>, gl.<span class="property">RGBA</span>, gl.<span class="property">RGBA</span>, gl.<span class="property">UNSIGNED_BYTE</span>, images[<span class="number">3</span>]) <span class="comment">// 下</span></span><br><span class="line">gl.<span class="title function_">texImage2D</span>(gl.<span class="property">TEXTURE_CUBE_MAP_POSITIVE_Z</span>, <span class="number">0</span>, gl.<span class="property">RGBA</span>, gl.<span class="property">RGBA</span>, gl.<span class="property">UNSIGNED_BYTE</span>, images[<span class="number">4</span>]) <span class="comment">// 前</span></span><br><span class="line">gl.<span class="title function_">texImage2D</span>(gl.<span class="property">TEXTURE_CUBE_MAP_NEGATIVE_Z</span>, <span class="number">0</span>, gl.<span class="property">RGBA</span>, gl.<span class="property">RGBA</span>, gl.<span class="property">UNSIGNED_BYTE</span>, images[<span class="number">5</span>]) <span class="comment">// 后</span></span><br></pre></td></tr></table></figure>
<p>可以看到，天空盒纹理在绑定纹理数据的时候要分别绑定<code>6</code>个<code>2D</code>纹理数据，每个纹理数据分别对应立方体的一个面，所以千万注意<font color=red><strong>不要把面的对应关系绑定错了</strong></font>！</p>
<ul>
<li><code>TEXTURE_CUBE_MAP_POSITIVE_X</code></li>
<li><code>TEXTURE_CUBE_MAP_NEGATIVE_X</code></li>
<li><code>TEXTURE_CUBE_MAP_POSITIVE_Y</code></li>
<li><code>TEXTURE_CUBE_MAP_NEGATIVE_Y</code></li>
<li><code>TEXTURE_CUBE_MAP_POSITIVE_Z</code></li>
<li><code>TEXTURE_CUBE_MAP_NEGATIVE_Z</code></li>
</ul>
</li>
<li>
<p><strong>设置纹理取样参数</strong>：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gl.<span class="title function_">texParameteri</span>(gl.<span class="property">TEXTURE_2D</span>, gl.<span class="property">TEXTURE_WRAP_S</span>, gl.<span class="property">CLAMP_TO_EDGE</span>) <span class="comment">// 指定纹理S轴方向大小适应方式</span></span><br><span class="line">gl.<span class="title function_">texParameteri</span>(gl.<span class="property">TEXTURE_2D</span>, gl.<span class="property">TEXTURE_WRAP_T</span>, gl.<span class="property">CLAMP_TO_EDGE</span>) <span class="comment">// 指定纹理T轴方向大小适应方式</span></span><br><span class="line">gl.<span class="title function_">texParameterf</span>(gl.<span class="property">TEXTURE_2D</span>, gl.<span class="property">TEXTURE_MIN_FILTER</span>, gl.<span class="property">LINEAR</span>) <span class="comment">// 指定纹理缩小取样算法</span></span><br><span class="line">gl.<span class="title function_">texParameterf</span>(gl.<span class="property">TEXTURE_2D</span>, gl.<span class="property">TEXTURE_MAG_FILTER</span>, gl.<span class="property">LINEAR</span>) <span class="comment">// 指定纹理放大取样算法</span></span><br></pre></td></tr></table></figure>
<p>举的例子是比较常见的取样参数设置。</p>
</li>
</ol>
<p>从上面流程可以看到，除了绑定纹理缓冲和绑定纹理数据和<code>2D</code>纹理略有不同之外，其它基本一致。</p>
<h3 id="天空盒纹理资源的加载"><a class="markdownIt-Anchor" href="#天空盒纹理资源的加载"></a> 天空盒纹理资源的加载</h3>
<p>纹理资源的来源和类型同上面一致；而加载方式也一样，只是要多注意<font color=red><strong>多个不同资源加载时</strong></font>需要等待所有资源全都加载完后才进行数据传递等操作！</p>
<p>以六张不同的纹理图片资源为例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> skybox = [</span><br><span class="line">    <span class="string">&#x27;1.png&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2.png&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;3.png&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;4.png&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;5.png&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;6.png&#x27;</span></span><br><span class="line">] <span class="comment">// 6张纹理图片地址</span></span><br><span class="line"><span class="comment">// 加载纹理图片</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadImages</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> skyList = [] <span class="comment">// 已加载成功的图片资源</span></span><br><span class="line">  skybox.<span class="title function_">forEach</span>(<span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>()</span><br><span class="line">    skyList.<span class="title function_">push</span>(img)</span><br><span class="line">    img.<span class="property">onload</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      i++</span><br><span class="line">      <span class="keyword">if</span> (i === <span class="number">6</span>) &#123; <span class="comment">// 所有纹理图片加载完后进行绘制</span></span><br><span class="line">        <span class="comment">// 在这里进行加载完成后的操作</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    img.<span class="property">src</span> = url</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这种方法是<strong>通过闭包</strong>的方式来判断图片是否已全部加载完成；当然，也可以<font color=#36f>将一个图片加载完成过程封装成一个<code>Promise</code>对象</font>，然后利用<code>Promise.all()</code>方法来执行所有图片加载完成的回调。</p>
<p>其它类型的纹理资源也是同理的，不再赘述。</p>
<h2 id="多个纹理输入"><a class="markdownIt-Anchor" href="#多个纹理输入"></a> 多个纹理输入</h2>
<p>输入多个纹理资源，实际上每个纹理资源的<strong>加载和传递等步骤</strong>同单个纹理资源的是一样的，不同的是多个纹理资源需要额外注意纹理通道的分配和纹理缓冲的对应等问题。</p>
<h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h3>
<ol>
<li>
<p><strong>纹理通道的分配</strong>：因为每个着色器内的<font color=red><strong>取样器连接的地址就是纹理通道</strong></font>，当多个纹理缓冲共用一个通道时，那么就相当于这个通道连接的所有取样器实际上都是共用一个纹理缓冲（最近更新数据那个纹理缓冲）；这显然是不可行的。因此需要给同一个<code>webGL</code>上下文内的所有纹理缓冲进行编号，可以设定一个类似于<code>ID</code>的<strong>自增属性</strong>（从<code>0</code>开始），在<code>TEXTURE0</code>常量上加上这个自增属性即可得到对应的纹理通道。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> textureID = <span class="number">0</span> <span class="comment">// 纹理通道的编号</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">let</span> textureBuffer = gl.<span class="title function_">createBuffer</span>()</span><br><span class="line">gl.<span class="title function_">activeTexture</span>(gl.<span class="property">TEXTURE0</span> + textureID)</span><br><span class="line">gl.<span class="title function_">bindTexture</span>(gl.<span class="property">TEXTURE_2D</span>)</span><br><span class="line">gl.<span class="title function_">uniform1i</span>(pos, textureID)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">textureID++ <span class="comment">// 创建并绑定完相应的纹理缓冲后编号自增</span></span><br></pre></td></tr></table></figure>
<p><code>TEXTURE0</code>常量指的就是<code>0</code>号纹理通道的地址，后面的纹理通道地址都是在此基础上自增的；上面只是举了一个最简单的例子，实际上可以声明一个纹理资源信息的类，直接将得到纹理编号绑定到纹理资源上。</p>
</li>
<li>
<p><strong>纹理缓冲的绑定</strong>：当需要对多个纹理资源中的某个纹理数据进行更新时，最好是不要重复再创建纹理缓冲，应该使用首次数据传递时用的那个缓冲对象；因此建议同上面类似，在<strong>第一次创建好纹理缓冲后将缓冲对象绑定到纹理资源信息上</strong>。</p>
</li>
</ol>
<h2 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h2>
<ol>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/texImage2D">WebGLRenderingContext.texImage2D() - Web API 接口参考 | MDN</a></li>
<li><a target="_blank" rel="noopener" href="https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/06%20Textures/">纹理 - LearnOpenGL-CN</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData/ImageData">ImageData() - Web API 接口参考 | MDN</a></li>
<li><a target="_blank" rel="noopener" href="https://webglfundamentals.org/webgl/lessons/webgl-2-textures.html">WebGL Using 2 or More Textures</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>xuefeng
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://note.xiexuefeng.cc/post/webgl-texture-input/" title="输入纹理资源">https://note.xiexuefeng.cc/post/webgl-texture-input/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/webGL/" rel="tag"># webGL</a>
              <a href="/tags/%E7%BA%B9%E7%90%86/" rel="tag"># 纹理</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/webgl-fbo-texture/" rel="prev" title="利用FBO传送粒子数据">
                  <i class="fa fa-chevron-left"></i> 利用FBO传送粒子数据
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/npm-use-and-error/" rel="next" title="使用npm的注意事项及错误收集">
                  使用npm的注意事项及错误收集 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
  <div class="languages">
    <label class="lang-select-label">
      <i class="fa fa-language"></i>
      <span>简体中文</span>
      <i class="fa fa-angle-up" aria-hidden="true"></i>
    </label>
    <select class="lang-select" data-canonical="" aria-label="选择语言">
      
        <option value="zh-CN" data-href="/post/webgl-texture-input/" selected="">
          简体中文
        </option>
      
        <option value="en" data-href="/en/post/webgl-texture-input/" selected="">
          English
        </option>
      
    </select>
  </div>


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xuefeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
  <script src='https://unpkg.com/mermaid@11.6.0/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'default' });
    }
  </script>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.2/katex.min.css" integrity="sha256-oWCabCfPd4Oi21wqZezBSz/anto4VYcJqc9sM9IzQTk=" crossorigin="anonymous">


<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"xxf1996/hexo-comment","issue_term":"pathname","theme":"github-dark"}</script>
<script src="/js/third-party/comments/utterances.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
